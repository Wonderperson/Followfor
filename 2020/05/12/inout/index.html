<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>输入输出流 | YOUR</title><meta name="description" content="流的定义以及C++流类和流对象程序中常用的 cin 和 cout，分别用于从键盘输入数据和向屏幕输出数据（简称为标准 I&#x2F;O）。除此之外，程序还可以从文件中读入数据，以及向文件中写入数据（简称为文件 I&#x2F;O)。 数据输入和输出的过程也是数据传输的过程。数据像水一样从一个地方流动到另一个地方，因此，在 C++ 中将此过程称为 “流（stream）”。 在 C++ 的标准类库中，将用于进行数据输入输出"><meta name="keywords" content="c++,输入输出"><meta name="author" content="Lee"><meta name="copyright" content="Lee"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/%E5%88%86%E7%B1%BB-%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="输入输出流"><meta name="twitter:description" content="流的定义以及C++流类和流对象程序中常用的 cin 和 cout，分别用于从键盘输入数据和向屏幕输出数据（简称为标准 I&#x2F;O）。除此之外，程序还可以从文件中读入数据，以及向文件中写入数据（简称为文件 I&#x2F;O)。 数据输入和输出的过程也是数据传输的过程。数据像水一样从一个地方流动到另一个地方，因此，在 C++ 中将此过程称为 “流（stream）”。 在 C++ 的标准类库中，将用于进行数据输入输出"><meta name="twitter:image" content="https://cdn.pixabay.com/photo/2020/03/27/15/31/norway-4973912_1280.jpg"><meta property="og:type" content="article"><meta property="og:title" content="输入输出流"><meta property="og:url" content="https://wonderperson.github.io/2020/05/12/inout/"><meta property="og:site_name" content="YOUR"><meta property="og:description" content="流的定义以及C++流类和流对象程序中常用的 cin 和 cout，分别用于从键盘输入数据和向屏幕输出数据（简称为标准 I&#x2F;O）。除此之外，程序还可以从文件中读入数据，以及向文件中写入数据（简称为文件 I&#x2F;O)。 数据输入和输出的过程也是数据传输的过程。数据像水一样从一个地方流动到另一个地方，因此，在 C++ 中将此过程称为 “流（stream）”。 在 C++ 的标准类库中，将用于进行数据输入输出"><meta property="og:image" content="https://cdn.pixabay.com/photo/2020/03/27/15/31/norway-4973912_1280.jpg"><meta property="article:published_time" content="2020-05-12T13:36:20.000Z"><meta property="article:modified_time" content="2020-05-12T13:41:42.357Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://wonderperson.github.io/2020/05/12/inout/"><link rel="next" title="为啥重载运算符要返回自身引用" href="https://wonderperson.github.io/2020/05/10/20200510/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://wonderperson.github.io/","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"HAVE,A,NiCE,DAY","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/xlweb.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#流的定义以及C-流类和流对象"><span class="toc-number">1.</span> <span class="toc-text">流的定义以及C++流类和流对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#标准流对象"><span class="toc-number">1.1.</span> <span class="toc-text">标准流对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cout格式化输出（输出格式）"><span class="toc-number">2.</span> <span class="toc-text">cout格式化输出（输出格式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用流操作算子"><span class="toc-number">2.1.</span> <span class="toc-text">使用流操作算子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用cout的成员函数"><span class="toc-number">2.2.</span> <span class="toc-text">调用cout的成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-cout-put-：输出单个字符"><span class="toc-number">3.</span> <span class="toc-text">C++ cout.put()：输出单个字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-cin判断输入结束（读取结束）"><span class="toc-number">4.</span> <span class="toc-text">C++ cin判断输入结束（读取结束）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cin-判断控制台（键盘）读取结束"><span class="toc-number">4.1.</span> <span class="toc-text">cin 判断控制台（键盘）读取结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cin-判断文件读取结束"><span class="toc-number">4.2.</span> <span class="toc-text">cin 判断文件读取结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意："><span class="toc-number">4.3.</span> <span class="toc-text">注意：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cin-get-：C-读取单个字符"><span class="toc-number">5.</span> <span class="toc-text">cin.get()：C++读取单个字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cin-getline-：C-读入一行字符串（整行数据）"><span class="toc-number">6.</span> <span class="toc-text">cin.getline()：C++读入一行字符串（整行数据）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cin-ignore-：C-跳过（忽略）指定字符"><span class="toc-number">7.</span> <span class="toc-text">cin.ignore()：C++跳过（忽略）指定字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cin-peek-：C-查看输入流中的下一个字符"><span class="toc-number">8.</span> <span class="toc-text">cin.peek()：C++查看输入流中的下一个字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-处理输入输出错误"><span class="toc-number">9.</span> <span class="toc-text">C++处理输入输出错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实例"><span class="toc-number">9.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-管理输出缓冲区"><span class="toc-number">10.</span> <span class="toc-text">C++管理输出缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#刷新输出缓冲区"><span class="toc-number">10.1.</span> <span class="toc-text">刷新输出缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unitbuf-操作符"><span class="toc-number">10.2.</span> <span class="toc-text">unitbuf 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关联输入和输出流"><span class="toc-number">10.3.</span> <span class="toc-text">关联输入和输出流</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.pixabay.com/photo/2020/03/27/15/31/norway-4973912_1280.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">YOUR</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">输入输出流</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-12 21:36:20"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-12</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-12 21:41:42"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-12</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/c-%E7%AC%94%E8%AE%B0/">c++笔记</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="流的定义以及C-流类和流对象"><a href="#流的定义以及C-流类和流对象" class="headerlink" title="流的定义以及C++流类和流对象"></a>流的定义以及C++流类和流对象</h2><p>程序中常用的 cin 和 cout，分别用于从键盘输入数据和向屏幕输出数据（简称为标准 I/O）。除此之外，程序还可以从文件中读入数据，以及向文件中写入数据（简称为文件 I/O)。</p>
<p>数据输入和输出的过程也是数据传输的过程。数据像水一样从一个地方流动到另一个地方，因此，在 C++ 中将此过程称为 “流（stream）”。</p>
<p>在 C++ 的标准类库中，将用于进行数据输入输出的类统称为“流类”。cin 是流类 istream 的对象，cout 是流类 ostream 的对象。要使用流类，需要在程序中包含 iostream 头文件。</p>
<p>C++ 中常用的几个流类及其相互关系如图所示：</p>
<p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200512161251.png" alt="20200512161251"></p>
<p>图1中的箭头代表派生关系。例如，ios 是抽象的基类，它派生出 istream 和 ostream。 istream 和 ostream 又共同派生了 iostream 类。</p>
<p>为了避免多继承的二义性，从 ios 派生出 istream 和 ostream 时，均使用了 <strong>virtual 关键字（虚继承）</strong>。</p>
<ul>
<li>istream 是用于输入的流类，cin 就是该类的对象。</li>
<li>ostream 是用于输出的流类，cout 就是该类的对象。</li>
<li>ifstream 是用于从文件读取数据的类。</li>
<li>ofstream 是用于向文件写入数据的类。</li>
<li>iostream 是既能用于输入，又能用于输出的类。</li>
<li>fstream 是既能从文件读取数据，又能向文件写入数据的类。</li>
</ul>
<h3 id="标准流对象"><a href="#标准流对象" class="headerlink" title="标准流对象"></a>标准流对象</h3><p>iostream 头文件中定义了四个标准流对象，它们是 cin、cout、cerr 和 clog。</p>
<ul>
<li>cin 对应于标准输入流，用于从键盘读取数据，也<strong>可以被重定向</strong>为从文件中读取数据。</li>
<li>cout 对应于标准输出流，用于向屏幕输出数据，也<strong>可以被重定向</strong>为向文件写入数据。</li>
<li>cerr 对应于标准错误输出流，用于向屏幕输出出错信息，<strong>不能被重定向</strong>。</li>
<li>clog 对应于标准错误输出流，用于向屏幕输出出错信息，<strong>不能被重定向</strong>。</li>
</ul>
<p>cerr 和 clog的区别在于：cerr 不使用缓冲区，直接向显示器输出信息；而输出到 clog 中的信息会先被存放到缓冲区，缓冲区满或者刷新时才输出到屏幕。</p>
<p>ostream 类的无参构造函数和复制构造函数都是私有的，因此在程序中一般无法定义 ostream 类的对象，<strong>唯一能用</strong>的 ostream 类的对象就是 cout。</p>
<p>当然，上面关于 cout 对象的定义语句说明 ostream 类是有一个公有构造函数的，如果知道这个构造函数是什么样的，那么也能自己定义 ostream 类的对象——但这么做并无必要。</p>
<p>cout 可以被重定向，而 cerr 不能。所谓重定向，就是将输入的源或输出的目的地改变。例如，cout 本来是输出到屏幕上的，但是经过重定向，本该输出到屏幕上的东西就可以被输出到文件中。</p>
<p>例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">freopen是被包含于C标准库头文件stdio.h中的一个函数，用于重定向输入输出流。该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C89函数声明：</span></span><br><span class="line"><span class="comment">*FILE freopen( const char filename, const char mode, FILE stream );</span></span><br><span class="line"><span class="comment">形参说明：</span></span><br><span class="line"><span class="comment">filename：需要重定向到的文件名或文件路径。</span></span><br><span class="line"><span class="comment">mode：代表文件访问权限的字符串。例如，"r"表示“只读访问”、"w"表示“只写访问”、"a"表示“追加写入”。</span></span><br><span class="line"><span class="comment">stream：需要被重定向的文件流。</span></span><br><span class="line"><span class="comment">返回值：如果成功，则返回该指向该输出流的文件指针，否则返回为NULL。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    freopen(<span class="string">"test.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);  <span class="comment">//将标准输出重定向到 test.txt文件</span></span><br><span class="line">    <span class="keyword">if</span>( y == <span class="number">0</span> )  <span class="comment">//除数为0则输出错误信息</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"error."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x /y ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重定向之后，所有对 cout 的输出都不再出现在屏幕上，而是出现在 test.txt 文件中。</p>
<p>test.txt 文件会和本程序的可执行文件出现在同一个文件夹中。重定向仅对本程序有效，不影响其他程序。</p>
<p>运行本程序，输入</p>
<blockquote>
<p>6 2↙</p>
</blockquote>
<p>程序没有输出，但是打开 test.txt文件，可以看到文件中有</p>
<blockquote>
<p>3</p>
</blockquote>
<p>如果输入</p>
<blockquote>
<p>4 0↙</p>
</blockquote>
<p>则程序在屏幕上输出</p>
<blockquote>
<p>error.</p>
</blockquote>
<p>说明 cerr <strong>不会被重定向</strong>。</p>
<p>cin 也是可以被重定向的。如果在程序中加入</p>
<blockquote>
<p>freopen(“input.dat”, “r”, stdin);</p>
</blockquote>
<p>第二个参数 r 代表读入方式，第三个参数 stdin 代表标准输入。执行此语句后，cin 就不再从键盘读入数据，而是从 input.dat 文件中读人数据，input.dat 文件中有什么，就相当于从键盘输入了什么。</p>
<h2 id="cout格式化输出（输出格式）"><a href="#cout格式化输出（输出格式）" class="headerlink" title="cout格式化输出（输出格式）"></a>cout格式化输出（输出格式）</h2><p>有时希望按照一定的格式进行输出，如按十六进制输出整数，输出浮点数时保留小数点后面两位，输出整数时按 6 个数字的宽度输出，宽度不足时左边补 0，等等。C语言中的 printf() 函数使用以%开头的格式控制符，例如 %X、%.2f、%6d 等；C++ 中的 cout 对象则使用<strong>流操作算子</strong>（你也可以叫做格式控制符）或者<strong>成员函数</strong>进行控制。</p>
<h3 id="使用流操作算子"><a href="#使用流操作算子" class="headerlink" title="使用流操作算子"></a>使用流操作算子</h3><p>C++ 中常用的输出流操纵算子如下表所示，它们都是在头文件 iomanip 中定义的；要使用这些流操纵算子，必须包含该头文件。</p>
<blockquote>
<p>注意：“流操纵算子”一栏中的星号*不是算子的一部分，星号表示在没有使用任何算子的情况下，就等效于使用了该算子。例如，在默认情况下，整数是用十进制形式输出的，等效于使用了 dec 算子。</p>
</blockquote>
<table>
<thead>
<tr>
<th>流操纵算子</th>
<th>作  用</th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td>*dec</td>
<td>以十进制形式输出整数</td>
<td style="text-align:right" rowspan="13">常用</td>
</tr>
<tr>
<td>hex</td>
<td>以十六进制形式输出整数</td>
</tr>
<tr>
<td>oct</td>
<td>以八进制形式输出整数</td>

</tr>
<tr>
<td>fixed</td>
<td>以普通小数形式输出浮点数</td>
</tr>
<tr>
<td>scientific</td>
<td>以科学计数法形式输出浮点数</td>

</tr>
<tr>
<td>left</td>
<td>左对齐，即在宽度不足时将填充字符添加到右边</td>

</tr>
<tr>
<td>*right</td>
<td>右对齐，即在宽度不足时将填充字符添加到左边</td>

</tr>
<tr>
<td>setbase(b)</td>
<td>设置输出整数时的进制，b=8、10 或 16</td>

</tr>
<tr>
<td>setw(w)</td>
<td>指定输出宽度为 w 个字符，或输人字符串时读入 w 个字符</td>

</tr>
<tr>
<td>setfill(c)</td>
<td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td>

</tr>
<tr>
<td>setprecision(n)</td>
<td>
1.设置输出浮点数的精度为 n。

<p>2.在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。</p>
<p>3.在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</td></p>
</tr>
<tr>
<td>setiosflags(flag)</td>
<td>将某个输出格式标志置为 1</td>

</tr>
<tr>
<td>resetiosflags(flag)</td>
<td>将某个输出格式标志置为 0</td>

</tr>
<tr>
<td>boolapha</td>
<td>把 true 和 false 输出为字符串</td>
<td style="text-align:right" rowspan="13">不常用</td>
</tr>
<tr>
<td>*noboolalpha</td>
<td>把 true 和 false 输出为 0、1</td>

</tr>
<tr>
<td>showbase</td>
<td>输出表示数值的进制的前缀</td>

</tr>
<tr>
<td>*noshowbase</td>
<td>不输出表示数值的进制.的前缀</td>

</tr>
<tr>
<td>showpoint</td>
<td>总是输出小数点</td>

</tr>
<tr>
<td>*noshowpoint</td>
<td>只有当小数部分存在时才显示小数点</td>

</tr>
<tr>
<td>showpos</td>
<td>在非负数值中显示 +</td>

</tr>
<tr>
<td>*noshowpos</td>
<td>在非负数值中不显示 +</td>

</tr>
<tr>
<td>*skipws</td>
<td>输入时跳过空白字符</td>

</tr>
<tr>
<td>noskipws</td>
<td>输入时不跳过空白字符</td>

</tr>
<tr>
<td>uppercase</td>
<td>十六进制数中使用 A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td>

</tr>
<tr>
<td>*nouppercase</td>
<td>十六进制数中使用 a~e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。</td>

</tr>
<tr>
<td>internal</td>
<td>数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td>

</tr>
</tbody>
</table>

<p><strong>流操作算子的使用方法</strong></p>
<p>使用这些算子的方法是将算子用 &lt;&lt; 和 cout 连用。例如：</p>
<blockquote>
<p>cout &lt;&lt; hex &lt;&lt; 12 &lt;&lt; “,” &lt;&lt; 24;</p>
</blockquote>
<p>这条语句的作用是指定以十六进制形式输出后面两个数，因此输出结果是：</p>
<blockquote>
<p>c, 18</p>
</blockquote>
<p><strong>setiosflags() 算子</strong><br>setiosflags() 算子实际上是一个库函数，它以一些标志作为参数，这些标志可以是在 iostream 头文件中定义的以下几种取值，它们的含义和同名算子一样。</p>
<table>
<thead>
<tr>
<th>标 志</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>ios::left</td>
<td>输出数据在本域宽范围内向左对齐</td>
</tr>
<tr>
<td>ios::right</td>
<td>输出数据在本域宽范围内向右对齐</td>
</tr>
<tr>
<td>ios::internal</td>
<td>数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</td>
</tr>
<tr>
<td>ios::dec</td>
<td>设置整数的基数为 10</td>
</tr>
<tr>
<td>ios::oct</td>
<td>设置整数的基数为 8</td>
</tr>
<tr>
<td>ios::hex</td>
<td>设置整数的基数为 16</td>
</tr>
<tr>
<td>ios::showbase</td>
<td>强制输出整数的基数（八进制数以 0 开头，十六进制数以 0x 打头）</td>
</tr>
<tr>
<td>ios::showpoint</td>
<td>强制输出浮点数的小点和尾数 0</td>
</tr>
<tr>
<td>ios::uppercase</td>
<td>在以科学记数法格式 E 和以十六进制输出字母时以大写表示</td>
</tr>
<tr>
<td>ios::showpos</td>
<td>对正数显示“+”号</td>
</tr>
<tr>
<td>ios::scientific</td>
<td>浮点数以科学记数法格式输出</td>
</tr>
<tr>
<td>ios::fixed</td>
<td>浮点数以定点格式（小数形式）输出</td>
</tr>
<tr>
<td>ios::unitbuf</td>
<td>每次输出之后刷新所有的流</td>
</tr>
<tr>
<td>ios::stdio</td>
<td>每次输出之后清除 stdout, stderr</td>
</tr>
</tbody></table>
<p>这些标志实际上都是仅有某比特位为 1，而其他比特位都为 0 的整数。</p>
<p>多个标志可以用|运算符连接，表示同时设置。例如：</p>
<blockquote>
<p>cout &lt;&lt; setiosflags(ios::scientific|ios::showpos) &lt;&lt; 12.34;</p>
</blockquote>
<p>输出结果是：</p>
<blockquote>
<p>+1.234000e+001</p>
</blockquote>
<p>如果两个相互矛盾的标志同时被设置，如先设置 setiosflags(ios::fixed)，然后又设置 setiosflags(ios::scientific)，那么结果可能就是两个标志都不起作用。因此，在设置了某标志，又要设置其他与之矛盾的标志时，就应该用 resetiosflags 清除原先的标志。例如下面三条语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; <span class="number">12.34</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; resetiosflags(ios::fixed) &lt;&lt; setiosflags(ios::scientific | ios::showpos) &lt;&lt; <span class="number">12.34</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; resetiosflags(ios::showpos) &lt;&lt; <span class="number">12.34</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//清除要输出正号的标志</span></span><br></pre></td></tr></table></figure>
<p>输出结果是：   </p>
<blockquote>
<p>12.340000<br>+1.234000e+001<br>1.234000e+001   </p>
</blockquote>
<p><strong>综合示例</strong><br>关于流操纵算子的使用，来看下面的程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">141</span>;</span><br><span class="line">    <span class="comment">//1) 分别以十六进制、十进制、八进制先后输出 n</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1)"</span> &lt;&lt; hex &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; dec &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; oct &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">1234567.89</span>, y = <span class="number">12.34567</span>;</span><br><span class="line">    <span class="comment">//2)保留5位有效数字</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2)"</span> &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//3)保留小数点后面5位</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3)"</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//4)科学计数法输出，且保留小数点后面5位</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4)"</span> &lt;&lt; scientific &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//5)非负数显示正号，输出宽度为12字符，宽度不足则用 * 填补</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5)"</span> &lt;&lt; showpos &lt;&lt; fixed &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; setfill(<span class="string">'*'</span>) &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//6)非负数不显示正号，输出宽度为12字符，宽度不足则右边用填充字符填充</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6)"</span> &lt;&lt; noshowpos &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; left &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//7)输出宽度为 12 字符，宽度不足则左边用填充字符填充</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"7)"</span> &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; right &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//8)宽度不足时，负号和数值分列左右，中间用填充字符填充</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"8)"</span> &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"9)"</span> &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是：</p>
<blockquote>
<p>1)8d 141 215<br>2)1.2346e+06 12.346<br>3)1234567.89000 12.34567<br>4)1.23457e+06 1.23457e+01<br>5)<strong><em>+12.10000<br>6)12.10000*</em></strong><br>7)<strong><em>*12.10000<br>8)-</em></strong>12.10000<br>9)12.10000      </p>
</blockquote>
<p>需要注意的是，setw() 算子所起的作用是一次性的，即只影响下一次输出。每次需要指定输出宽度时都要使用 setw()。因此可以看到，第 9) 行的输出因为没有使用 setw()，输出的宽度就不再是前面指定的 12 个字符。但是setprecision(5)的影响并不是一次性的。</p>
<p>在读入字符串时，setw() 还能影响 cin 的行为。例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; setw(<span class="number">4</span>) &gt;&gt; s1 &gt;&gt; setw(<span class="number">3</span>) &gt;&gt; s2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="string">","</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<blockquote>
<p>1234567890↙</p>
</blockquote>
<p>程序的输出结果是：</p>
<blockquote>
<p>1234,567</p>
</blockquote>
<p>说明setw(4)使得读入 s1 时，只读入 4 个字符，其后的setw(3)使得读入 s2 时只读入 3 个字符。</p>
<p>setw() 用于 cin 时，<strong>同样只影响下一次的输入</strong>。</p>
<h3 id="调用cout的成员函数"><a href="#调用cout的成员函数" class="headerlink" title="调用cout的成员函数"></a>调用cout的成员函数</h3><p>stream 类有一些成员函数，通过 cout 调用它们也能用于控制输出的格式，其作用和流操纵算子相同，如表所示:</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>作用相同的流操纵算子</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>precision(n)</td>
<td>setprecision(n)</td>
<td>设置输出浮点数的精度为 n。</td>
</tr>
<tr>
<td>width(w)</td>
<td>setw(w)</td>
<td>指定输出宽度为 w 个字符。</td>
</tr>
<tr>
<td>fill(c)</td>
<td>setfill (c)</td>
<td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）。</td>
</tr>
<tr>
<td>setf(flag)</td>
<td>setiosflags(flag)</td>
<td>将某个输出格式标志置为 1。</td>
</tr>
<tr>
<td>unsetf(flag)</td>
<td>resetiosflags(flag)</td>
<td>将某个输出格式标志置为 0。</td>
</tr>
</tbody></table>
<p>setf 和 unsetf 函数用到的<strong>flag</strong>，与 setiosflags 和 resetiosflags 用到的完全相同。</p>
<p>这些成员函数的用法十分简单。例如下面的三行程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::scientific);</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">12.23</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<blockquote>
<p>1.22300000e+01</p>
</blockquote>
<h2 id="C-cout-put-：输出单个字符"><a href="#C-cout-put-：输出单个字符" class="headerlink" title="C++ cout.put()：输出单个字符"></a>C++ cout.put()：输出单个字符</h2><p>C++ 程序中一般用 ostream 类的 cout 输出流对象和 &lt;&lt; 输出运算符实现输出，并且 cout 输出流在内存中有相应的缓冲区。但有时用户还有特殊的输出需求，例如只输出一个字符，这种情况下可以借助该类提供的 put() 成员方法实现。</p>
<p>put() 方法专用于向输出流缓冲区中添加单个字符，其语法格式如下：</p>
<blockquote>
<p>ostream＆put(char c);</p>
</blockquote>
<p>其中，参数 c 为要输出的字符。</p>
<p>可以看到，该函数会返回一个 ostream 类的引用对象，可以理解返回的是 cout 的引用。这意味着，我们可以像下面这样使用 put() 函数：</p>
<blockquote>
<p>cout.put(c1).put(c2).put(c3);</p>
</blockquote>
<p>因为 cout.put(c1) 向输出流缓冲区中添加 c1 字符的同时，返回一个引用形式的 cout 对象，所以可以继续用此对象调用 put(c2)，依次类推。 </p>
<p>【实例1】输出单个字符 a。</p>
<blockquote>
<p>cout.put(‘a’);</p>
</blockquote>
<p>调用该方法的结果是在屏幕上显示一个字符 a。</p>
<p>【实例2】put() 函数的参数可以是字符或字符的 ASCII 代码（也可以是一个整型表达式）。</p>
<blockquote>
<p>cout.put(65 + 32);<br>cout.put(97);</p>
</blockquote>
<p>上面两行代码都输出字符 a，因为 97 是字符 a 的 ASCII 代码。</p>
<p>【实例3】可以在一个语句中连续调用 put() 函数，例如：</p>
<blockquote>
<p>cout.put(71).put(79).put(79). put(68).put(‘\n’);</p>
</blockquote>
<p>在屏幕上显示GOOD。</p>
<p>【实例4】有一个字符串 “abcdefg”，要求把它们按相反的顺序输出:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">cout</span>.<span class="built_in">put</span>(str[i]);  <span class="comment">//从最后一个字符开始输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">put</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>gfedcba</p>
</blockquote>
<p>除了使用 cout.put() 函数输出一个字符外，还可以用 putchar() 函数输出一个字符。putchar() 函数是C语言中使用的，C++保留了这个函数，在 &lt;iostream&gt; 头文件中定义。<br>下面是 putchar() 函数的声明。</p>
<blockquote>
<p>int putchar(int char)</p>
</blockquote>
<p>下面的实例演示了 putchar() 函数的用法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(ch = <span class="string">'A'</span> ; ch &lt;= <span class="string">'Z'</span> ; ch++) &#123;</span><br><span class="line">      <span class="built_in">putchar</span>(ch);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>ABCDEFGHIJKLMNOPQRSTUVWXYZ</p>
</blockquote>
<h2 id="C-cin判断输入结束（读取结束）"><a href="#C-cin判断输入结束（读取结束）" class="headerlink" title="C++ cin判断输入结束（读取结束）"></a>C++ cin判断输入结束（读取结束）</h2><p>cin 可以用来从键盘输入数据；将标准输入重定向为文件后，cin 也可以用来从文件中读入数据。在输入数据的多少不确定，且没有结束标志的情况下，该如何判断输入数据已经读完了呢？</p>
<p>其实在控制台中输入特殊的控制字符就表示输入结束：</p>
<ul>
<li>在 Windows 系统中，通过键盘输入时，按 Ctrl+Z 组合键后再按回车键，就代表输入结束。</li>
<li>在 UNIX/Linux/Mac OS 系统中，Ctrl+D 代表输入结束。</li>
</ul>
<p><strong>不管是文件末尾，还是 Ctrl+Z 或者 Ctrl+D，它们都是结束标志；cin 在正常读取时返回 true，遇到结束标志时返回 false，我们可以根据 cin 的返回值来判断是否读取结束。</strong></p>
<h3 id="cin-判断控制台（键盘）读取结束"><a href="#cin-判断控制台（键盘）读取结束" class="headerlink" title="cin 判断控制台（键盘）读取结束"></a>cin 判断控制台（键盘）读取结束</h3><p>输入若干个正整数，输出其中的最大值，程序该如何编写？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> maxN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)&#123;  <span class="comment">//输入没有结束，cin 就返回 true，条件就为真</span></span><br><span class="line">        <span class="keyword">if</span> (maxN &lt; n)</span><br><span class="line">            maxN = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxN &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Windows 下运行该程序，先输入以下整数：</p>
<blockquote>
<p>10<br>30<br>93<br>206<br>8      </p>
</blockquote>
<p>然后在按下 Ctrl+Z 组合键（可以在当前行，也可以在新的一行），接着按下回车键，输入就结束了，此时 cin 返回 false，循环结束，得到了最大值。</p>
<p>完整的输入输出结果如下所示：</p>
<blockquote>
<p>10↙<br>30↙<br>93↙<br>206↙<br>8↙<br>^Z↙<br>206     </p>
</blockquote>
<p>↙表示回车键，^Z表示 Ctrl+Z 组合键。</p>
<h3 id="cin-判断文件读取结束"><a href="#cin-判断文件读取结束" class="headerlink" title="cin 判断文件读取结束"></a>cin 判断文件读取结束</h3><p>cin 读到文件末尾时，cin&gt;&gt;n就会返回 false，从而导致程序结束。例如，假定 test.txt 文件中的内容如下所示：</p>
<blockquote>
<p>112<br>23123<br>34 444 55<br>44           </p>
</blockquote>
<p>代码及演示如下图：<br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200512181848.png" alt="20200512181848"></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>重载部分提到过 istream 类将 &gt;&gt; 重载为成员函数，而且这些成员函数的返回值是 cin 的引用。准确地说，cin&gt;&gt; n 的返回值的确是 istream &amp; 类型的，而 while 语句中的条件表达式的返回值应该是 bool 类型、整数类型或其他和整数类型兼容的类型，istream &amp; 显然和整数类型不兼容，为什么while(cin&gt;&gt;n)还能成立呢？</p>
<p>这是因为，<strong>istream 类对强制类型转换运算符 bool 进行了重载</strong>，这使得 cin 对象可以被自动转换成 bool 类型。所谓自动转换的过程，就是调用 cin 的 operator bool() 这个成员函数，而该成员函数可以返回某个标志值，该标志值在 cin 没有读到输入结尾时为 true，读到输入结尾后变为 false。对该标志值的设置，在 operator &lt;&lt;() 成员函数中进行。</p>
<p>如果 cin 在读取过程中发生了错误，cin&gt;&gt;n这样的表达式也会返回 false。例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序本该输入整数，如果输入了一个字母，则程序就会结束。因为，应该读入整数时却读入了字母也算读入出错。</p>
<h2 id="cin-get-：C-读取单个字符"><a href="#cin-get-：C-读取单个字符" class="headerlink" title="cin.get()：C++读取单个字符"></a>cin.get()：C++读取单个字符</h2><p>get() 是 istream 类的成员函数，它有多种重载形式，此处只介绍最简单最常用的一种：</p>
<blockquote>
<p>int get();</p>
</blockquote>
<p>此函数从输入流中读入一个字符，返回值就是该字符的 ASCII 码。如果碰到输入的末尾，则返回值为 EOF。</p>
<p>EOF 是 End of File 的缩写。istream 类中从输入流（包括文件）中读取数据的成员函数，在把输入数据都读取完后再进行读取，就会返回 EOF。<strong>EOF 是在 iostream 类中定义的一个整型常量，值为 -1。</strong></p>
<p>get() 函数<strong>不会跳过空格、制表符、回车等特殊字符</strong>，所有的字符都能被读入。例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">cin</span>.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">        <span class="built_in">cout</span>.<span class="built_in">put</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">程序运行情况如下：</span><br><span class="line">&gt;abcdefg↙     </span><br><span class="line">abcdefg     </span><br><span class="line">C++ Tutorial↙     </span><br><span class="line">C++ Tutorial      </span><br><span class="line">^Z↙</span><br><span class="line"></span><br><span class="line">↙表示回车键，^Z表示 Ctrl+Z 组合键。</span><br><span class="line"></span><br><span class="line">程序中的变量 c 应为 <span class="keyword">int</span> 类型，而不能是 <span class="keyword">char</span> 类型。在输入流中碰到 ASCII 码等于 <span class="number">0xFF</span> 的字符时，<span class="built_in">cin</span>.<span class="built_in">get</span>() 返回 <span class="number">0xFF</span>，<span class="number">0xFF</span> 赋值给 c，此时如果 c 是 <span class="keyword">char</span> 类型的，那么其值就是 <span class="number">-1</span>（因为符号位为 <span class="number">1</span> 代表负数），即等于 EOF，于是程序就错误地认为输入已经结束。</span><br><span class="line"></span><br><span class="line">而在 c 为 <span class="keyword">int</span> 类型的情况下，将 <span class="number">0xFF</span> 赋值给 c，c 的值是 <span class="number">255</span>（因为符号位为 <span class="number">0</span>，是正数），而非 <span class="number">-1</span>，即除非读到输入末尾，c 的值都不可能是 <span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line">要将文本文件 test.txt 中的全部内容原样显示出来，程序可以如下编写：</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    freopen(<span class="string">"test.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);  <span class="comment">//将标准输入重定向为 test.txt</span></span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">cin</span>.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">        <span class="built_in">cout</span>.<span class="built_in">put</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图如下：</p>
<p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200512210019.png" alt="20200512210019"></p>
<h2 id="cin-getline-：C-读入一行字符串（整行数据）"><a href="#cin-getline-：C-读入一行字符串（整行数据）" class="headerlink" title="cin.getline()：C++读入一行字符串（整行数据）"></a>cin.getline()：C++读入一行字符串（整行数据）</h2><p>getline() 是 istream 类的成员函数，它有如下两个重载版本：</p>
<blockquote>
<p>istream &amp; getline(char* buf, int bufSize);<br>istream &amp; getline(char* buf, int bufSize, char delim);</p>
</blockquote>
<p>第一个版本从输入流中读取 bufSize-1 个字符到缓冲区 buf，或遇到\n为止（<strong>哪个条件先满足就按哪个执行</strong>）。函数会自动在 buf 中读入数据的结尾添加\0。</p>
<p>第二个版本和第一个版本的区别在于，第一个版本是读到\n为止，第二个版本是读到 delim 字符为止。\n或 delim 都不会被读入 buf，但会被从输入流中取走。</p>
<p>这两个函数的返回值就是函数所作用的对象的引用。如果输入流中\n或 delim 之前的字符个数达到或超过 bufSize，就会导致读入出错，其结果是：虽然本次读入已经完成，但是之后的读入都会失败。</p>
<p>从输入流中读入一行，可以用第一个版本。用cin &gt;&gt; str这种写法是不行的，因为此种读法在碰到行中的空格或制表符时就会停止，因此就不能保证 str 中读入的是整行。</p>
<p>第一个版本的 getline 函数的用法示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> szBuf[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">120</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">cin</span>.getline(szBuf,<span class="number">6</span>))  <span class="comment">//如果输入流中一行字符超过5个，就会出错</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; szBuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">//clear能够清除cin内部的错误标记，使之恢复正常</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行过程如下：</p>
<blockquote>
<p>ab cd↙<br>ab cd<br>33↙<br>33<br>44↙<br>44        </p>
</blockquote>
<p>在上面的输入情况下，程序是正常的。程序运行过程中还可能出现如下情况：</p>
<blockquote>
<p>ab cd123456k↙<br>error<br>ab cd<br>120<br>123456       </p>
</blockquote>
<p>第 7 行，读入时因字符串超长导致出错，于是第 11 行并没有从输入流读入 n，n 维持了原来的值 120。</p>
<p>第 12 行，调用 istream 的成员函数 clear() 清除 cin 内部的错误标记，此后 cin 又能正常读入了。因此，123456 在第 13 行被读入 n。</p>
<p>可以用 getline() 函数的返回值（为 false 则输入结束）来判断输入是否结束。例如，要将文件 test.txt 中的全部内容（假设文件中一行最长有 10 000个字符）原样显示，程序可以如下编写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LINE_LEN = <span class="number">10000</span>;  <span class="comment">//假设文件中一行最长 10000 个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> szBuf[MAX_LINE_LEN + <span class="number">10</span>];</span><br><span class="line">    freopen(<span class="string">"test.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);  <span class="comment">//将标准输入重定向为 test.txt</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>.getline(szBuf, MAX_LINE_LEN + <span class="number">5</span>))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; szBuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序每次读入文件中的一行到 szBuf 并输出。szBuf 中不会读入回车符，因此输出 szBuf 后要再输出 endl 以换行。</p>
<h2 id="cin-ignore-：C-跳过（忽略）指定字符"><a href="#cin-ignore-：C-跳过（忽略）指定字符" class="headerlink" title="cin.ignore()：C++跳过（忽略）指定字符"></a>cin.ignore()：C++跳过（忽略）指定字符</h2><p>ignore() 是 istream 类的成员函数，它的原型是：</p>
<blockquote>
<p>istream &amp; ignore(int n =1, int delim = EOF);</p>
</blockquote>
<p>此函数的作用是跳过输入流中的 n 个字符，或跳过 delim 及其之前的所有字符，哪个条件先满足就按哪个执行。两个参数都有默认值，因此 cin.ignore() 就等效于 cin.ignore(1, EOF)， 即跳过一个字符。</p>
<p>该函数常用于跳过输入中的无用部分，以便提取有用的部分。例如，输入的电话号码形式是 Tel:63652823 ，Tel: 就是无用的内容。例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>.ignore(<span class="number">5</span>, <span class="string">'A'</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行过程可能如下：</p>
<blockquote>
<p>abcde34↙<br>34</p>
</blockquote>
<p>cin.ignore() 跳过了输入中的前 5 个字符，其余内容被当作整数输入 n 中。</p>
<p>该程序的运行过程也可能如下：</p>
<blockquote>
<p>abA34↙<br>34</p>
</blockquote>
<p>cin.ignore() 跳过了输入中的 ‘A’ 及其前面的字符，其余内容被当作整数输入 n 中。</p>
<h2 id="cin-peek-：C-查看输入流中的下一个字符"><a href="#cin-peek-：C-查看输入流中的下一个字符" class="headerlink" title="cin.peek()：C++查看输入流中的下一个字符"></a>cin.peek()：C++查看输入流中的下一个字符</h2><p>peek() 是 istream 类的成员函数，它的原型是：</p>
<blockquote>
<p>int peek();</p>
</blockquote>
<p>此函数返回输入流中的下一个字符，但是并不将该字符从输入流中取走——相当于只是看了一眼下一个字符，因此叫 peek。</p>
<p>cin.peek() 不会跳过输入流中的空格、回车符。在输入流已经结束的情况下，cin.peek() 返回 EOF。</p>
<p>在输入数据的格式不同，需要预先判断格式再决定如何输入时，peek() 就能起到作用。</p>
<p>例题：编写一个日期格式转换程序，输入若干个日期，每行一个，要求全部转换为“mm-dd-yyyy”格式输出。输入的日期格式可以是“2011.12.24”（中式格式），也可以是“Dec 24 2011”（西式格式）。要求该程序对于以下输入数据：</p>
<blockquote>
<p>Dec 3 1990<br>2011.2.3<br>458.12.1<br>Nov 4 1998<br>Feb 12 2011             </p>
</blockquote>
<p>输出结果应为：</p>
<blockquote>
<p>12-03-1990<br>02-03-2011<br>12-01-0458<br>11-04-1998<br>02-12-2011       </p>
</blockquote>
<p>输入数据中的 Ctrl+Z 略去不写，因为输入数据也可能来自于文件。</p>
<p>编写这个程序时，如果输入的是中式格式，就用 cin&gt;&gt;year（假设 year 是 int 类型变量）读取年份，然后再读取后面的内容；如果输入是西式格式，就用 cin&gt;&gt;sMonth（假设 sMonth 是 string 类型对象）读取月份，然后读取后面的内容。</p>
<p>可是，如果没有将数据从输入流中读取出来，就无法判断输入到底是哪种格式。即便用 cin.get() 读取一个字符后再作判断，也很不方便。例如，在输入为2011.12.24的情况下，读取第一个字符2后就知道是格式一，问题是输入流中的已经被读取了，剩下的表示年份的部分只有011，如何将这个011和前面读取的2奏成一个整数 2011，也是颇费周折的事情。使用 peek() 函数很容易解决这个问题。</p>
<p>示例程序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> Months[<span class="number">12</span>] = &#123; <span class="string">"Jan"</span>,<span class="string">"Feb"</span>,<span class="string">"Mar"</span>,<span class="string">"Apr"</span>,<span class="string">"May"</span>,<span class="string">"Jun"</span>,<span class="string">"Jul"</span>,<span class="string">"Aug"</span>, <span class="string">"Sep"</span>,<span class="string">"Oct"</span>,<span class="string">"Nov"</span>,<span class="string">"Dec"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">cin</span>.<span class="built_in">peek</span>()) != EOF) &#123; <span class="comment">//取输入流中的第一个字符进行查看</span></span><br><span class="line">         <span class="keyword">int</span> year,month,day;</span><br><span class="line">         <span class="keyword">if</span>(c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) &#123; <span class="comment">//美国日期格式</span></span><br><span class="line">            <span class="built_in">string</span> sMonth;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; sMonth &gt;&gt; day &gt;&gt; year;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">12</span>; ++i)  <span class="comment">//查找月份</span></span><br><span class="line">                   <span class="keyword">if</span>(sMonth == Months[i]) &#123;</span><br><span class="line">                    month = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//中国日期格式</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; year ;</span><br><span class="line">            <span class="built_in">cin</span>.ignore() &gt;&gt; month ; <span class="comment">//用ignore跳过 "2011.12.3"中的'.'</span></span><br><span class="line">            <span class="built_in">cin</span>.ignore() &gt;&gt; day;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>.ignore();   <span class="comment">//跳过行末 '\n'</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; month ;<span class="comment">//设置填充字符'\0'，输出宽度2</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; day &lt;&lt; <span class="string">"-"</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>istream 还有一个成员函数 istream &amp; putback(char c)，可以将一个字符插入输入流的最前面。对于上面的例题，也可以在用 get() 函数读取一个字符并判断是中式格式还是西式格式时，将刚刚读取的字符再用 putback() 成员函数放回流中，然后再根据判断结果进行不同方式的读入。</p>
<h2 id="C-处理输入输出错误"><a href="#C-处理输入输出错误" class="headerlink" title="C++处理输入输出错误"></a>C++处理输入输出错误</h2><p>当处理输入输出时，我们必须预计到其中可能发生的错误并给出相应的处理措施。</p>
<ul>
<li>当我们输入时，可能会由于人的失误（错误理解了指令、打字错误、允许自家的小猫在键盘上散步等）、文件格式不符、错误估计了情况等原因造成读取失败。</li>
<li>当我们输出时，如果输出设备不可用、队列满或者发生了故障等，都会导致写入失败。</li>
</ul>
<p>发生输入输出错误的可能情况是无限的！但 C++ 将所有可能的情况归结为四类，称为流状态（stream state）。每种流状态都用一个 iostate 类型的标志位来表示。</p>
<table>
<thead>
<tr>
<th>标志位</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>badbit</td>
<td>发生了（或许是物理上的）致命性错误，流将不能继续使用。</td>
</tr>
<tr>
<td>eofbit</td>
<td>输入结束（文件流的物理结束或用户结束了控制台流输入，例如用户按下了 Ctrl+Z 或 Ctrl+D 组合键。</td>
</tr>
<tr>
<td>failbit</td>
<td>I/O 操作失败，主要原因是非法数据（例如，试图读取数字时遇到字母）。流可以继续使用，但会设置 failbit 标志。</td>
</tr>
<tr>
<td>goodbit</td>
<td>一切止常，没有错误发生，也没有输入结束。</td>
</tr>
<tr>
<td>ios_base 类定义了以上四个标志位以及 iostate 类型，但是 ios 类又派生自 ios_base 类，所以可以使用 ios::failbit 代替 ios_base::failbit 以节省输入。</td>
<td></td>
</tr>
</tbody></table>
<p>一旦流发生错误，对应的标志位就会被设置，我们可以通过下表列出的函数检测流状态。</p>
<table>
<thead>
<tr>
<th>检测函数</th>
<th>对应的标志位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>good()</td>
<td>goodbit</td>
<td>操作成功，没有发生任何错误。</td>
</tr>
<tr>
<td>eof()</td>
<td>eofbit</td>
<td>到达输入末尾或文件尾。</td>
</tr>
<tr>
<td>fail()</td>
<td>failbit</td>
<td>发生某些意外情况（例如，我们要读入一个数字，却读入了字符 ‘x’）。</td>
</tr>
<tr>
<td>bad()</td>
<td>badbit</td>
<td>发生严重的意外（如磁盘读故障）。</td>
</tr>
</tbody></table>
<p>不幸的是，fail() 和 bad() 之间的区别并未被准确定义，程序员对此的观点各种各样。但是，基本的思想很简单：</p>
<ul>
<li>如果输入操作遇到一个简单的格式错误，则使流进入 fail() 状态，也就是假定我们（输入操作的用户）可以从错误中恢复。</li>
<li>如果错误真的非常严重，例如发生了磁盘故障，输入操作会使得流进入 bad() 状态。也就是假定面对这种情况你所能做的很有限，只能退出输入。</li>
</ul>
<p>以上观点导致如下逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">cin</span>)&#123;  <span class="comment">//只有输入操作失败，才会跳转到这里</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cin</span>.bad())&#123;  <span class="comment">//流发生严重故障，只能退出函数</span></span><br><span class="line">        error(<span class="string">"cin is bad!"</span>);  <span class="comment">//error是自定义函数，它抛出异常，并给出提示信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cin</span>.eof())&#123;  <span class="comment">//检测是否读取结束</span></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cin</span>.fail())&#123;  <span class="comment">//流遇到了一些意外情况</span></span><br><span class="line">        <span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">//清除/恢复流状态</span></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!cin 可以理解为“cin 不成功”或者“cin 发生了某些错误”或者“ cin 的状态不是 good()”， 这与“操作成功”正好相反，</p>
<p>注意在处理 fail() 时所使用的 cin.clear()。当流发生错误时，我们可以进行错误恢复。为了恢复错误，我们显式地将流从 fail() 状态转移到其他状态，从而可以继续从中读取字符。clear() 就起到这样的作用——执行 cin.clear() 后，cin 的状态就变为 good()。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面是一个如何使用流状态的例子。假定我们要读取一个整数序列并存入 vector 中，字符*或“文件尾”表示序列结束。Windows 平台按下 Ctrl+Z 组合键，再按下回车键表示到达文件末尾；类Unix系统按下 Ctrl+D 组合键表示到达文件末尾。</p>
<p>上述功能可通过如下函数来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 ist 中读入整数到 v 中，直到遇到 eof() 或终结符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_vector</span><span class="params">(istream&amp; ist, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">char</span> terminator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i; ist&gt;&gt;i; ) v.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常情况</span></span><br><span class="line">    <span class="keyword">if</span>(ist.eof()) <span class="keyword">return</span>;  <span class="comment">//发现到了文件尾，正确，返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生严重错误，只能退出函数</span></span><br><span class="line">    <span class="keyword">if</span> (ist.bad())&#123;</span><br><span class="line">        error(<span class="string">"cin is bad!"</span>);  <span class="comment">//error是自定义函数，它抛出异常，并给出提示信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生意外情况</span></span><br><span class="line">    <span class="keyword">if</span> (ist.fail()) &#123;  <span class="comment">//最好清除混乱，然后汇报问题</span></span><br><span class="line">        ist.<span class="built_in">clear</span>();  <span class="comment">//清除流状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//检测下一个字符是否是终结符</span></span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        ist&gt;&gt;c;  <span class="comment">//读入一个符号，希望是终结符</span></span><br><span class="line">        <span class="keyword">if</span>(c != terminator) &#123; <span class="comment">// 非终结符</span></span><br><span class="line">            ist.unget(); <span class="comment">//放回该符号</span></span><br><span class="line">            ist.<span class="built_in">clear</span>(ios_base::failbit);  <span class="comment">//将流状态设置为 fail()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果发生了 fail()，我们尝试检测下一个字符是否是结束符：如果是，那么就完整得读取了数据，使用 clear() 恢复状态就可以；如果不是，我们就没有办法处理了，所以将状态重新设置为 fail()，以期望 fill_vector() 的调用者（上层函数）有能力处理。</p>
<p>我们通过调用 ist.clear(ios_base::failbit) 来将流状态设置为 fail()。对照简单的cleal()，带参数的用法有些令人迷惑：当 clear() 带参数时，参数中所指出的 iostream 状态位会被置位（进入相应状态)，而未指出的状态位会被复位。通过将流状态设置为 fail()，我们表明遇到了一个格式错误，而不是一个更为严重的问题。</p>
<p>可以用 unget() 将字符放回 ist，以便 fill_vector() 的调用者可能使用该字符。unget() 函数是 putback() 的简化版本，它依赖于流对象记住最后一个字符是什么，所以在这里可以不用考虑它的用法。</p>
<p>如果 fill_vector() 的调用者想知道是什么原因终止了输入，那么可以检测流是处于 fail() 还是 eof() 状态。当然也可以捕获 error() 抛出的 runtime_error 异常，但当 istream 处于 bad() 状态时，继续获取数据是不可能的。大多数的调用者无须为此烦恼。因为这意味着，几乎在所有情况下，对于 bad() 状态，我们所能做的只是抛出一个异常。</p>
<p>简单起见，可以让 istream 帮我们抛出这个异常。</p>
<blockquote>
<p>//当 ist 出现问题时拋出异常<br>ist.exceptions(ist.exceptions() | ios_base:: badbit);</p>
</blockquote>
<p>这样的写法也许看起来有些奇怪，但结果却很简单，当此语句执行时，如果 ist 处于 bad() 状态，它会抛出一个标准库异常 ios_base::failure。在一个程序中，我们只需要调用 exceptions() 一次。这允许我们简化关联于 ist 的所有输入过程，同时忽略对 bad() 的处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从ist中读入整数到v中，直到遇到eof()或终结符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_vector</span><span class="params">(istream&amp; ist, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">char</span> terminator)</span></span>&#123;</span><br><span class="line">    ist.exceptions(ist.exceptions() | ios_base:: badbit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i; ist&gt;&gt;i; ) v.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ist.eof()) <span class="keyword">return</span>;  <span class="comment">//发现到了文件尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是good()，不是bad()，不是eof()，ist的状态一定是fail()</span></span><br><span class="line">    ist.<span class="built_in">clear</span>();  <span class="comment">//清除流状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    ist&gt;&gt;c;    <span class="comment">//读入一个符号，希望是终结符</span></span><br><span class="line">    <span class="keyword">if</span> (c != terminator) &#123; <span class="comment">//不是终结符号，一定是失败了</span></span><br><span class="line">        ist.unget();    <span class="comment">//也许程序调用者可以使用这个符号</span></span><br><span class="line">        ist.<span class="built_in">clear</span>(ios_base::failbit); <span class="comment">//将流状态设置为 fail()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了 ios_base，它是 iostream 的一部分，包含了对常量如 badbit 的定义、异常如 failure 的定义，以及其他一些有用的定义。可以通过::操作符来使用它们，例如 ios_ base::badbit。</p>
<p>与 istream—样，ostream 也有四个状态：good()、fail()、eof() 和 bad()。不过，对于多数人来说，输出错误要比输入错误少得多，因此通常不对 ostream 进行状态检测。如果程序运行环境中输出设备不可用、队列满或者发生故障的概率很高，我们就可以像处理输入操作那样，在每次输出操作之后都检测其状态。</p>
<h2 id="C-管理输出缓冲区"><a href="#C-管理输出缓冲区" class="headerlink" title="C++管理输出缓冲区"></a>C++管理输出缓冲区</h2><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下而的代码：</p>
<blockquote>
<p>cout &lt;&lt; “abcdefg”;</p>
</blockquote>
<p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。</p>
<p>有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。</p>
<p>导致缓冲刷新（数据真正写到输出设备或文件）的原因有很多：</p>
<ul>
<li>程序正常结束，作为 main() 函数的 return 操作的一部分，缓冲刷新被执行。</li>
<li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如 endl 来显式刷新缓冲区。</li>
<li>在每个输出操作之后，我们可以用操作符 unitbuf 设置流的内部状态，来清空缓冲区。默认情况下，对 cerr 是设置 unitbuf 的，因此写到 cerr 的内容都是立即刷新的。</li>
<li>一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin 和 cerr 都关联到 cout。因此，读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新。<h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3>我们已经使用过操作符 endl，它完成换行并刷新缓冲区的工作。IO 库中还有两个类似的操纵符：</li>
<li>flush 和 ends。flush 刷新缓冲区，但不输出任何额外的字符；</li>
<li>ends向缓冲区插入一个空字符，然后刷新缓冲区。</li>
</ul>
<blockquote>
<p>值得一提得是，cout 所属 ostream 类中还提供有 flush() 成员方法，它和 flush 操纵符的功能完全一样，仅在使用方法上（ cout.flush() ）有区别。</p>
</blockquote>
<p>请看下面的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出hi和一个换行，然后刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; <span class="built_in">flush</span>;  <span class="comment">//输出hi，然后刷新缓冲区，不附加任何额外字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; ends;  <span class="comment">//输出hi和一个空字符，然后刷新缓冲区</span></span><br></pre></td></tr></table></figure>
<h3 id="unitbuf-操作符"><a href="#unitbuf-操作符" class="headerlink" title="unitbuf 操作符"></a>unitbuf 操作符</h3><p>如果想在每次输出操作后都刷新缓冲区，我们可以使用 unitbuf 操作符，它告诉流在接下来的每次写操作之后都进行一次 flush 操作。而 nounitbuf 操作符则重置流， 使其恢复使用正常的系统管理的缓冲区刷新机制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;  <span class="comment">//所有输出操作后都会立即刷新缓冲区</span></span><br><span class="line"><span class="comment">//任何输出都立即刷新，无缓冲</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;  <span class="comment">//回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure>
<p><strong>警告：如果程序崩溃，输出缓冲区不会被刷新</strong><br>如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。</p>
<p>当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。</p>
<h3 id="关联输入和输出流"><a href="#关联输入和输出流" class="headerlink" title="关联输入和输出流"></a>关联输入和输出流</h3><p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将 cout 和 cin 关联在一起，因此下面语句：</p>
<blockquote>
<p>cin &gt;&gt; ival;</p>
</blockquote>
<p>导致 cout 的缓冲区被刷新。</p>
<p>交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。</p>
<p>tie() 函数可以用来绑定输出流，它有两个重载的版本：</p>
<blockquote>
<p>ostream* tie ( ) const;  //返回指向绑定的输出流的指针。<br>ostream* tie ( ostream* os );  //将 os 指向的输出流绑定的该对象上，并返回上一个绑定的输出流指针。</p>
</blockquote>
<p>第一个版本不带参数，返冋指向出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。</p>
<p>tie() 的第二个版本接受一个指向 ostream 的指针，将自己关联到此 ostream，即，x.tie(&amp;o) 将流 x 关联到输出流 o。</p>
<p>我们既可以将一个 istream 对象关联到另一个 ostream，也可以将一个 ostream 关联到另一个 ostream：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cout</span>);  <span class="comment">//仅仅是用来展示，标准库已经将 cin 和 cout 关联在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//old_tie 指向当前关联到 cin 的流（如果有的话）</span></span><br><span class="line">ostream *old_tie = <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);  <span class="comment">// cin 不再与其他流关联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 cin 与 cerr 关联，这不是一个好主意，因为 cin 应该关联到 cout</span></span><br><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cerr</span>);  <span class="comment">//读取 cin 会刷新 cerr 而不是 cout</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.tie(old_tie);  <span class="comment">//重建 cin 和 cout 间的正常关联</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了 tie()。为了彻底解开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流， 但多个流可以同时关联到同一个ostream。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wonderperson.github.io/2020/05/12/inout/">https://wonderperson.github.io/2020/05/12/inout/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Wonderperson.github.io" target="_blank">YOUR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a><a class="post-meta__tags" href="/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">输入输出</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.pixabay.com/photo/2020/03/27/15/31/norway-4973912_1280.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/05/10/20200510/"><img class="next_cover" src="https://cdn.pixabay.com/photo/2020/05/09/06/11/bridge-5148390_1280.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">为啥重载运算符要返回自身引用</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/10/20200510/" title="为啥重载运算符要返回自身引用"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2020/05/09/06/11/bridge-5148390_1280.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-10</div><div class="relatedPosts_title">为啥重载运算符要返回自身引用</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/06/c-operator/" title="c++的运算符重载"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2015/06/08/15/11/typewriter-801921_1280.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-06</div><div class="relatedPosts_title">c++的运算符重载</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/06/c-string/" title="字符串操作"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2020/04/28/18/33/key-5105878_1280.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-06</div><div class="relatedPosts_title">字符串操作</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/10/oomaster/" title="面向对象进阶"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2020/05/05/16/48/bush-5133907_1280.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-10</div><div class="relatedPosts_title">面向对象进阶</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/06/template1/" title="模板（一）"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2016/03/09/09/14/books-1245690_1280.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-06</div><div class="relatedPosts_title">模板（一）</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/07/template2/" title="模板（二）"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2020/04/24/08/57/street-5085971_1280.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-07</div><div class="relatedPosts_title">模板（二）</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = 'https://wonderperson.github.io/2020/05/12/inout/';
  this.page.identifier = '2020/05/12/inout/';
  this.page.title = '输入输出流';
};
(function() { 
  var d = document, s = d.createElement('script');
  s.src = 'https://your.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.pixabay.com/photo/2020/03/27/15/31/norway-4973912_1280.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Lee</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>