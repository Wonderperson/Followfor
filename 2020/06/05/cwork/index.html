<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++基础面试题整理 | YOUR</title><meta name="description" content="C语言&#x2F;C++基础面试知识大集合const作用 修饰变量，说明该变量不可以被改变；  修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；  修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；  修饰成员函数，说明该成员函数内不能修改成员变量。   const"><meta name="keywords" content="c++,面试"><meta name="author" content="Lee"><meta name="copyright" content="Lee"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/%E5%88%86%E7%B1%BB-%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="C++基础面试题整理"><meta name="twitter:description" content="C语言&#x2F;C++基础面试知识大集合const作用 修饰变量，说明该变量不可以被改变；  修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；  修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；  修饰成员函数，说明该成员函数内不能修改成员变量。   const"><meta name="twitter:image" content="https://cdn.pixabay.com/photo/2017/03/04/12/15/programming-2115930_960_720.jpg"><meta property="og:type" content="article"><meta property="og:title" content="C++基础面试题整理"><meta property="og:url" content="https://wonderperson.github.io/2020/06/05/cwork/"><meta property="og:site_name" content="YOUR"><meta property="og:description" content="C语言&#x2F;C++基础面试知识大集合const作用 修饰变量，说明该变量不可以被改变；  修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；  修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；  修饰成员函数，说明该成员函数内不能修改成员变量。   const"><meta property="og:image" content="https://cdn.pixabay.com/photo/2017/03/04/12/15/programming-2115930_960_720.jpg"><meta property="article:published_time" content="2020-06-05T08:49:50.000Z"><meta property="article:modified_time" content="2020-06-07T09:05:23.982Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://wonderperson.github.io/2020/06/05/cwork/"><link rel="prev" title="宏定义" href="https://wonderperson.github.io/2020/06/05/c-define/"><link rel="next" title="leetcode_no.151" href="https://wonderperson.github.io/2020/06/03/leetcode-151/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/disqusjs@1.2/dist/disqusjs.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://wonderperson.github.io/","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"HAVE,A,NiCE,DAY","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/xlweb.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">29</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C语言-C-基础面试知识大集合"><span class="toc-number">1.</span> <span class="toc-text">C语言&#x2F;C++基础面试知识大集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">1.1.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">1.1.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-的指针与引用"><span class="toc-number">1.1.2.</span> <span class="toc-text">const 的指针与引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-number">1.1.3.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">1.2.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-指针"><span class="toc-number">1.3.</span> <span class="toc-text">this 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-内联函数"><span class="toc-number">1.4.</span> <span class="toc-text">inline 内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特征"><span class="toc-number">1.4.1.</span> <span class="toc-text">特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编译器对-inline-函数处理步骤"><span class="toc-number">1.4.3.</span> <span class="toc-text">编译器对 inline 函数处理步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优缺点"><span class="toc-number">1.4.4.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚函数（virtual）可以是内联函数（inline）吗？"><span class="toc-number">1.4.5.</span> <span class="toc-text">虚函数（virtual）可以是内联函数（inline）吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">1.5.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assert"><span class="toc-number">1.6.</span> <span class="toc-text">assert()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeof"><span class="toc-number">1.7.</span> <span class="toc-text">sizeof()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pragma-pack-n"><span class="toc-number">1.8.</span> <span class="toc-text">#pragma pack(n)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位域"><span class="toc-number">1.9.</span> <span class="toc-text">位域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-“C”"><span class="toc-number">1.10.</span> <span class="toc-text">extern “C”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extern-“C”-使用"><span class="toc-number">1.10.1.</span> <span class="toc-text">extern “C” 使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-和-typedef-struct"><span class="toc-number">1.11.</span> <span class="toc-text">struct 和 typedef struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C中"><span class="toc-number">1.11.1.</span> <span class="toc-text">C中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-中"><span class="toc-number">1.11.2.</span> <span class="toc-text">C++中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-中-struct-和-class"><span class="toc-number">1.12.</span> <span class="toc-text">C++ 中 struct 和 class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#union-联合"><span class="toc-number">1.13.</span> <span class="toc-text">union 联合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#union-使用"><span class="toc-number">1.13.1.</span> <span class="toc-text">union 使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C语言实现C-类"><span class="toc-number">1.14.</span> <span class="toc-text">C语言实现C++类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit（显式）关键字"><span class="toc-number">1.15.</span> <span class="toc-text">explicit（显式）关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#explicit-使用"><span class="toc-number">1.15.1.</span> <span class="toc-text">explicit 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换函数"><span class="toc-number">1.15.2.</span> <span class="toc-text">类型转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换函数-与-explicit"><span class="toc-number">1.15.3.</span> <span class="toc-text">类型转换函数 与 explicit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#friend-友元类和友元函数"><span class="toc-number">1.16.</span> <span class="toc-text">friend 友元类和友元函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using"><span class="toc-number">1.17.</span> <span class="toc-text">using</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#using-声明"><span class="toc-number">1.17.1.</span> <span class="toc-text">using 声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using-指示-引入命名空间"><span class="toc-number">1.17.2.</span> <span class="toc-text">using 指示 (引入命名空间)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型重定义，取代-typedef"><span class="toc-number">1.17.3.</span> <span class="toc-text">类型重定义，取代 typedef</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.pixabay.com/photo/2017/03/04/12/15/programming-2115930_960_720.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">YOUR</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">C++基础面试题整理</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-05 16:49:50"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-05</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-07 17:05:23"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-07</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">面试题整理</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="C语言-C-基础面试知识大集合"><a href="#C语言-C-基础面试知识大集合" class="headerlink" title="C语言/C++基础面试知识大集合"></a>C语言/C++基础面试知识大集合</h1><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li><p>修饰变量，说明该变量不可以被改变；</p>
</li>
<li><p>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</p>
</li>
<li><p>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</p>
</li>
<li><p>修饰成员函数，说明该成员函数内不能修改成员变量。</p>
</li>
</ol>
<h3 id="const-的指针与引用"><a href="#const-的指针与引用" class="headerlink" title="const 的指针与引用"></a>const 的指针与引用</h3><ol>
<li>指针</li>
</ol>
<ul>
<li>指向常量的指针（pointer to const）</li>
<li>自身是常量的指针（常量指针，const pointer）</li>
</ul>
<ol start="2">
<li>引用</li>
</ol>
<ul>
<li>指向常量的引用（reference to const）</li>
<li>没有 const reference，因为<strong>引用本身就是 const pointer</strong></li>
</ul>
<p>（为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 指针变量，指向常对象</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>

<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><ol>
<li>this 指针是一个隐含于每一个非静态成员函数中的特殊指针。<strong>它指向调用该成员函数的那个对象</strong>。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li>this 指针被隐含地声明为: ClassName const this，<em>这意味着不能给 this 指针赋值</em>；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；。</li>
<li>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（<strong>不能 &amp;this</strong>）。</li>
</ol>
<p>在以下场景中，经常需要显式引用 this 指针：</p>
<ul>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 list。</li>
</ul>
<h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了<strong>虚函数</strong>的其他函数都会自动隐式地当成内联函数。</li>
</ul>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>inline 使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>

<h3 id="编译器对-inline-函数处理步骤"><a href="#编译器对-inline-函数处理步骤" class="headerlink" title="编译器对 inline 函数处理步骤"></a>编译器对 inline 函数处理步骤</h3><ol>
<li>将 inline 函数体复制到 inline 函数调用点处；</li>
<li>为所用 inline 函数中的局部变量分配内存空间；</li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p>
<ul>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ul>
<h3 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h3><ul>
<li><p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</p>
</li>
<li><p>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</p>
</li>
<li><p>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
</li>
</ul>
<p>虚函数内联使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。</span></span><br><span class="line">	Base b;</span><br><span class="line">	b.who();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。</span></span><br><span class="line">	Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">	ptr-&gt;who();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">	ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile int i = 10;</p>
<ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
<h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><p>断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <strong>NDEBUG</strong> 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。</p>
<p><strong>assert() 使用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure>

<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h2><ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
<h2 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h2><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<p><strong>#pragma pack(n) 使用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure>

<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><blockquote>
<p>Bit mode: 2; // mode 占 2 位</p>
</blockquote>
<p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ul>
<li>位域在内存中的布局是与机器有关的</li>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ul>
<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的</li>
</ul>
<p>extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<h3 id="extern-“C”-使用"><a href="#extern-“C”-使用" class="headerlink" title="extern “C” 使用"></a>extern “C” 使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h2><h3 id="C中"><a href="#C中" class="headerlink" title="C中"></a>C中</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>typedef struct Student S; 此时 S 等价于 struct Student，但两个标识符名称空间不相同。</p>
<p>另外还可以定义与 struct Student 不冲突的 void Student() {}。</p>
<h3 id="C-中"><a href="#C-中" class="headerlink" title="C++中"></a>C++中</h3><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p>
<p>1.如果在类标识符空间定义了 struct Student {…};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。</p>
<p>即表现为可以使用 Student 也可以使用 struct Student，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure>
<p>2.若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h2><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<p><strong>区别:</strong></p>
<p>最本质的一个区别就是默认的访问控制</p>
<ul>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ul>
<h2 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h2><p>联合（union）是一种节省空间的特殊的<strong>类</strong>，一个 union 可以有多个数据成员，<strong>但是在任意时刻只有一个数据成员可以有值</strong>。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li><strong>匿名 union 在定义所在作用域可直接访问 union 成员</strong></li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<h3 id="union-使用"><a href="#union-使用" class="headerlink" title="union 使用"></a>union 使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;                       <span class="comment">//匿名 union 在定义所在作用域可直接访问 union 成员</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;                       <span class="comment">//局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C语言实现C-类"><a href="#C语言实现C-类" class="headerlink" title="C语言实现C++类"></a>C语言实现C++类</h2><p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p>
<ul>
<li>封装：使用函数指针把属性与方法封装到结构体中</li>
<li>继承：结构体嵌套</li>
<li>多态：父类与子类方法的函数指针不同</li>
</ul>
<h2 id="explicit（显式）关键字"><a href="#explicit（显式）关键字" class="headerlink" title="explicit（显式）关键字"></a>explicit（显式）关键字</h2><ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外</li>
</ul>
<h3 id="explicit-使用"><a href="#explicit-使用" class="headerlink" title="explicit 使用"></a>explicit 使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	A(<span class="keyword">int</span>) &#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">	A a2 = <span class="number">1</span>;		<span class="comment">// OK：复制初始化</span></span><br><span class="line">	A a3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">	A a4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：复制列表初始化</span></span><br><span class="line">	A a5 = (A)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">	doA(<span class="number">1</span>);			<span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line">	<span class="keyword">if</span> (a1);		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a6（a1）;		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a7 = a1;		<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> a8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;		<span class="comment">// OK：直接初始化</span></span><br><span class="line">	B b2 = <span class="number">1</span>;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">	B b3&#123; <span class="number">1</span> &#125;;		<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">	B b4 = &#123; <span class="number">1</span> &#125;;		<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">	B b5 = (B)<span class="number">1</span>;		<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">	doB(<span class="number">1</span>);			<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line">	<span class="keyword">if</span> (b1);		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;		<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">	<span class="keyword">bool</span> b7 = b1;		<span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line">	<span class="keyword">bool</span> b8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p>在C++中，可以使用构造函数将一个指定类型的数据转换为类的对象，也可以使用 <strong>类型转换函数 (type conversion function)</strong> 将一个类对象转换为其他类型的数据。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den = <span class="number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) m_numerator/m_denominator; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_numerator;        <span class="comment">// 分子</span></span><br><span class="line">        <span class="keyword">int</span> m_denominator;      <span class="comment">// 分母</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>; </span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.2</span> + f;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.2</strong> 是一个浮点类型的变量，而 <strong>f</strong> 是一个 <strong>Fraction</strong> 类型的变量，因此不能直接相加，于是编译器会到分数类中寻找，找到了 <strong>operator double</strong> 函数，该函数可以将类型对象转换为一个浮点类型的变量。因此该函数就是我们所说的<strong>类型转换函数(type conversion function)</strong>。通过分数类中的转换函数，我们给出转换函数的一般形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> 类型名称() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// 实现转换      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>转换函数必须是类的成员函数</li>
<li>转换函数不能声明返回类型</li>
<li>形参列表必须为空</li>
<li>类型转换函数通常应该是const</li>
</ol>
<p>类型转换运算符是隐式执行的，因此对象 f 就拥有了双重类型，既可以是类类型，也可以是double类型。</p>
<h3 id="类型转换函数-与-explicit"><a href="#类型转换函数-与-explicit" class="headerlink" title="类型转换函数 与 explicit"></a>类型转换函数 与 explicit</h3><p>既然可以调用类型转换函数将该 <strong>Fraction</strong> 类型转换为 <strong>double</strong> 类型，那么也可以通过重载+将double类型转换为类类型。因此该类的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den = <span class="number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span> + (<span class="keyword">const</span> Fraction&amp; f) &#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(f.m_numerator + <span class="keyword">this</span>-&gt;m_numerator , f.m_denominator + <span class="keyword">this</span>-&gt;m_denominator); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>; </span><br><span class="line">    Fraction d = f + <span class="number">3.2</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们将 <strong>f + 3.2</strong> 的值赋值给 <strong>d</strong> 实例时， <strong>3.2</strong> 就通过构造函数转换为<strong>Fraction</strong> 类型，然后调用 <strong>operator +</strong> 函数将两个实例加起来赋值给 <strong>d</strong> 对象。</p>
<p>但是如果同时存在类型转换函数，则会可能出现以下情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* explicit */</span> Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den = <span class="number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    <span class="comment">/* explicit */</span><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) m_numerator/m_denominator; </span><br><span class="line">    &#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span> + (<span class="keyword">const</span> Fraction&amp; f) &#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(f.m_numerator+<span class="keyword">this</span>-&gt;m_numerator, f.m_denominator+<span class="keyword">this</span>-&gt;m_denominator); </span><br><span class="line">        <span class="comment">//设计有缺陷，应该先通分再合并</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>; </span><br><span class="line">    <span class="keyword">double</span> d = f + <span class="number">3.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果编译上述的代码可能就会立刻报错：<strong>ambiguous overload for ‘operator+’ (operand types are ‘Fraction’ and ‘double’)</strong></p>
<p>因为存在了二义性。我们来具体分析以下：</p>
<ul>
<li>f对象可以通过类型转换函数将类类型转换为double类型，然后加上3.2赋值给d。</li>
<li>3.2也可以通过构造函数将double类型转换为Fraction类型，然后两个类类型相加，又可以通过类型转换函数转换为double类型，所以这种方法也可以。</li>
<li>因此，以上两种方式都可以，所以编译器会报<strong>二义性</strong>的错误。</li>
</ul>
<p>解决的办法就是，使用<strong>explicit</strong>关键字的限制，使用方法也有两种：</p>
<ul>
<li>直接在构造函数前加上explicit关键字，防止double类型的变量隐式的转换为类类型。</li>
<li>在转换构造函数operator double前加上explicit关键字，表示只有显示的将类类型转换为double类型时才调用该函数。</li>
</ul>
<p>例如：</p>
<blockquote>
<p>double d = static_cast<double>(f) + 3.2</p>
</blockquote>
<p>后面的方法是<strong>C++11</strong>新引入的显示的类型转换运算符。</p>
<p>我们要尽量避免有二义性的类型转换，如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式，否则将出现二义性。</p>
<h2 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h2><ul>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
<h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><h3 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h3><p><strong>using 声明 (using declaration)</strong> 是将命名空间中单个名字注入到<strong>当前作用域</strong>的机制，使得在<strong>当前作用域</strong>下访问另一个作用域下的成员时无需使用限定符 <strong>::</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; the_map; <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; the_map2;  <span class="comment">//error，不在作用域内</span></span><br></pre></td></tr></table></figure>
<p>using 声明将其它 namespace 的成员引入本命名空间的 当前作用域 <strong>(包括其嵌套作用域)</strong> 。一个 using 声明一次只引入一个命名空间成员，它使得无论程序中使用哪些名字，都非常准确。</p>
<p>利用 using 声明，可以改变派生类对父类成员的访问控制:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> bn1;</span><br><span class="line">    <span class="keyword">int</span> bn2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::bn1;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedAgain</span>:</span> <span class="keyword">public</span> Derived&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    DerivedAgain da; </span><br><span class="line">    d.bn1 = <span class="number">1</span>;</span><br><span class="line">    d.bn2 = <span class="number">2</span>; <span class="comment">//error, 'bn2' is a private member of 'Base'</span></span><br><span class="line">    da.bn1 = <span class="number">3</span>;  <span class="comment">//ok</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;d.bn1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管 Derived 对 base 是私有继承，但通过 using 声明，我们还是可以在 Derived 中访问其成员，且后续的继承同样不受 private 限定的影响。</p>
<p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<blockquote>
<p>Derived(parms) : Base(args) { }</p>
</blockquote>
<h3 id="using-指示-引入命名空间"><a href="#using-指示-引入命名空间" class="headerlink" title="using 指示 (引入命名空间)"></a>using 指示 (引入命名空间)</h3><p>using 指示 (using directive) 是使一个命名空间中的 所有 名字都在该作用域中可见的机制。这是最常用的方式了。需要注意的是命名冲突问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> n1&#123; </span><br><span class="line">    <span class="keyword">int</span> n1_member = <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">11</span>; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> m = <span class="number">12</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> n1; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;n1_member&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;m&lt;&lt;std::endl;  //error 命名冲突</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;::m&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">13</span>; <span class="comment">//ok, 局部变量屏蔽命名空间变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Notice</strong>: 尽管 using指示很方便，但在实际工作中应该尽量避免：它一下子将另一个 namespace 中的成员全部引入了，一不小心就会出现<strong>命名空间污染</strong>问题。</p>
<h3 id="类型重定义，取代-typedef"><a href="#类型重定义，取代-typedef" class="headerlink" title="类型重定义，取代 typedef"></a>类型重定义，取代 typedef</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> alias = <span class="keyword">typename</span></span><br></pre></td></tr></table></figure>
<p>这是 C++11 中的新用法，比 typedef 更能表达别名的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> fun = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//typedef void (*fun)(int, int); //与上一句等价</span></span><br><span class="line"><span class="keyword">using</span> int16 = short;</span><br><span class="line"><span class="comment">//typedef short int16; //与上一句等价</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(int16)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wonderperson.github.io/2020/06/05/cwork/">https://wonderperson.github.io/2020/06/05/cwork/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Wonderperson.github.io" target="_blank">YOUR</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.pixabay.com/photo/2020/06/20/00/39/barbados-5319257_960_720.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/05/c-define/"><img class="prev_cover" src="https://cdn.pixabay.com/photo/2017/01/18/17/14/girl-1990347_960_720.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">宏定义</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/03/leetcode-151/"><img class="next_cover" src="https://cdn.pixabay.com/photo/2020/06/06/14/36/ice-5266805_960_720.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode_no.151</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/10/20200510/" title="为啥重载运算符要返回自身引用"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2020/05/09/06/11/bridge-5148390_1280.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-10</div><div class="relatedPosts_title">为啥重载运算符要返回自身引用</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/06/20200606/" title="c语言结构体struct所占字节数求解"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2020/06/01/23/21/smilies-5248759_960_720.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-06</div><div class="relatedPosts_title">c语言结构体struct所占字节数求解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/05/c-define/" title="宏定义"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2017/01/18/17/14/girl-1990347_960_720.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-05</div><div class="relatedPosts_title">宏定义</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/05/c-inline/" title="inline 函数————内联函数"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2017/03/09/12/31/error-2129569_960_720.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-05</div><div class="relatedPosts_title">inline 函数————内联函数</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/06/c-string/" title="字符串操作"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2020/04/28/18/33/key-5105878_1280.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-06</div><div class="relatedPosts_title">字符串操作</div></div></a></div><div class="relatedPosts_item"><a href="/2020/05/06/c-operator/" title="c++的运算符重载"><img class="relatedPosts_cover" src="https://cdn.pixabay.com/photo/2015/06/08/15/11/typewriter-801921_1280.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-06</div><div class="relatedPosts_title">c++的运算符重载</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = 'https://wonderperson.github.io/2020/06/05/cwork/';
  this.page.identifier = '2020/06/05/cwork/';
  this.page.title = 'C++基础面试题整理';
};
(function() { 
  var d = document, s = d.createElement('script');
  s.src = 'https://your.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.pixabay.com/photo/2017/03/04/12/15/programming-2115930_960_720.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Lee</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script></body></html>