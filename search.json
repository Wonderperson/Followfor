[{"title":"链表总结","url":"/2020/05/04/链表总结/","content":"\n# 链表\n\n**链表的定义（来自维基百科）**：\n\n在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（“links”）。\n\n**链表与顺序表的区别（来自维基百科）**：\n\n链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。\n\n**顺序表与数组的区别**：\n\n顺序表是在计算机内存中以数组的形式保存的线性表。\n\n顺序表是指用一组地址连续的存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表，顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。线性表采用指针链接的方式存储就称之为链表。\n\n线性表是从逻辑结构的角度来说的，除了头和尾之外，它的每一个元素都只有一个前驱元素和一个后驱元素。各种队列（单向、双向、循环队列），栈等都是线性表的不同例子。\n\n而数组是从物理存贮的角度来说的，线性表可以用数组存贮也可以用链表来存贮。同样的队列和栈也可以用数组和链表存贮，各有利弊。具体使用时，根据具体情况选择。 \n\n所以说，数组是一个更大的概念。使用数组，不但可以存储线性表，也可存储非线性结构的数据结构。比如堆、完全二叉树、乃至于其它类型的树、图等。\n\n顺序表与数组都是数据结构，只是描述角度不同。顺序表是从逻辑结构的角度来说的，它的每一个元素都只有一个前驱元素和一个后驱元素除了头和尾，逻辑结构还有队列，堆栈，树，图等。而数组是从物理存贮的角度来说的，顺序表用数组存贮也可以用链表来存贮。同样的队列也可以用数组和链表存贮，各有利弊。具体使用时，根据具体情况选择。\n\n\n>1. 数组就是相同数据类型的元素按一定顺序排列的集合。\n>\n>一句话：就是物理上存储在一组联系的地址上。也称为数据结构中的物理结构。\n>\n>2. 线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。\n>\n>一句话：线性表是数据结构中的逻辑结构。可以存储在数组上，也可以存储在链表上。\n>\n>3. 线性表的结点按逻辑次序依次存放在一组地址连续的存储单元里的方法。用顺序存储方法存储的线性表简称为顺序表。\n>\n>一句话：用数组来存储的线性表就是顺序表。\n\n**链表的优缺点（来自维基百科）**：\n\n使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。\n链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。\n\n**链表的类型（来自维基百科）**：\n\n单向链表，双向链表以及循环链表。\n\n## 单向链表\n\n**单向链表的定义：**\n\n单向链表是链表类型中最为简单的一种，每个节点包含两个域，一个数据域(data)，一个指针域(next)。单向链表的next节点指向下一节点，而尾节点的next节点为空。\n\n**单向链表节点的定义：**\n```c++\nstruct ListNode\n{\n\tint val;\n    ListNode *next;\n    ListNode(int x):val(x),next(nullptr){}\n};\n```\n![20200504153648](https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504153648.png)\n\n**单链表的模板：**\n```c++\n#include <iostream>\nusing namespace std;\n\nclass MyListForward\n{\nprivate:\n    struct ListNode\n    {\n        int val;\n        ListNode *next;\n        ListNode(int x):val(x),next(nullptr){}\n    };\n    ListNode* head;\npublic:\n    MyListForward():head(nullptr){}\n\n    //1、获得链表中第index个节点的值\n    int get(int index){\n        int i=0;\n        ListNode *p=head;\n        while(p&&i<index){\n            p=p->next;\n            i++;\n        }\n        if(p)return p->val;\n        else return -1; //如果为第index节点值为空值则返回-1；\n    }\n\n    //2、在链表头部插一个值为val的节点\n    void addAtHead(int val){\n        ListNode *p=new ListNode(val);\n        p->next=head;\n        head=p;//更换头节点\n    }\n\n    //3、在链表尾部添加一个值为val的节点\n    void addAtTail(int val){\n        ListNode *p=new ListNode(val);\n        //链表为空，直接将新节点作为头节点\n        if(head==nullptr){\n            head=p;\n            return;\n        }\n        ListNode *q=head;\n        //遍历直到q的next节点为空\n        while(q->next){\n            q=q->next;\n        }\n        q->next=p;\n    }\n\n    //4、在索引为index的节点之前添加值为val的节点\n    void addAtIndex(int index,int val){\n        ListNode *node=new ListNode(val);\n        //1、index小于等于0，直接在头部插入节点\n        if(index<=0)\n        {//若index小于等于0，我们仅需要在头节点前面插入新节点就行了\n        //注意这里不能使用指针p，因为p=node时，p所指向的地址发生了变化，head指向的地址没有变化，所以我们这里要使用指针head\n            node->next=head;\n            head=node;\n            return;\n        }\n        int i=0;\n        ListNode *p=head;\n        //在索引为index的节点之前插入新节点，我们需要找到它的前驱节点，然后插入在它的前驱节点后面\n        while(p&&i<index-1)\n        {\n            p=p->next;\n            ++i;\n        }\n        //2、p为索引节点的前驱节点\n        if(p)\n        {\n            node->next=p->next;\n            p->next=node;\n        }\n    }\n\n    //5、删除索引为index的节点\n    void deleteAtIndex(int index){\n        //1、index为0，我们直接删除head节点\n        if(index==0&&head!=nullptr)\n        {\n            ListNode *del=head;\n            head=head->next;\n            delete del;\n            return;\n        }\n        int i=0;\n        ListNode* p=head;\n        //删除索引为index的节点，我们需要找到它的前驱节点p，p->next为需要删除节点\n        while(p&&i<index-1)\n        {\n            p=p->next;\n            i++;\n        }\n        //2、index超过链表范围，删除失败\n        if(!p)return;\n        //3、index的位置合法，我们找到需要删除的p->next节点\n        if(p->next)\n        {\n            ListNode *del=p->next;\n            p->next=del->next;\n            delete del;\n        }\n    }\n\n    //6、链表长度\n    int length(){\n        int i=0;\n        ListNode *p=head;\n        while(p){\n            i++;\n            p=p->next;\n        }\n        return i;\n    }\n\n    //7、清空链表\n    void clear(){\n        ListNode *del=nullptr;\n        while(head){\n            del=head;\n            head=head->next;\n            delete del;\n        }\n    }\n};\n\nint main()\n{\n    MyListForward mlf;\n    mlf.addAtIndex(0,10);\n    mlf.addAtIndex(0,20);\n    mlf.addAtIndex(1,30);\n    for(int i=0;i<mlf.length();++i){\n        cout<<mlf.get(i)<<\" \";\n    }\n    cout<<endl;\n    mlf.clear();\n    cout<<mlf.length()<<endl;\n    system(\"pause\");\n}\n\n```\n\n## 双向链表\n**双向链表的定义：**\n\n双向链表是一种更为复杂的链表，每个节点包含三个域，一个数据域(data)和两个指针域(prev、next)，其中数据域存放节点的数值，prev指向该节点的前一个节点，next指向该节点的后一个节点。\n\n**双向链表节点的定义：**\n```c++\nstruct ListNode\n{\n\tint val;\n    ListNode *next,*prev;\n    ListNode(int x):val(x),next(nullptr),prev(nullptr){}\n};\n```\n![20200504155110](https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504155110.png)\n\n**双向链表的模板：**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass MyList\n{\nprivate:\n    struct ListNode\n    {\n        int val;\n        ListNode *next,*prev;\n        ListNode(int x):val(x),next(nullptr),prev(nullptr){}\n    };\nprivate:\n    //头节点尾节点都为空，表示为空链表\n    ListNode *head,*tail;\n    int size=0;\npublic:\n    MyList():size(0),head(nullptr),tail(nullptr){}\n\n    //1、获得索引为index的节点值\n    int get(int index){\n        int i=0;\n        ListNode *p=head;\n        while(p&&i<index){\n            p=p->next;\n            i++;\n        }\n        if(p)return p->val;\n        else return -1;\n    }\n\n    //2、在头部插入值为val的新节点\n    void addAtHead(int val){\n        if(head!=nullptr){\n            ListNode *node=new ListNode(val);\n            node->next=head;\n            head->prev=node;\n            head=node;\n        }\n        else{\n            head=new ListNode(val);\n            tail=head;\n        }\n        ++size;\n    }\n\n    //3、在尾部插入值为val的新节点\n    void addAtTail(int val){\n        if(tail!=nullptr){\n            ListNode *node=new ListNode(val);\n            node->prev=tail;\n            tail->next=node;\n            tail=node;\n        }\n        else{//尾节点为空，那么头节点也为空，然后首尾节点都为新节点\n            tail=new ListNode(val);\n            head=tail;\n        }\n        ++size;\n    }\n\n    //4、在index之前添加值为val的新节点\n    void addAtIndex(int index,int val){\n        //首先排除三种特殊情况的index，然后剩下来的index肯定在链表内\n        if(index<=0){\n            addAtHead(val);\n            return;\n        }\n        if(index==size){\n            addAtTail(val);\n            return;\n        }\n        if(index>size)return;\n        ListNode *p=nullptr,*cur=head;\n        int i=0;\n        while(cur&&i<index){\n            p=cur;\n            cur=cur->next;\n            i++;\n        }\n        ListNode *node=new ListNode(val);\n        //由于前面已经将特殊情况的index排除了，现在的p和cur都有效，都在链表内\n        p->next=node;\n        node->prev=p;\n        node->next=cur;\n        cur->prev=node;\n        size++;\n    }\n\n    //5、删除索引为index的节点\n    void deleteAtIndex(int index){\n        //链表为空时，不能删除\n        if(!head)return;\n        if(index==0)\n        {\n            ListNode *del=head;\n            head=head->next;\n            if(head){//链表有2个以上节点\n                head->prev=nullptr;\n            }\n            else{//链表只有一个节点，将尾部制空\n                tail=nullptr;\n            }\n            delete del;\n            size--;\n            return;\n        }\n        //index为最后为尾节点，我们需要删除尾节点\n        if(index==size-1){\n            ListNode *del=tail;\n            tail=tail->prev;\n            //注意这里不用处理tail为空，因为tail为空的话，那么链表只有单个节点\n            //然而单个节点只能删除0号节点，只有index为0时才能删除，前面已经处理过了index为0的情况了，所以这里不在处理\n            if(tail){\n                tail->next=nullptr;\n            }\n            delete del;\n            size--;\n            return;\n        }\n        int i=0;\n        ListNode *p=nullptr,*cur=head;\n        while(cur){\n            if(i==index){\n                ListNode *del=cur;\n                p->next=cur->next;\n                if(cur->next){\n                    cur->next->prev=p;\n                }\n                delete del;\n                size--;\n                return;\n            }\n            p=cur;\n            cur=cur->next;\n            ++i;\n        }\n    }\n\n    //6、获得链表的长度\n    int length(){\n        return size;\n    }\n\n    //7、清空链表\n    void clear(){\n        for(int i=size-1;i>=0;--i){\n            deleteAtIndex(i);\n        }\n    }\n};\n\nint main()\n{\n    MyList ml;\n    ml.addAtHead(1);\n    ml.addAtTail(3);\n    ml.addAtHead(4);\n    ml.addAtHead(5);\n    ml.addAtIndex(1,2);\n    for(int i=0;i<ml.length();++i){\n        cout<<ml.get(i)<<\" \";\n    }\n    cout<<endl;\n    ml.deleteAtIndex(1);\n    for(int i=0;i<ml.length();++i){\n        cout<<ml.get(i)<<\" \";\n    }\n    cout<<endl;\n    ml.clear();\n    cout<<ml.length()<<endl;\n    system(\"pause\");\n}\n\n```\n## 环形链表\n\n**环形链表的定义：**\n\n循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存， 假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。\n![20200504155514](https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504155514.png)\n# 习题解析\n## 链表中的双指针技巧\n\n[19. 删除链表的倒数第N个节点](https://xiaoneng.blog.csdn.net/article/details/97423144)：**快慢指针法**，起始快指针走n步后，若此时快指针已为空，表示我们删除第一个节点，直接返回head->next即可；否则此时快慢指针一起走，也就是慢指针走size-n步到达倒数第N个节点的前驱节点，快指针会到达链表的尾节点，此时我们删除slow->next节点即可。\n\n[86. 分隔链表](https://blog.csdn.net/qq_43152052/article/details/103322178)：**双指针法**，before_head链表存放比x小的节点，after_head链表存放比x大于或等于的节点，我们分别用before和after来前面两个链表添加节点，用head来遍历原始链表。当原始链表遍历完成时，我们需要将before_head链表连接上after_head链表，即before->next=after_head->next;after->next=nullptr;。\n\n[92. 反转链表 II](https://xiaoneng.blog.csdn.net/article/details/103648554)：**双指针法**，指针pre指针指向m的前驱节点，用来将cur的next节点插入到pre后面，指针cur指向位置m起始节点，该节点保持不变，每次需要将cur连接上nxt后边的部分。换句话说，我们要将[m+1,n]的节点每次都要插到位置m之前，这样就完成了反转。\n\n[141. 环形链表](https://xiaoneng.blog.csdn.net/article/details/97416410)：**快慢指针法**，若存在环最终快慢指针会相遇；若不存在环，那么快指针一定会先走到链表尾部。\n\n[142. 环形链表 II](https://xiaoneng.blog.csdn.net/article/details/97420675)：**快慢指针法**，首先利用141的代码判断是否存在环，然后相遇之后将fast指针指向头节点，然后fast和slow现在开始每次走一步，相遇点就是环的入口。\n\n[143. 重排链表](https://blog.csdn.net/qq_43152052/article/details/103588663)：**首尾指针法**，首先将原始链表的每一个节点存放在一个数组中，然后我们取首尾指针向中间遍历，每次循环我们需要将左指针的节点连上右指针的节点，在节点连上之后，我们需要将右指针连上未排序的首节点。\n\n[160. 相交链表](https://xiaoneng.blog.csdn.net/article/details/97421357)：本题也属于**快慢指针法**，具体思路更抽象的说就是将链表AB分别变成了A->B和B->A（这里假设A更短一点），这里我们用ha遍历A->B，hb遍历B->A，然后ha指针先走到A-B的B部分，hb指针还在走在B-A的B部分，当hb走到B-A的A部分时，最终二者会相遇，而相遇部分就是公共部分。\n\n[109. 有序链表转换二叉搜索树](https://blog.csdn.net/qq_43152052/article/details/103445269)：**快慢指针法**，用两个指针，一块一慢，快的每次走两步，慢的每次走一步，这样当快指针遍历结束时，慢指针指向的也就是链表的中间位置。这时候把中间位置的节点的值作为二叉搜索树根节点的值。因为二叉搜索树对应的就是一个有序数组，根节点对应的元素值为为有序数组最中间的位置。\n\n[206. 反转链表](https://blog.csdn.net/qq_43152052/article/details/100934558)：**双指针法**，指针pre用来表示前驱节点，指针cur用来遍历链表，每次循环改变将pre->cur的方向改变为pre<-cur，直到遍历结束。\n\n[234. 回文链表](https://xiaoneng.blog.csdn.net/article/details/104034708)：**快慢指针法**，快指针走两步，慢指针走一步，找到链表的中点。然后，翻转后半部分。最后从前半部分链表和后半部分链表是否相同。\n\n[876. 链表的中间结点](https://blog.csdn.net/qq_43152052/article/details/103995590)：**快慢指针法**，快指针走两步，慢指针走一步，等快指针走到链表尾节点时，慢指针的位置就是中位数的位置。\n\n## 链表排序问题\n[147. 对链表进行插入排序](https://blog.csdn.net/qq_43152052/article/details/103662802)：**插入排序**，我们每次用head->next来进行插入排序，每次插入排序，我们需要从链表的头部开始寻找插入点，所以我们使用一个指针pre来寻找插入点，若pre->next的节点值大于等于head->next的节点时，我们的插入位置就是pre->next，这里处理起来可能麻烦点，大家仔细看代码即可。\n\n[148. 排序链表](https://blog.csdn.net/qq_43152052/article/details/103661851)：**归并排序**，先2个2个的 merge，完成一趟后，再 4个4个的 merge，直到结束。\n\n\n## 链表经典题目\n[2. 两数相加](https://blog.csdn.net/qq_43152052/article/details/89285335)：**模拟题**，由于链表是逆序存放数字的，所以链表数字从左至右低位对低位，高位对高位，因此我们从左至右遍历两个链表模拟加法运算即可，注意向高位进位。\n\n[21. 合并两个有序链表](https://xiaoneng.blog.csdn.net/article/details/97426128)：**模拟题**，每次循环比较l1->val和l2->val，若l1->val<l2->val，则在cur后面添加l1；否则在cur后面添加l2。\n\n[23. 合并K个排序链表](https://blog.csdn.net/qq_43152052/article/details/103183470)：**方法1：分治法**，将k个链表利用二分分为k个独立子链表，然后两两进行合并，最后形成一个排序链表。**方法2：优雅的暴力法**，利用队列queue来实现两两链表的组合，首先将队列前两个链表合并成一个，然后添加到队列的尾部，直到队列中只有一个链表时，表示k个链表已经合成了。\n\n[24. 两两交换链表中的节点](https://blog.csdn.net/qq_43152052/article/details/100888248)：**简单递归**，每次递归交换head与nxt即可，也就是完成了两两交换链表中的节点。\n\n[25. K 个一组翻转链表](https://blog.csdn.net/qq_43152052/article/details/103324877)：**分治法**，将链表按长度k进行分组，然后每次翻转长度k的链表，注意翻转了长度k的链表后新链表的尾部还要连接未翻转部分。\n\n[61. 旋转链表](https://blog.csdn.net/qq_43152052/article/details/89366849)：**模拟题**，先求出链表长度size，若k取余size为空，那么不用旋转了，直接返回head；否则将链表首尾相连形成环形链表，由于k表示尾节点移动k%size位，那么头节点移动size-k%size位。\n\n[82. 删除排序链表中的重复元素 II](https://blog.csdn.net/qq_43152052/article/details/103544889)：**模拟题**，遍历链表，若head的节点值与head的next节点值不相等，则pre指向head，也就是不重复节点；若相等，我们需要找到重复值子链表的最后一个节点，然后令pre指向head->next，同时head移动到下一个节点。\n\n[83. 删除排序链表中的重复元素](https://blog.csdn.net/qq_43152052/article/details/103533398)：**模拟题**，直接遍历链表，遇到重复值的节点删除即可。\n\n[138. 复制带随机指针的链表](https://blog.csdn.net/qq_43152052/article/details/89323912)：**模拟题**，分三步，第一步在原链表的每个节点后面拷贝出一个新的节点，第二步拷贝random，第三步断开链表。\n\n[203. 移除链表元素](https://xiaoneng.blog.csdn.net/article/details/104033912)：**模拟题**，直接遍历链表确定是否删除节点即可。\n\n[445. 两数相加 II](https://blog.csdn.net/qq_43152052/article/details/103996408)：**双栈法**，将两个链表节点值全部压入栈中，然后每次去栈顶元素进行相加，因为这样保证了低位和低位相加，不会出现错位现象。最后直到两个栈为空且进位为0为止，就表示相加完成了。\n\n[725. 分隔链表](https://blog.csdn.net/qq_43152052/article/details/103995776)：**模拟题**，首先求出链表的长度，然后根据k来求得每段链表的平均长度，顺便求出余数。由于题目要求每部分长度相差不能超过1，而且排在前面的部分长度要大于后面部分的长度，所以我们根据余数的个数，给排在前面的部分长度+1。\n\n[430. 扁平化多级双向链表](https://blog.csdn.net/qq_43152052/article/details/89304371)：**模拟题**，迭代法，遍历链表，若发现该链表存在child节点那么就将[child,tail]这段子链表插入到当前节点的后面去，然后继续遍历链表。\n\n[817. 链表组件](https://blog.csdn.net/qq_43152052/article/details/103997681)：**模拟题**，如果当前的节点在列表G中，并且下一个节点不在列表G中，我们就找到了一个组件的尾节点，将res加1。\n\n[1171. 从链表中删去总和值为零的连续节点](https://blog.csdn.net/qq_43152052/article/details/103997711)：**模拟题**，直接遍历链表进行删除和为0的连续子链表。\n\n\n\n>文章转载：[algsup](https://xiaoneng.blog.csdn.net/article/details/104007259)\n\n\n","tags":["数据结构","链表"],"categories":["总结"]},{"title":"0503leetcode","url":"/2020/05/03/0503leetcode/","tags":["leetcode","题解"],"categories":["leetcode刷题记录"]},{"title":"0502leetcode","url":"/2020/05/02/0502leetcode/","content":"\n### 142. 环形链表 II\n\n<center>\n\n![20200502162145](https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502162145.png)\n</center>\n\n\n**解题思路：**\n\n<center>\n\n![20200502162430](https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502162430.png)\n</center>\n\n**代码：**\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head == nullptr || head->next == nullptr)\n         return nullptr;\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while(fast != nullptr){\n           fast =fast->next;\n           if(fast != nullptr){\n               fast = fast->next; \n           }\n           //else break;\n           slow =slow->next;\n           if(fast == slow){\n               while(fast != nullptr && head != nullptr){\n                   if(fast == head)\n                   return fast;\n                   fast = fast->next;\n                   head = head->next;\n               }\n           } \n        }\n        return nullptr;\n        \n    }\n};\n```\n### 25. K 个一组翻转链表\n\n<center>\n\n![20200502164548](https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502164548.png)\n</center>\n\n**解题思路：**\n1. 为链表设置虚拟头结点**dummyhead**，链表设置虚拟头结点dummyhead，这样对链表来说，第一个元素就是dummyhead的next所对应的节点元素，而不是dummyhead所对应的节点元素。dummyhead位置所对应的元素是根本不存在的，这只是未来我们编写逻辑方便而出现的一个虚拟头结点。dummyhead就是索引为0的这个位置的元素的前一个节点。当我们有了dummyhead后，为链表添加一个元素，就不需要对头结点进行特殊处理了，只需要找到等待添加位置的前一个位置的节点，**此时对于链表来说，所有位置都有前一个节点。**\n\n2. 代码主要分为两部分，一部分负责切割链接，另一部分负责将切割下来的链表反转并将链表头指针返回。\n3. Tail的使用\n\n![20200502171941](https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502171941.png)\n\n**代码：**\n```c++\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if (k == 1 || head == NULL) return head;\n        ListNode* dummy = new ListNode(0);\n        ListNode* Tail = dummy;//Tail是当前已经确定的尾部\n        //ListNode* Head = head;//还没有确定的首部\n        ListNode* p=head;//游标\n        int count = 0;\n        while (head) {\n            count = 0;\n            while ((p != NULL) && (count < k)) {\n                p = p->next;\n                count++;\n            }\n            if (count < k) {//如果小于k个，则用上一个模块的Tail直接连接首部就可以\n                Tail->next = head;\n                return dummy->next;//输出\n            }\n            else {//如果不小于k个，\n                Tail->next = reversegroup(head, k);//更新已经确定的尾部\n                while (Tail->next != NULL)Tail = Tail->next;//更新Tail，把Tail更新到指向为空\n                head = p;//更新没有确定的首部\n            }\n        }\n        return dummy->next;\n    }\n    ListNode* reversegroup(ListNode* head, int k) {//从abcd变成bcda\n        ListNode* cur;\n        ListNode* tail;//当前已经完成翻转的链表的第一个节点\n        ListNode* ahead;//存储旧链表中cur指向的节点\n        tail = nullptr;\n        cur = nullptr;\n        ahead = head;\n        int count = 1;\n        while (count < k) {\n            cur = ahead;\n            ahead = cur->next;//存储旧链表中cur指向的节点\n            cur->next = tail;//指向已经完成翻转的链表的第一个节点\n            tail = cur;//更新tail\n            count++;\n        }\n        ahead->next = tail;\n        return ahead;//返回小模块的第一个节点，用以作为连接外层循环Tail指向的对象\n    },\n};\n```","tags":["leetcode","题解"],"categories":["leetcode刷题记录"]},{"title":"test","url":"/2020/05/01/test/","content":"\n## 测试\n\n1111111\n\n![分类-守望先锋](https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/%E5%88%86%E7%B1%BB-%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B.png)\n\n\n","categories":["test"]},{"title":"Hello World","url":"/2020/05/01/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","categories":["Hexo"]}]