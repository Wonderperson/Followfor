<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>为啥重载运算符要返回自身引用</title>
      <link href="/2020/05/10/20200510/"/>
      <url>/2020/05/10/20200510/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么重载运算符一定要返回自身引用"><a href="#为什么重载运算符一定要返回自身引用" class="headerlink" title="为什么重载运算符一定要返回自身引用"></a>为什么重载运算符一定要返回自身引用</h3><p>结论:</p><ul><li>可以实现和cout一样连续调用</li><li>避免了一次拷贝构造和析构，提升程序性能</li></ul><h3 id="返回自身类型是为了实现连续赋值"><a href="#返回自身类型是为了实现连续赋值" class="headerlink" title="返回自身类型是为了实现连续赋值"></a>返回自身类型是为了实现连续赋值</h3><p>首先给出一个Number类为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;<span class="comment">//用于计算调用了几次构造函数，包括拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Number(<span class="keyword">int</span> n=<span class="number">0</span>):num(n)<span class="comment">//默认参数为零，可以同时当默认构造函数使用</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;<span class="comment">//每次调用一次加1</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Count of constructed class Number: "</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Number(<span class="keyword">const</span> Number&amp; other)<span class="comment">//自定义拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        num=other.num;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Count of constructed(Copy) class Number:"</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Number()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructor has been called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"num的值:"</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Number::count=<span class="number">0</span>;<span class="comment">//count初始值设为0</span></span><br></pre></td></tr></table></figure><p>1) 首先现在类里添加一个重载 = 的方法，不过其返回类型为void:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Number&amp; other)<span class="comment">//只是改了函数名，将“equal”改为“operator=”</span></span><br><span class="line">&#123;</span><br><span class="line">num=other.num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Number <span class="title">n1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Number n2;</span><br><span class="line"> </span><br><span class="line">    n2=n1;</span><br><span class="line">    n2.printNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：       </p><blockquote><p>Count of constructed class Number: 1<br>Count of constructed class Number: 2<br>num的值:1<br>Destructor has been called<br>Destructor has been called   </p></blockquote><p>2) 赋值操作符调用成功,那么问题来了，既然void就可以，为什么开头的重载函数要返回Number类型呢？<br>如果我们回顾一下int类型的赋值我们可以发现它是可以连续赋值的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i1=<span class="number">2</span>,i2=<span class="number">2</span>,i3=<span class="number">3</span>;</span><br><span class="line">    i1=i2=i3;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>3</p></blockquote><p>此时可以发现（i1=i2）它是有一个返回类型的，返回的类型就是他本身的类型，所以可以实现连续赋值.而我们写的Numer类就不能实现该连续赋值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Number n1(1),n2(2),n3(3);</span><br><span class="line">    n1=n2=n3;<span class="comment">//如果我们这么写，编译器会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若改为返回自身类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number <span class="keyword">operator</span>=(<span class="keyword">const</span> Number&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">num=other.num;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Number n1(1),n2(2),n3(3);</span><br><span class="line">    n1=n2=n3;</span><br><span class="line">    n1.printNumber();<span class="comment">// 运行结果值为3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现一旦改为返回自身类型就可以实现连续赋值了<br>所以返回自身类型，是为了该操作符能连续使用。</p><h3 id="返回引用，提升性能"><a href="#返回引用，提升性能" class="headerlink" title="返回引用，提升性能"></a>返回引用，提升性能</h3><p>若同时调用一下文章开头返回Number引用的重载运算符和上面写的不带引用的重载运算符，用同样的代码来测试一下有什么区别。测试代码均为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Number n1(1),n2(2);</span><br><span class="line">    n1=n2;</span><br><span class="line">    n1.printNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不带引用的运行结果：</p><blockquote><p>Count of constructed class Number: 1<br>Count of constructed class Number: 2<br>Count of constructed(Copy) class Number:3<br>Destructor has been called<br>num的值:2<br>Destructor has been called<br>Destructor has been called </p></blockquote><p>而带引用的运算结果为：</p><blockquote><p>Count of constructed class Number: 1<br>Count of constructed class Number: 2<br>num的值:2<br>Destructor has been called<br>Destructor has been called </p></blockquote><p>可以发现带引用的运行结果减少一次拷贝构造和析构。可为什么会减少呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number n1(1),n2(2);</span><br><span class="line">   n1=n2;</span><br><span class="line">   n1.printNumber();</span><br></pre></td></tr></table></figure><p>因为上面运行代码中，带引用的话，只新建了n1和n2两个对象，当n1=n2的时候，因为返回的n1的引用，所以返回还是n1这个对象。即（n1=n2）的值，还是n1，只不过n1里面的变量值变了。</p><p>而不带引用时，在赋值重载函数中，return *this 的时候，用n1拷贝构造了一个临时对象，然后因为没有左值接受这个临时变量，所以又被析构了。即（n1=n2）的值是一个临时变量，刚新建，就被析构了。所以多了一个拷贝构造函数和析构函数，因此返回引用类型会带来了一点性能的提升。</p><p>当返回值时，函数返回值时会产生一个临时变量作为函数返回值的副本，并调用复制构造函数将 *this 传给这个临时变量，并且赋值得到的是一个右值，右值是不能继续赋值的，而返回引用时，引用就是obj对象本身，赋值得到一个左值，是可以继续赋值的，其原因是这是为了支持连续的=号操作，如：A a,b,c  .调用(a=b)=c,这种情况下就要要求重载操作符=号必须返回一个 *this 的引用，这样a=b才能得到一个更新后的a,再用c对其赋值才能作用到更新的a身上，如果不返回 *this的引用，将无法完成第二次用c的那个赋值,因为返回的是对象（一个临时对象，a的一个拷贝），不是引用，所以此时 a 不在后面的‘()=c’的操作中，而是c对一个临时对象赋值，所以a的内容保持不变（等于a）。调用成员函数时*this指向该对象本身。</p><p>参考来源：<a href="https://blog.csdn.net/weixin_43515966/article/details/93746576?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">csdn</a></p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象进阶</title>
      <link href="/2020/05/10/oomaster/"/>
      <url>/2020/05/10/oomaster/</url>
      
        <content type="html"><![CDATA[<h2 id="C-拷贝构造函数（复制构造函数）"><a href="#C-拷贝构造函数（复制构造函数）" class="headerlink" title="C++拷贝构造函数（复制构造函数）"></a>C++拷贝构造函数（复制构造函数）</h2><p>拷贝和复制是一个意思，对应的英文单词都是copy。<strong>对于计算机来说，拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据</strong>。例如，将 Word 文档拷贝到U盘去复印店打印，将 D 盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。</p><p>在 C++ 中，拷贝并没有脱离它本来的含义，只是将这个含义进行了“特化”，是指用已经存在的对象创建出一个新的对象。从本质上讲，对象也是一份数据，因为它会占用内存。</p><p>严格来说，对象的创建包括两个阶段，首先要分配内存空间，然后再进行初始化：</p><ul><li>分配内存很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。</li><li>初始化就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，初始化就是调用构造函数。</li></ul><p><strong>很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存</strong>。</p><p>那么，如何用拷贝的方式来初始化一个对象呢？其实这样的例子比比皆是，string 类就是一个典型的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s3 = s1;</span><br><span class="line">    <span class="built_in">string</span> s4 = s1 + <span class="string">" "</span> + s2;</span><br><span class="line">    func(s1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a><br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a><br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a><br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a><br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a> <a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a>    </p></blockquote><p>s1、s2、s3、s4 以及 func() 的形参 str，都是使用拷贝的方式来初始化的。<br>对于 s1，表面上看起来是将一个字符串直接赋值给了 s1，实际上在内部进行了类型转换，将 const char * 类型转换为 string 类型后才赋值的,s4 也是类似的道理。</p><p>对于 s1、s2、s3、s4，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。</p><p>对于 func() 的形参 str，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用 func() 时，才会将其它对象的数据拷贝给 str 以完成初始化。</p><p>当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是<strong>拷贝构造函数（Copy Constructor）。</strong></p><p>下面的例子演示了拷贝构造函数的定义和使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>, <span class="keyword">float</span> score = <span class="number">0.0f</span>);  <span class="comment">//普通构造函数</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//拷贝构造函数（声明）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数（定义）</span></span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    Student stu2 = stu1;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    stu1.<span class="built_in">display</span>();</span><br><span class="line">    stu2.<span class="built_in">display</span>();</span><br><span class="line">    stu3.<span class="built_in">display</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Copy constructor was called.<br>Copy constructor was called.<br>小明的年龄是16，成绩是90.5<br>小明的年龄是16，成绩是90.5<br>小明的年龄是16，成绩是90.5   </p></blockquote><p>第 8 行是拷贝构造函数的声明，第 20 行是拷贝构造函数的定义。拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。</p><p><strong>1) 为什么必须是当前类的引用呢？</strong><br>如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p><p>只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。</p><p><strong>2) 为什么是 const 引用呢？</strong></p><p>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。</p><p>另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。</p><p>以上面的 Student 类为例，将 const 去掉后，拷贝构造函数的原型变为：</p><blockquote><p>Student::Student(Student &amp;stu);</p></blockquote><p>此时，下面的代码就会发生错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">Student stu2 = stu1;</span><br><span class="line"><span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;</span><br></pre></td></tr></table></figure><p>stu1 是 const 类型，在初始化 stu2、stu3 时，编译器希望调用<strong>Student::Student(const Student &amp;stu)</strong>，但是这个函数却不存在，又不能将 const Student 类型转换为 Student 类型去调用<strong>Student::Student(Student &amp;stu)</strong>，所以最终调用失败了。</p><p>当然，你也可以再添加一个参数为 const 引用的拷贝构造函数，这样就不会出错了。换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 const 引用，另一个函数的参数为非 const 引用。</p><h3 id="默认拷贝构造函数"><a href="#默认拷贝构造函数" class="headerlink" title="默认拷贝构造函数"></a>默认拷贝构造函数</h3><p>在前面的教程中，我们还没有讲解拷贝构造函数，但是却已经在使用拷贝的方式创建对象了，并且也没有引发什么错误。这是因为，如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面 Student 类的拷贝构造函数非常类似。</p><p>对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p><h2 id="C-深拷贝和浅拷贝（深复制和浅复制）"><a href="#C-深拷贝和浅拷贝（深复制和浅复制）" class="headerlink" title="C++深拷贝和浅拷贝（深复制和浅复制）"></a>C++深拷贝和浅拷贝（深复制和浅复制）</h2><p>对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(): m_a(<span class="number">0</span>), m_b(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a;  <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    Base obj2 = obj1;  <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b 和 obj2 都是以拷贝的方式初始化的，具体来说，就是将 a 和 obj1 所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，<strong>这种默认的拷贝行为就是浅拷贝</strong>，<strong>这和调用 memcpy() 函数的效果非常类似</strong>。</p><p>对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p><p>下面我们通过一个具体的例子来说明显式定义拷贝构造函数的必要性。我们知道，有些较老的编译器不支持变长数组，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    <span class="comment">//因为返回类型是int型的引用，所以说是可写入处理的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Array arr2 = arr1;</span><br><span class="line">    arr2[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">29</span>;</span><br><span class="line">   </span><br><span class="line">    printArray(arr1);</span><br><span class="line">    printArray(arr2);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">&gt;运行结果：   </span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>    </span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>  </span><br><span class="line"></span><br><span class="line">本例中我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了 arr2 的数据，就没有影响 arr1。</span><br><span class="line"></span><br><span class="line">**这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。**</span><br><span class="line"></span><br><span class="line">深拷贝的例子比比皆是，除了上面的变长数组类，标准模板库（STL）中的 <span class="built_in">string</span>、<span class="built_in">vector</span>、<span class="built_in">stack</span>、<span class="built_in">set</span>、<span class="built_in">map</span> 等也都必须使用深拷贝。</span><br><span class="line"></span><br><span class="line">果希望亲眼目睹不使用深拷贝的后果，可以将上例中的拷贝构造函数删除，那么运行结果将变为：</span><br><span class="line"></span><br><span class="line">&gt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>  </span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line">可以发现，更改 arr2 的数据也影响到了 arr1。这是因为，在创建 arr2 对象时，默认拷贝构造函数将 arr1.m_p 直接赋值给了 arr2.m_p，**导致 arr2.m_p 和 arr1.m_p 指向了同一块内存，所以会相互影响。**</span><br><span class="line"></span><br><span class="line">另外需要注意的是，printArray() 函数的形参为引用类型，这样做能够避免在传参时调用拷贝构造函数；又因为 printArray() 函数不会修改任何数组元素，所以我们添加了 <span class="keyword">const</span> 限制，以使得语义更加明确。</span><br><span class="line"></span><br><span class="line">### 到底是浅拷贝还是深拷贝</span><br><span class="line">如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。</span><br><span class="line"></span><br><span class="line">另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等，请看下面的例子：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  //在Linux和Mac下要换成 unistd.h 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>);</span><br><span class="line">    Base(<span class="keyword">const</span> Base &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">time_t</span> <span class="title">getTime</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_time; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">    <span class="keyword">time_t</span> m_time;  <span class="comment">//对象创建时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_count;  <span class="comment">//创建过的对象的数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123;</span><br><span class="line">    m_count++;</span><br><span class="line">    m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">const</span> Base &amp;obj)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_a = obj.m_a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_b = obj.m_b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_count++;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj1: count = "</span>&lt;&lt;obj1.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj1.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    Sleep(<span class="number">3000</span>);  <span class="comment">//在Linux和Mac下要写作 sleep(3);</span></span><br><span class="line">   </span><br><span class="line">    Base obj2 = obj1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj2: count = "</span>&lt;&lt;obj2.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj2.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>obj1: count = 1, time = 1488344372<br>obj2: count = 2, time = 1488344375    </p></blockquote><p>运行程序，先输出第一行结果，等待 3 秒后再输出第二行结果。Base 类中的 m_time 和 m_count 分别记录了对象的创建时间和创建数目，它们在不同的对象中有不同的值，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。</p><h2 id="C-重载-（赋值运算符）"><a href="#C-重载-（赋值运算符）" class="headerlink" title="C++重载=（赋值运算符）"></a>C++重载=（赋值运算符）</h2><p>初始化和赋值的区别：<br>在定义的同时进行赋值叫做<strong>初始化</strong>（Initialization），定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做<strong>赋值</strong>（Assignment）。<strong>初始化只能有一次，赋值可以有多次。</strong></p><p>当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符。</p><p><strong>即使我们没有显式的重载赋值运算符，编译器也会以默认地方式重载它。默认重载的赋值运算符功能很简单，就是将原有对象的所有成员变量一一赋值给新对象，这和默认拷贝构造函数的功能类似。</strong></p><p>对于简单的类，默认的赋值运算符一般就够用了，我们也没有必要再显式地重载它。但是当类持有其它资源时，例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就不能处理了，我们必须显式地重载它，这样才能将原有对象的所有数据都赋值给新对象。</p><p>仍然以 Array 类为例，该类拥有一个指针成员，指向动态分配的内存。为了让 Array 类的对象之间能够正确地赋值，我们必须重载赋值运算符。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    Array &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line">Array &amp;Array::<span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span> != &amp;arr)&#123;  <span class="comment">//判断是否是给自己赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_p);  <span class="comment">//释放原来的内存</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">        <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(arr1);</span><br><span class="line">   </span><br><span class="line">    <span class="function">Array <span class="title">arr2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        arr2[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(arr2);</span><br><span class="line">    arr2 = arr1;  <span class="comment">//调用operator=()</span></span><br><span class="line">    printArray(arr2);</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">234</span>;  <span class="comment">//修改arr1的数据不会影响arr2</span></span><br><span class="line">    arr2[<span class="number">7</span>] = <span class="number">920</span>;</span><br><span class="line">    printArray(arr1);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br>0, 1, 2, 3, 4<br>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br>0, 1, 2, 3, 4, 5, 6, 7, 8, 9   </p></blockquote><p>将 arr1 赋值给 arr2 后，修改 arr2 的数据不会影响 arr1。如果把 operator=() 注释掉，那么运行结果将变为：</p><blockquote><p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br>0, 1, 2, 3, 4<br>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br>0, 1, 2, 234, 4, 5, 6, 920, 8, 9  </p></blockquote><blockquote><p>去掉operator=()后，由于 m_p 指向的堆内存会被 free() 两次，(析构函数)所以还会导致内存错误。</p></blockquote><p>1) operator=() 的返回值类型为Array &amp;，这样不但能够避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的。下面的语句就是连续赋值：</p><blockquote><p>arr4 = arr3 = arr2 = arr1;</p></blockquote><p>2) if( this != &amp;arr)语句的作用是「判断是否是给同一个对象赋值」：如果是，那就什么也不做；如果不是，那就将原有对象的所有成员变量一一赋值给新对象，并为新对象重新分配内存。下面的语句就是给同一个对象赋值：</p><blockquote><p>arr1 = arr1;<br>arr2 = arr2;</p></blockquote><p>3) return <em>this表示返回当前对象（新对象），而且是一个*</em>临时对象**。</p><p>4) operator=() 的形参类型为const Array &amp;，这样不但能够避免在传参时调用拷贝构造函数，还能够同时接收 const 类型和非 const 类型的实参。</p><p>5) 赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是其它参数必须给出默认值，例如：</p><blockquote><p>Array &amp; operator=(const Array &amp;arr, int a = 100); </p></blockquote><h2 id="C-转换构造函数：将其它类型转换为当前类的类型"><a href="#C-转换构造函数：将其它类型转换为当前类的类型" class="headerlink" title="C++转换构造函数：将其它类型转换为当前类的类型"></a>C++转换构造函数：将其它类型转换为当前类的类型</h2><p>在 C/C++ 中，不同的数据类型之间可以相互转换。无需用户指明如何转换的称为自动类型转换（隐式类型转换），需要用户显式地指明如何转换的称为强制类型转换。</p><p>自动类型转换示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">a = <span class="number">7.5</span> + a;</span><br></pre></td></tr></table></figure><p>编译器对 7.5 是作为 double 类型处理的，在求解表达式时，先将 a 转换为 double 类型，然后与 7.5 相加，得到和为 13.5。在向整型变量 a 赋值时，将 13.5 转换为整数 13，然后赋给 a。整个过程中，我们并没有告诉编译器如何去做，编译器使用内置的规则完成数据类型的转换。</p><p>强制类型转换示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;n;</span><br><span class="line"><span class="keyword">float</span> *p2 = (<span class="keyword">float</span>*)p1;</span><br></pre></td></tr></table></figure><p>p1 是int *类型，它指向的内存里面保存的是整数，p2 是float *类型，将 p1 赋值给 p2 后，p2 也指向了这块内存，并把这块内存中的数据作为小数处理。我们知道，整数和小数的存储格式大相径庭，将整数作为小数处理非常荒诞，可能会引发莫名其妙的错误，所以编译器默认不允许将 p1 赋值给 p2。但是，使用强制类型转换后，编译器就认为我们知道这种风险的存在，并进行了适当的权衡，所以最终还是允许了这种行为。</p><p>不管是自动类型转换还是强制类型转换，前提必须是编译器知道如何转换，例如，将小数转换为整数会抹掉小数点后面的数字，将int *转换为float *只是简单地复制指针的值，这些规则都是编译器内置的，我们并没有告诉编译器。</p><p>但如果编译器不知道转换规则就不能转换，使用强制类型也无用，如下例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    a = (Complex)<span class="number">25.5</span>;  <span class="comment">//错误，转换失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>25.5 是实数，a 是复数，将 25.5 赋值给 a 后，我们期望 a 的实部变为 25.5，而虚部为 0。但是，编译器并不知道这个转换规则，这超出了编译器的处理能力，所以转换失败，即使加上强制类型转换也无用。</p><p>不过 C++ 允许我们自定义类型转换规则，用户可以将其它类型转换为当前类类型，也可以将当前类类型转换为其它类型。这种自定义的类型转换规则只能以类的成员函数的形式出现，换句话说，这种转换规则只适用于类。</p><h3 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h3><p><strong>将其它类型转换为当前类类型需要借助转换构造函数</strong>（Conversion constructor）。转换构造函数也是一种构造函数，它遵循构造函数的一般规则。<strong>转换构造函数只有一个参数</strong>。</p><p>仍然以 Complex 类为例，我们为它添加转换构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real): m_real(real), m_imag(<span class="number">0.0</span>)&#123; &#125;  <span class="comment">//转换构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    a = <span class="number">25.5</span>;  <span class="comment">//调用转换构造函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>10 + 20i<br>25.5 + 0i</p></blockquote><p>Complex(double real); 就是转换构造函数，它的作用是将 double 类型的参数 real 转换成 Complex 类的对象，并将 real 作为复数的实部，将 0 作为复数的虚部。这样一来，a = 25.5; 整体上的效果相当于：</p><blockquote><p>a.Complex(25.5);</p></blockquote><p>将赋值的过程转换成了函数调用的过程。</p><p>在进行数学运算、赋值、拷贝等操作时，如果遇到类型不兼容、需要将 double 类型转换为 Complex 类型时，编译器会检索当前的类是否定义了转换构造函数，如果没有定义的话就转换失败，如果定义了的话就调用转换构造函数。</p><p>转换构造函数也是构造函数的一种，它除了可以用来将其它类型转换为当前类类型，还可以用来初始化对象，这是构造函数本来的意义。下面创建对象的方式是正确的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">26.4</span>)</span></span>;  <span class="comment">//创建具名对象</span></span><br><span class="line">Complex c2 = <span class="number">240.3</span>;  <span class="comment">//以拷贝的方式初始化对象</span></span><br><span class="line">Complex(<span class="number">15.9</span>);  <span class="comment">//创建匿名对象</span></span><br><span class="line">c1 = Complex(<span class="number">46.9</span>);  <span class="comment">//创建一个匿名对象并将它赋值给 c1</span></span><br></pre></td></tr></table></figure><p><strong>在以拷贝的方式初始化对象时，编译器先调用转换构造函数，将 240.3 转换为 Complex 类型（创建一个 Complex 类的匿名对象），然后再拷贝给 c2。</strong></p><p>如果已经对+运算符进行了重载，使之能进行两个 Complex 类对象的相加，那么下面的语句也是正确的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">15.6</span>, <span class="number">89.9</span>)</span></span>;</span><br><span class="line">Complex c2;</span><br><span class="line">c2 = c1 + <span class="number">29.6</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>在进行加法运算符时，编译器先将 29.6 转换为 Complex 类型（创建一个 Complex 类的匿名对象）再相加。</p><p>需要注意的是，<strong>为了获得目标类型，编译器会“不择手段”，会综合使用内置的转换规则和用户自定义的转换规则，并且会进行多级类型转换</strong>，例如：</p><ul><li>编译器会根据内置规则先将 int 转换为 double，再根据用户自定义规则将 double 转换为 Complex（int –&gt; double –&gt; Complex）；</li><li>编译器会根据内置规则先将 char 转换为 int，再将 int 转换为 double，最后根据用户自定义规则将 double 转换为 Complex（char –&gt; int –&gt; double –&gt; Complex）。</li></ul><p>从本例看，只要一个类型能转换为 double 类型，就能转换为 Complex 类型。请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Complex c1 = <span class="number">100</span>;  <span class="comment">//int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c1 = <span class="string">'A'</span>;  <span class="comment">//char --&gt; int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c1 = <span class="literal">true</span>;  <span class="comment">//bool --&gt; int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">25.8</span>, <span class="number">0.7</span>)</span></span>;</span><br><span class="line">    <span class="comment">//假设已经重载了+运算符</span></span><br><span class="line">    c1 = c2 + <span class="string">'H'</span> + <span class="literal">true</span> + <span class="number">15</span>;  <span class="comment">//将char、bool、int都转换为Complex类型再运算</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>100 + 0i<br>65 + 0i<br>1 + 0i<br>113.8 + 0.7i</p></blockquote><h3 id="构造函数-综合"><a href="#构造函数-综合" class="headerlink" title="构造函数 综合"></a>构造函数 综合</h3><p>构造函数的本意是在创建对象的时候初始化对象，编译器会根据传递的实参来匹配不同的（重载的）构造函数。回顾一下以前的章节，到目前为止我们已经学习了以下几种构造函数。</p><p>1) 默认构造函数。就是编译器自动生成的构造函数。以 Complex 类为例，它的原型为：</p><blockquote><p>Complex();  //没有参数</p></blockquote><p>2) 普通构造函数。就是用户自定义的构造函数。以 Complex 类为例，它的原型为：</p><blockquote><p>Complex(double real, double imag);  //两个参数</p></blockquote><p>3) 拷贝构造函数。在以拷贝的方式初始化对象时调用。以 Complex 类为例，它的原型为：</p><blockquote><p>Complex(const Complex &amp;c);</p></blockquote><p>4) 转换构造函数。将其它类型转换为当前类类型时调用。以 Complex 为例，它的原型为：</p><blockquote><p>Complex(double real);</p></blockquote><p>不管哪一种构造函数，都能够用来初始化对象，这是构造函数的本意。假设 Complex 类定义了以上所有的构造函数，那么下面创建对象的方式都是正确的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">()</span></span>;  <span class="comment">//调用Complex()</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">//调用Complex(double real, double imag)</span></span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(c2)</span></span>;  <span class="comment">//调用Complex(const Complex &amp;c)</span></span><br><span class="line"><span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">25.7</span>)</span></span>;  <span class="comment">//调用Complex(double real)</span></span><br></pre></td></tr></table></figure><p>这些代码都体现了构造函数的本意——在创建对象时初始化对象。</p><p>除了在创建对象时初始化对象，其他情况下也会调用构造函数，例如，以拷贝的的方式初始化对象时会调用拷贝构造函数，将其它类型转换为当前类类型时会调用转换构造函数。这些在其他情况下调用的构造函数，就成了特殊的构造函数了。特殊的构造函数并不一定能体现出构造函数的本意。</p><h3 id="对-Complex-类的进一步精简"><a href="#对-Complex-类的进一步精简" class="headerlink" title="对 Complex 类的进一步精简"></a>对 Complex 类的进一步精简</h3><p>上面的 Complex 类中我们定义了三个构造函数，其中包括两个普通的构造函数和一个转换构造函数。其实，借助<strong>函数的默认参数</strong>，我们可以将这三个构造函数简化为一个，请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;  <span class="comment">//向构造函数传递 2 个实参，不使用默认参数</span></span><br><span class="line">    <span class="function">Complex <span class="title">b</span><span class="params">(<span class="number">89.5</span>)</span></span>;  <span class="comment">//向构造函数传递 1 个实参，使用 1 个默认参数</span></span><br><span class="line">    Complex c;  <span class="comment">//不向构造函数传递实参，使用全部默认参数</span></span><br><span class="line">    a = <span class="number">25.5</span>;  <span class="comment">//调用转换构造函数（向构造函数传递 1 个实参，使用 1 个默认参数）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精简后的构造函数包含了两个默认参数，在调用它时可以省略部分或者全部实参，也就是可以向它传递 0 个、1 个、2 个实参。转换构造函数就是包含了一个参数的构造函数，恰好能够和其他两个普通的构造函数“融合”在一起。</p><h2 id="C-类型转换函数：将当前类的类型转换为其它类型"><a href="#C-类型转换函数：将当前类的类型转换为其它类型" class="headerlink" title="C++类型转换函数：将当前类的类型转换为其它类型"></a>C++类型转换函数：将当前类的类型转换为其它类型</h2><p>C++ 提供了类型转换函数（Type conversion function）来将当前类类型转换为其它类型（例如将 Complex 类型转换为 double 类型）。类型转换函数的作用就是将当前类类型转换为其它类型，它只能以成员函数的形式出现，也就是只能出现在类中。</p><p>类型转换函数的语法格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>operator 是 C++ 关键字，type 是要转换的目标类型，data 是要返回的 type 类型的数据。</p><p>因为要转换的目标类型是 type，所以返回值 data 也必须是 type 类型。既然已经知道了要返回 type 类型的数据，所以没有必要再像普通函数一样明确地给出返回值类型。这样做导致的结果是：类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。</p><p>类型转换函数也没有参数，因为要将当前类的对象转换为其它类型，所以参数不言而喻。实际上编译器会把当前对象的地址赋值给 this 指针，这样在函数体内就可以操作当前对象了。</p><p>【示例】为 Complex 类添加类型转换函数，使得 Complex 类型能够转换为 double 类型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> f = c1;  <span class="comment">//相当于 double f = Complex::operator double(&amp;c1);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"f = "</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    f = <span class="number">12.5</span> + c1 + <span class="number">6</span>;  <span class="comment">//相当于 f = 12.5 + Complex::operator double(&amp;c1) + 6;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"f = "</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = Complex(<span class="number">43.2</span>, <span class="number">9.3</span>);  <span class="comment">//先转换为 double，再转换为 int</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"n = "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>f = 24.6<br>f = 43.1<br>n = 43</p></blockquote><h3 id="关于类型转换函数的说明"><a href="#关于类型转换函数的说明" class="headerlink" title="关于类型转换函数的说明"></a>关于类型转换函数的说明</h3><p>1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。</p><p>2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。</p><p>3) 类型转换函数可以被继承，可以是虚函数。</p><p>4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。以 Complex 类为例，假设它有两个类型转换函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//转换为double类型</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">int</span>)m_real; &#125;  <span class="comment">//转换为int类型</span></span><br></pre></td></tr></table></figure><p>那么下面的写法就会引发二义性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">12.5</span> + c1;</span><br></pre></td></tr></table></figure><p>编译器可以调用 operator double() 将 c1 转换为 double 类型，也可以调用 operator int() 将 c1 转换为 int 类型，这两种类型都可以跟 12.5 进行加法运算，并且从 Complex 转换为 double 与从 Complex 转化为 int 是平级的，没有谁的优先级更高，所以这个时候编译器就不知道该调用哪个函数了，干脆抛出一个二义性错误，让用户解决。</p><h2 id="拷贝控制操作（三-五法则）"><a href="#拷贝控制操作（三-五法则）" class="headerlink" title="拷贝控制操作（三/五法则）"></a>拷贝控制操作（三/五法则）</h2><p>当定义一个类时，我们显式地或隐式地指定了此类型的对象在<strong>拷贝</strong>、<strong>赋值</strong>和<strong>销毁</strong>时做什么；<br>一个类通过定义三种特殊的成员函数来控制这些操作，分别是<strong>拷贝构造函数</strong>、<strong>赋值运算符</strong>和<strong>析构函数</strong>；</p><ul><li>拷贝构造函数定义了当用同类型的另一个对象初始化新对象时做什么；</li><li>赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么；</li><li>析构函数定义了此类型的对象销毁时做什么；</li></ul><p>我们将这些操作称为<strong>拷贝控制操作</strong>；</p><p>由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“<strong>C++三法则</strong>”；<br>在较新的 C++11 标准中，为了支持移动语义，又增加了<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，这样共有五个特殊的成员函数，所以又称为“<strong>C++五法则</strong>”；</p><p>也就是说，“三法则”是针对较旧的 C++89 标准说的，“五法则”是针对较新的 C++11 标准说的；为了统一称呼，后来人们干把它叫做“<strong>C++ 三/五法则</strong>”；</p><p>如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义默认的操作，因此很多类会忽略这些拷贝控制操作；<br>但是，对于一些持有其他资源（例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等）的类来说，依赖这些默认的操作会导致灾难，我们必须显式的定义这些操作；</p><p>C++ 并不要求我们定义所有的这些操作，你可以只定义其中的一个或两个；<br>但是，这些操作通常应该被看做一个整体，只需要定义其中一个操作，而不需要定义其他操作的情况很少见；</p><p><strong>需要析构函数的类也需要拷贝和赋值操作</strong><br>当我们决定是否要为一个类显式地定义拷贝构造函数和赋值运算符时，一个基本原则是首先确定这个类是否需要一个析构函数；<br>通常，对析构函数的需求要比拷贝构造函数和赋值运算符的需求更加明显；</p><p>如果一个类需要定义析构函数，那么几乎可以肯定这个类也需要一个拷贝构造函数和一个赋值运算符；</p><p><strong>需要拷贝操作的类也需要赋值操作，反之亦然</strong><br>虽然很多类需要定义所有（或是不需要定义任何）拷贝控制成员，但某些类所要完成的工作，只需要拷贝或者赋值操作，不需要析构操作；</p><p>如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个赋值运算符；反之亦然；<br>然而，无论需要拷贝构造函数还是需要复制运算符，都不必然意味着也需要析构函数；</p><h2 id="转换构造函数和类型转换函数"><a href="#转换构造函数和类型转换函数" class="headerlink" title="转换构造函数和类型转换函数"></a>转换构造函数和类型转换函数</h2><p><strong>转换构造函数</strong>和<strong>类型转换函数</strong>的作用是相反的：转换构造函数会将其它类型转换为当前类类型，类型转换函数会将当前类类型转换为其它类型；</p><p>如果没有这两个函数，Complex 类和 int、double、bool 等基本类型的四则运算、逻辑运算都将变得非常复杂，要编写大量的运算符重载函数；</p><p>但是，如果一个类同时存在这两个函数，就有可能产生二义性:例如在处理 c1 + 2.5 时会出现二义性。一种理解是：调用转换构造函数，把 2.5 变成 Complex类对象，然后调用运算符 “+” 重载函数，与 c1 进行复数相加。而另外一种理解就是：调用类型转换函数，把 c1 转换成 double 型数，然后与 2.55 进行相加。导致系统无法判断，这二者是矛盾的。如果想要使用类型转换函数，就应当山区运算符  “+” 重载函数。</p><p>解决二义性问题的办法也很简单粗暴，<strong>要么只使用转换构造函数，要么只使用类型转换函数；</strong></p><p>实践证明，<strong>用户对转换构造函数的需求往往更加强烈，这样能增加编码的灵活性；</strong></p><p>例如，可以将一个字符串字面量或者一个字符数组直接赋值给 string 类的对象，可以将一个 int、double、bool 等基本类型的数据直接赋值给 Complex 类的对象；</p><p>那么，如果我们想把当前类类型转换为其它类型怎么办呢？<br>很简单，增加一个普通的成员函数即可，例如，string 类使用 c_str() 函数转换为 C 风格的字符串，complex 类使用 real() 和 imag() 函数来获取复数的实部和虚部；</p><h2 id="类型转换的本质"><a href="#类型转换的本质" class="headerlink" title="类型转换的本质"></a>类型转换的本质</h2><p>在 C/C++ 中，不同的数据类型之间可以相互转换：<br>无需用户指明如何转换的称为<strong>自动类型转换（隐式类型转换）</strong>，需要用户显式地指明如何转换的称为<strong>强制类型转换（显式类型转换）</strong>；</p><p>隐式类型转换利用的是<strong>编译器内置的转换规则</strong>，或者<strong>用户自定义的转换构造函数以及类型转换函数</strong>（这些都可以认为是已知的转换规则）；</p><p>type *是一个具体类型的指针，例如int *、double *、Student *等，它们都可以直接赋值给void *指针；<br>而反过来是不行的，必须使用强制类型转换才能将void *转换为type *；</p><p>例如，malloc() 分配内存后返回的就是一个void *指针，我们必须进行强制类型转换后才能赋值给指针变量；</p><p>当隐式转换不能完成类型转换工作时，我们就必须使用<strong>强制类型转换</strong>了；</p><p>强制类型转换的语法也很简单，只需要在表达式的前面增加新类型的名称，格式为：<strong>(new_type)expression</strong></p><h3 id="类型转换的本质-1"><a href="#类型转换的本质-1" class="headerlink" title="类型转换的本质"></a>类型转换的本质</h3><p>我们知道，数据是放在内存中的，变量（以及指针、引用）是给这块内存起的名字，有了变量就可以找到并使用这份数据；</p><p>但问题是，该如何使用呢？</p><p>诸如数字、文字、符号、图形、音频、视频等数据都是以二进制形式存储在内存中的，它们并没有本质上的区别，那么，00010000 该理解为数字 16 呢，还是图像中某个像素的颜色呢，还是要发出某个声音呢？如果没有特别指明，我们并不知道；</p><p>也就是说，内存中的数据有多种解释方式，使用之前必须要确定；<br>这种「确定数据的解释方式」的工作就是由 <strong>数据类型（Data Type）</strong> 来完成的；<br>例如 <strong>int a;</strong> 表明，a 这份数据是整数，不能理解为像素、声音、视频等；</p><p>顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义；<br>C/C++ 支持多种数据类型，包括内置类型（例如 int、double、bool 等）和自定义类型（结构体类型和类类型）；</p><p>所谓数据类型转换，就是对数据所占用的二进制位做出重新解释；如果有必要，在重新解释的同时还会修改数据，改变它的二进制位；</p><p>对于<strong>隐式类型转换</strong>，编译器可以根据<strong>已知的转换规则</strong>来决定是否需要修改数据的二进制位；而对于<strong>强制类型转换</strong>，由于没有对应的转换规则，所以能做的事情仅仅是<strong>重新解释数据的二进制位</strong>，但无法对数据的二进制位做出修正；这就是隐式类型转换和强制类型转换最根本的区别；</p><p>这里说的修改数据并不是修改原有的数据，而是修改它的副本（先将原有数据拷贝到另外一个地方再修改）；</p><p>修改数据的二进制位非常重要，它能把转换后的数据调整到正确的值，所以这种修改时常会发生，例如：</p><p>1) 整数和浮点数在内存中的存储形式大相径庭，将浮点数 f 赋值给整数 i 时，不能原样拷贝 f 的二进制位，也不能截取部分二进制位，必须先将 f 的二进制位读取出来，以浮点数的形式呈现，然后直接截掉小数部分，把剩下的整数部分再转换成二进制形式，拷贝到 i 所在的内存中；</p><p>2) short 一般占用两个字节，int 一般占用四个字节，将 short 类型的 s 赋值给 int 类型的 i 时，如果仅仅是将 s 的二进制位拷贝给 i，那么 i 最后的两个字节会原样保留，这样会导致赋值结束后 i 的值并不等于 s 的值，所以这样做是错误的；<br>正确的做法是，先给 s 添加 16 个二进制位（两个字节）并全部置为 0，然后再拷贝给 i 所在的内存；</p><p>3) 当存在多重继承时，如果把派生类指针 pd 赋值给基类指针 pb，就必须考虑基类子对象在派生类对象中的偏移，偏移不为 0 时就要调整 pd 的值，让它加上或减去偏移量，这样赋值后才能让 pb 恰好指向基类子对象；</p><p>4) Complex 类型占用 16 个字节，double 类型占用 8 个字节，将 double 类型的数据赋值给 Complex 类型的变量（对象）时，必须调用转换构造函数，否则剩下的 8 个字节就不知道如何填充了；</p><p>以上这些都是隐式类型转换，它对数据的调整都是有益的，能够让程序更加安全稳健地运行；</p><p>隐式类型转换必须使用已知的转换规则，虽然灵活性受到了限制，但是由于能够对数据进行恰当地调整，所以更加安全（几乎没有风险）；<br>强制类型转换能够在更大范围的数据类型之间进行转换，例如不同类型指针（引用）之间的转换、从 const 到非 const 的转换、从 int 到指针的转换等；这虽然增加了灵活性，但是由于不能恰当地调整数据，所以也充满了风险，程序员要小心使用；</p><h3 id="为什么会有隐式类型转换和强制类型转换之分？"><a href="#为什么会有隐式类型转换和强制类型转换之分？" class="headerlink" title="为什么会有隐式类型转换和强制类型转换之分？"></a>为什么会有隐式类型转换和强制类型转换之分？</h3><p>隐式类型转换和显式类型转换最根本的区别是：隐式类型转换除了会重新解释数据的二进制位，还会利用已知的转换规则对数据进行恰当地调整；而显式类型转换只能简单粗暴地重新解释二进制位，不能对数据进行任何调整；</p><p>其实，能不能对数据进行调整是显而易见地事情，有转换规则就可以调整，没有转换规则就不能调整，当进行数据类型转换时，编译器明摆着是知道有没有转换规则的；<br>站在这个角度考虑，强制类型转换的语法就是多此一举，编译器完全可以自行判断是否需要调整数据；<br>例如从int *转换到float *，加不加强制类型转换的语法都不能对数据进行调整；</p><p>C/C++ 之所以增加强制类型转换的语法，是为了提醒程序员这样做存在风险，一定要谨慎小心；说得通俗一点，你现在的类型转换存在风险，你自己一定要知道；</p><h3 id="强制类型转换也不是万能的"><a href="#强制类型转换也不是万能的" class="headerlink" title="强制类型转换也不是万能的"></a>强制类型转换也不是万能的</h3><p>类型转换只能发生在相关类型或者相近类型之间，两个毫不相干的类型不能相互转换，即使使用强制类型转换也不行；<br>例如，两个没有继承关系的类不能相互转换，基类不能向派生类转换（向下转型），类类型不能向基本类型转换，指针和类类型之间不能相互转换；</p><h2 id="四种类型转换运算符"><a href="#四种类型转换运算符" class="headerlink" title="四种类型转换运算符"></a>四种类型转换运算符</h2><p>隐式类型转换是安全的，显式类型转换是有风险的，C语言之所以增加强制类型转换的语法，就是为了强调风险，让程序员意识到自己在做什么；</p><p>但是，这种强调风险的方式还是比较粗放，粒度比较大，它并没有表明存在什么风险，风险程度如何；</p><p>为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：</p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>static_cast</td><td>用于良性转换，一般不会导致意外发生，风险很低；</td></tr><tr><td>const_cast</td><td>用于 const 与非 const、volatile 与非 volatile 之间的转换；</td></tr><tr><td>reinterpret_cast</td><td>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换；</td></tr><tr><td>dynamic_cast</td><td>借助 RTTI，用于类型安全的向下转型（Downcasting）；</td></tr></tbody></table><p>这四个关键字的语法格式都是一样的，具体为：xxx_cast&lt;newType&gt;(data)<br>newType是要转换成的新类型，data是被转换的数据；</p><p>比如：score为 double 类型的数据，将其转换为 int：int n = static_cast&lt;int&gt;(score);</p><p><strong>static_cast 关键字</strong><br>static_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外；</p><p>例如原有的自动类型转换，short 转 int、int 转 double、const 转非 const、向上转型等；<br>void 指针和具体类型指针之间的转换，例如void *转int *、char *转void *等；<br>有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）；</p><p>需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：<br>两个具体类型指针之间的转换，例如int *转double *、Student *转int *等；<br>int 和指针之间的转换，将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件；</p><p>static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰；换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型；</p><p>static_cast 是“静态转换”的意思，也就是在<strong>编译期间转换</strong>，转换失败的话会抛出一个编译错误；</p><p><strong>const_cast 关键字</strong><br>const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰；<br>换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型；</p><p><strong>reinterpret_cast 关键字</strong><br>reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高；</p><p>reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换；</p><p><strong>dynamic_cast 关键字</strong><br>dynamic_cast 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）；</p><p>向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功；</p><p>dynamic_cast 与 static_cast 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思；<br>dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就<strong>要求基类必须包含虚函数；</strong><br>static_cast 在编译期间完成类型转换，能够更加及时地发现错误；</p><p>dynamic_cast 的语法格式为：dynamic_cast&lt;newType&gt;(expression)<br>newType和expression必须同时是<strong>指针类型</strong>或者<strong>引用类型</strong>；<br>换句话说，dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行；</p><p>对于指针，如果转换失败将返回 NULL；对于引用，如果转换失败将抛出std::bad_cast异常；</p><p>1) <strong>向上转型（Upcasting）</strong><br>向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数（这些信息在编译期间就能确定），就一定能转换成功；<br>因为向上转型始终是安全的，所以 dynamic_cast 不会进行任何运行期间的检查，这个时候的 dynamic_cast 和 static_cast 就没有什么区别了；</p><p>2) <strong>向下转型（Downcasting）</strong><br>向下转型是有风险的，dynamic_cast 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败；<br>那么，哪些向下转型是安全的呢，哪些又是不安全的呢？下面我们通过一个例子来演示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"class A\n"</span>); &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"class B\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"class C\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"class D\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *pa = <span class="literal">nullptr</span>;</span><br><span class="line">    B *pb = <span class="literal">nullptr</span>;</span><br><span class="line">    C *pc = <span class="literal">nullptr</span>;</span><br><span class="line">    D *pd = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    pa = <span class="keyword">new</span> A;</span><br><span class="line">    pb = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pa); <span class="comment">// 向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span> (pb == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting failed: A * to B *\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting successfully: A * to B *\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span>&lt;D *&gt;(pa); <span class="comment">// 向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting failed: A * to D *\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting successfully: A * to D *\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    pa = <span class="keyword">new</span> C;</span><br><span class="line">    pb = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pa); <span class="comment">// 向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span> (pb == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting failed: A * to B *\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting successfully: A * to B *\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span>&lt;D *&gt;(pa); <span class="comment">// 向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting failed: A * to D *\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting successfully: A * to D *\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ./a.out</span><br><span class="line">Downcasting failed: A * to B *</span><br><span class="line">Downcasting failed: A * to D *</span><br><span class="line">----------------------------------</span><br><span class="line">Downcasting successfully: A * to B *</span><br><span class="line">Downcasting failed: A * to D *</span><br></pre></td></tr></table></figure><p>当使用 dynamic_cast 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到当前类（指针指向的对象所属的类）的类型信息；<br>并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功；<br>如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换；</p><p>表面上看起来 dynamic_cast 确实能够向下转型，本例也很好地证明了这一点；<br>但是从本质上讲，dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链；</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常（二）</title>
      <link href="/2020/05/09/try0509/"/>
      <url>/2020/05/09/try0509/</url>
      
        <content type="html"><![CDATA[<h2 id="C-异常类型以及多级catch匹配"><a href="#C-异常类型以及多级catch匹配" class="headerlink" title="C++异常类型以及多级catch匹配"></a>C++异常类型以及多级catch匹配</h2><p>上面讲到的 try-catch 的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(exceptionType variable)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exceptionType 是异常类型，它指明了当前的 catch 可以处理什么类型的异常；variable是一个变量，用来接收异常信息。当程序抛出异常时，会创建一份数据，这份数据包含了错误信息，程序员可以根据这些信息来判断到底出了什么问题，接下来怎么处理。</p><p>异常既然是一份数据，那么就应该有数据类型。C++ 规定，异常类型可以是 int、char、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。C++ 语言本身以及标准库中的函数抛出的异常，都是 exception 类或其子类的异常。也就是说，抛出异常时，会创建一个 exception 类或其子类的对象。</p><p>exceptionType variable 和函数的形参非常类似，当异常发生后，会将异常数据传递给 variable 这个变量，这和函数传参的过程类似。当然，只有跟 exceptionType 类型匹配的异常数据才会被传递给 variable，否则 catch 不会接收这份异常数据，也不会执行 catch 块中的语句。换句话说，catch 不会处理当前的异常。</p><p><strong>我们可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参（异常数据）</strong>。</p><p>但是 catch 和真正的函数调用又有区别：</p><ul><li>真正的函数调用，形参和实参的类型必须要匹配，或者可以自动转换，否则在编译阶段就报错了。</li><li>而对于 catch，异常是在运行阶段产生的，它可以是任何类型，没法提前预测，所以不能在编译阶段判断类型是否正确，只能等到程序运行后，真的抛出异常了，再将异常类型和 catch 能处理的类型进行匹配，匹配成功的话就“调用”当前的 catch，否则就忽略当前的 catch。</li></ul><p><strong>总起来说，catch 和真正的函数调用相比，多了一个「在运行阶段将实参和形参匹配」的过程。</strong></p><p>另外需要注意的是，如果不希望 catch 处理异常数据，也可以将 variable 省略掉，也即写作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(exceptionType)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只会将异常类型和 catch 所能处理的类型进行匹配，不会传递异常数据了。</p><h3 id="多级catch"><a href="#多级catch" class="headerlink" title="多级catch"></a>多级catch</h3><p>一个 try 后面可以跟多个 catch：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (exception_type_1 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (exception_type_2 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他的catch</span></span><br><span class="line"><span class="keyword">catch</span> (exception_type_n e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当异常发生时，程序会按照从上到下的顺序，将异常类型和 catch 所能接收的类型逐个匹配。一旦找到类型匹配的 catch 就停止检索，并将异常交给当前的 catch 处理（其他的 catch 不会被执行）。如果最终也没有找到匹配的 catch，就只能交给系统处理，终止程序的运行。</p><p>多级 catch 的使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> Derived();  <span class="comment">//抛出自己的异常类型，实际上是创建一个Derived类型的匿名对象</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">int</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: int"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">char</span> *)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: cahr *"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Base)&#123;  <span class="comment">//匹配成功（向上转型）</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: Base"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Derived)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: Derived"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Exception type: Base</p></blockquote><p>在 catch 中，我们只给出了异常类型，没有给出接收异常信息的变量。<br>本例中，我们定义了一个基类 Base，又从 Base 派生类出了 Derived。抛出异常时，我们创建了一个 Derived 类的匿名对象，也就是说，异常的类型是 Derived。</p><p>我们期望的是，异常被catch(Derived)捕获，但是从输出结果可以看出，异常提前被catch(Base)捕获了，这说明 <strong>catch 在匹配异常类型时发生了向上转型（Upcasting）。</strong></p><h3 id="catch-在匹配过程中的类型转换"><a href="#catch-在匹配过程中的类型转换" class="headerlink" title="catch 在匹配过程中的类型转换"></a>catch 在匹配过程中的类型转换</h3><p>C/C++ 中存在多种多样的类型转换，以普通函数（非模板函数）为例，发生函数调用时，如果实参和形参的类型不是严格匹配，那么会将实参的类型进行适当的转换，以适应形参的类型，这些转换包括：</p><ul><li>算数转换：例如 int 转换为 float，char 转换为 int，double 转换为 int 等。</li><li>向上转型：也就是派生类向基类的转换。</li><li>const 转换：也即将非 const 类型转换为 const 类型，例如将 char * 转换为 const char *。</li><li>数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。<br>用户自定的类型转换。</li></ul><p>catch 在匹配异常类型的过程中，也会进行类型转换，但是这种转换受到了更多的限制，仅能进行「向上转型」、「const 转换」和「数组或函数指针转换」，其他的都不能应用于 catch。</p><p>向上转型在上面的例子中已经发生了，下面的例子演示了 const 转换以及数组和指针的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> nums;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">int</span> *)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: const int *"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Exception type: const int *</p></blockquote><p>nums 本来的类型是int [3]，但是 catch 中没有严格匹配的类型，所以先转换为int *，再转换为const int *。</p><p><strong>数组也是一种类型，数组并不等价于指针</strong>。</p><h2 id="C-throw（抛出异常）"><a href="#C-throw（抛出异常）" class="headerlink" title="C++ throw（抛出异常）"></a>C++ throw（抛出异常）</h2><p>C++ 异常处理的流程，具体为：</p><blockquote><p>抛出（Throw）–&gt; 检测（Try） –&gt; 捕获（Catch）</p></blockquote><p>异常必须显式地抛出，才能被检测和捕获到；如果没有显式的抛出，即使有异常也检测不到。</p><p>在 C++ 中，我们使用 throw 关键字来显式地抛出异常，它的用法为：</p><blockquote><p>throw exceptionData;</p></blockquote><p>exceptionData 是“异常数据”的意思，它可以包含任意的信息，完全有程序员决定。exceptionData 可以是 int、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。</p><h2 id="throw-用作异常规范（了解）"><a href="#throw-用作异常规范（了解）" class="headerlink" title="throw 用作异常规范（了解）"></a>throw 用作异常规范（了解）</h2><p>throw 关键字除了可以用在函数体中抛出异常，还可以用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为异常规范（Exception specification），有些教程也称为异常指示符或异常列表。请看下面的例子：</p><blockquote><p>double func (char param) throw (int);</p></blockquote><p>这条语句声明了一个名为 func 的函数，它的返回值类型为 double，有一个 char 类型的参数，并且只能抛出 int 类型的异常。如果抛出其他类型的异常，try 将无法捕获，只能终止程序。</p><p>如果函数会抛出多种类型的异常，那么可以用逗号隔开：</p><blockquote><p>double func (char param) throw (int, char, exception);</p></blockquote><p>如果函数不会抛出任何异常，那么( )中什么也不写：</p><blockquote><p>double func (char param) throw ();</p></blockquote><p>如此，func() 函数就不能抛出任何类型的异常了，即使抛出了，try 也检测不到。</p><p>C++ 规定，派生类虚函数的异常规范必须与基类虚函数的异常规范一样严格，或者更严格。同时要求异常规范在函数声明和函数定义中必须同时指明，并且要严格<strong>保持一致</strong>，不能更加严格或者更加宽松。</p><p>不过<strong>异常规范是 C++98 新增的一项功能，但是后来的 C++11 已经将它抛弃了</strong>，不再建议使用。另外，各个编译器对异常规范的支持也不一样。</p><h2 id="C-exception类：C-标准异常的基类"><a href="#C-exception类：C-标准异常的基类" class="headerlink" title="C++ exception类：C++标准异常的基类"></a>C++ exception类：C++标准异常的基类</h2><p>C++语言本身或者标准库抛出的异常都是 exception 的子类，称为标准异常（Standard Exception）。可以通过下面的语句来捕获所有的标准异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(exception &amp;e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以使用引用，是为了提高效率。如果不使用引用，就要经历一次对象拷贝（要调用拷贝构造函数）的过程。</p><p>exception 类位于 &lt;exception&gt; 头文件中，它被声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">exception</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    exception () <span class="keyword">throw</span>();  <span class="comment">//构造函数</span></span><br><span class="line">    exception (<span class="keyword">const</span> exception&amp;) <span class="keyword">throw</span>();  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    exception&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> exception&amp;) <span class="keyword">throw</span>();  <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="keyword">virtual</span> ~exception() <span class="keyword">throw</span>();  <span class="comment">//虚析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明的是 what() 函数。what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略告诉你这是什么异常。不过C++标准并没有规定这个字符串的格式，各个编译器的实现也不同，所以 what() 的返回值仅供参考。</p><p>下图展示了 exception 类的继承层次：<br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200509214741.png" alt="exception 类的继承层次以及它们所对应的头文件"></p><p>exception 类的直接派生类：</p><table><thead><tr><th align="left">异常名称</th><th>说  明</th></tr></thead><tbody><tr><td align="left">logic_error</td><td>逻辑错误。</td></tr><tr><td align="left">runtime_error</td><td>运行时错误。</td></tr><tr><td align="left">bad_alloc</td><td>使用 new 或 new[ ] 分配内存失败时抛出的异常。</td></tr><tr><td align="left">bad_typeid</td><td>使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常。</td></tr><tr><td align="left">bad_cast</td><td>使用 dynamic_cast 转换失败时抛出的异常。</td></tr><tr><td align="left">ios_base::failure</td><td>io 过程中出现的异常。</td></tr><tr><td align="left">bad_exception</td><td>这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型。</td></tr></tbody></table><p>logic_error 的派生类： </p><table><thead><tr><th align="left">异常名称</th><th>说  明</th></tr></thead><tbody><tr><td align="left">length_error</td><td>试图生成一个超出该类型最大长度的对象时抛出该异常，例如 vector 的 resize 操作。</td></tr><tr><td align="left">domain_error</td><td>参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数。</td></tr><tr><td align="left">out_of_range</td><td>超出有效范围。</td></tr><tr><td align="left">invalid_argument</td><td>参数不合适。在标准库中，当利用string对象构造 bitset 时，而 string 中的字符不是 0 或1 的时候，抛出该异常。</td></tr></tbody></table><p>runtime_error 的派生类： </p><table><thead><tr><th align="left">异常名称</th><th>说  明</th></tr></thead><tbody><tr><td align="left">range_error</td><td>计算结果超出了有意义的值域范围。</td></tr><tr><td align="left">overflow_error</td><td>算术计算上溢。</td></tr><tr><td align="left">underflow_error</td><td>算术计算下溢。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常（一）</title>
      <link href="/2020/05/07/try0507/"/>
      <url>/2020/05/07/try0507/</url>
      
        <content type="html"><![CDATA[<h2 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++ 异常处理"></a>C++ 异常处理</h2><p>程序的错误大致可以分为三种，分别是语法错误、逻辑错误和运行时错误：</p><p>1) 语法错误在编译和链接阶段就能发现，只有 100% 符合语法规则的代码才能生成可执行程序。语法错误是最容易发现、最容易定位、最容易排除的错误，程序员最不需要担心的就是这种错误。</p><p>2) 逻辑错误是说我们编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决。</p><p>3) 运行时错误是指程序在运行期间发生的错误，例如除数为 0、内存分配失败、数组越界、文件不存在等。C++ 异常（Exception）机制就是为解决运行时错误而引入的。</p><p>运行时错误如果放任不管，系统就会执行默认的操作，终止程序运行，也就是我们常说的程序崩溃（Crash）。<strong>C++ 提供了异常（Exception）机制，让我们能够捕获运行时错误，给程序一次“起死回生”的机会，或者至少告诉用户发生了什么再终止程序。</strong></p><p>例如下面一个发生错误的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="keyword">char</span> ch1 = str[<span class="number">100</span>];  <span class="comment">//下标越界，ch1为垃圾值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ch1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> ch2 = str.at(<span class="number">100</span>);  <span class="comment">//下标越界，抛出异常</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ch2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，在控制台输出 ch1 的值后程序崩溃。下面我们来分析一下原因。</p><p>at() 是 string 类的一个成员函数，它会根据下标来返回字符串的一个字符。与[ ]不同，at() 会检查下标是否越界，如果越界就抛出一个异常；而[ ]不做检查，不管下标是多少都会照常访问。</p><blockquote><p>所谓抛出异常，就是报告一个运行时错误，程序员可以根据错误信息来进一步处理。</p></blockquote><p>上面的代码中，下标 100 显然超出了字符串 str 的长度。由于第 6 行代码不会检查下标越界，虽然有逻辑错误，但是程序能够正常运行。而第 8 行代码则不同，at() 函数检测到下标越界会抛出一个异常，这个异常可以由程序员处理，但是我们在代码中并没有处理，所以系统只能执行默认的操作，也即终止程序执行。</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>我们可以借助 C++ 异常机制来捕获上面的异常，避免程序崩溃。捕获异常的语法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(exceptionType variable)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try和catch都是 C++ 中的关键字，后跟语句块，不能省略{ }。try 中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的 catch 捕获。从 try 的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。catch 是“抓住”的意思，用来捕获并处理 try 检测到的异常；如果 try 语句块没有检测到异常（没有异常抛出），那么就不会执行 catch 中的语句。</p><p><strong>这就好比，catch 告诉 try：你去检测一下程序有没有错误，有错误的话就告诉我，我来处理，没有的话就不要理我！</strong></p><p>catch 关键字后面的 exceptionType variable 指明了当前 catch 可以处理的异常类型，以及具体的出错信息.</p><p>示例二：修改上面的代码，加入捕获异常的语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = str[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ch1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(exception e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[1]out of bound!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch2 = str.at(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ch2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(exception &amp;e)&#123;  <span class="comment">//exception类位于&lt;exception&gt;头文件中</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[2]out of bound!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>(<br>[2]out of bound!</p></blockquote><p>可以看出，第一个 try 没有捕获到异常，输出了一个没有意义的字符（垃圾值）。<strong>因为[ ]不会检查下标越界，不会抛出异常</strong>，所以即使有错误，try 也检测不到。<strong>换句话说，发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到</strong>。所谓抛出异常，就是明确地告诉程序发生了什么错误。</p><p>第二个 try 检测到了异常，并交给 catch 处理，执行 catch 中的语句。需要说明的是，异常一旦抛出，会立刻被 try 检测到，并且不会再执行异常点（异常发生位置）后面的语句。本例中抛出异常的位置是第 17 行的 at() 函数，它后面的 cout 语句就不会再被执行，所以看不到它的输出。</p><p>说得直接一点，<strong>检测到异常后程序的执行流会发生跳转，从异常点跳转到 catch 所在的位置，位于异常点之后的、并且在当前 try 块内的语句就都不会再执行了</strong>；即使 catch 语句成功地处理了错误，程序的执行流也不会再回退到异常点，所以这些语句永远都没有执行的机会了。本例中，第 18 行代码就是被跳过的代码。</p><p>执行完 catch 块所包含的代码后，程序会继续执行 catch 块后面的代码，就恢复了正常的执行流。</p><p>为了演示「不明确地抛出异常就检测不到异常」，大家不妨将第 10 行代码改为char ch1 = str[100000000];，访问第 100 个字符可能不会发生异常，但是访问第 1 亿个字符肯定会发生异常了，这个异常就是内存访问错误。运行更改后的程序，会发现第 10 行代码产生了异常，导致程序崩溃了，这说明 try-catch 并没有捕获到这个异常。</p><h3 id="发生异常的位置"><a href="#发生异常的位置" class="headerlink" title="发生异常的位置"></a>发生异常的位置</h3><p>异常可以发生在当前的 try 块中，也可以发生在 try 块所调用的某个函数中，或者是所调用的函数又调用了另外的一个函数，这个另外的函数中发生了异常。这些异常，都可以被 try 检测到。</p><p>1) 下面的例子演示了 try 块中直接发生的异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Unknown Exception"</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Unknown Exception</p></blockquote><p>throw关键字用来抛出一个异常，这个异常会被 try 检测到，进而被 catch 捕获。关于 throw 的用法，我们将在下节深入讲解，这里大家只需要知道，在 try 块中直接抛出的异常会被 try 检测到。</p><p>2) 下面的例子演示了 try 块中调用的某个函数中发生了异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Unknown Exception"</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"[1]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        func();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[2]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Unknown Exception</p></blockquote><p>func() 在 try 块中被调用，它抛出的异常会被 try 检测到，进而被 catch 捕获。从运行结果可以看出，func() 中的 cout 和 try 中的 cout 都没有被执行。</p><p>3) try 块中调用了某个函数，该函数又调用了另外的一个函数，这个另外的函数抛出了异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Unknown Exception"</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"[1]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func_inner();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"[2]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        func_outer();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[3]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Unknown Exception</p></blockquote><p>发生异常后，程序的执行流会沿着函数的调用链往前回退，直到遇见 try 才停止。在这个回退过程中，调用链中剩下的代码（所有函数中未被执行的代码）都会被跳过，没有执行的机会了。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板（二）</title>
      <link href="/2020/05/07/template2/"/>
      <url>/2020/05/07/template2/</url>
      
        <content type="html"><![CDATA[<h2 id="三、模板的形参"><a href="#三、模板的形参" class="headerlink" title="三、模板的形参"></a>三、模板的形参</h2><p>有三种类型的模板形参：类型形参，非类型形参和模板形参。</p><p><strong>1、类型形参</strong></p><p>1.1 、类型模板形参：<strong>类型形参由关见字class或typename后接说明符构成</strong>，如<strong>template<class T> void h(T a){}</strong>;其中<strong>T</strong>就是一个类型形参，类型形参的名字由用户自已确定。<strong>模板形参表示的是一个未知的类型</strong>。模板类型形参可作为类型说明符用在模板中的任何地方，与内置类型说明符或类类型说明符的使用方式完全相同，即可以用于指定返回类型，变量声明等。</p><p>1.2、不能为同一个模板类型形参指定两种不同的类型，比如<strong>template<class T>void h(T a, T b){}</strong>，语句调用h(2, 3.2)将出错，因为该语句给同一模板形参T指定了两种类型，第一个实参2把模板形参T指定为int，而第二个实参3.2把模板形参指定为double，两种类型的形参不一致，会出错。<strong>（针对函数模板）</strong></p><p>1.2针对函数模板是正确的，但是忽略了类模板。下面将对类模板的情况进行补充。</p><p>1.2补充版（<strong>针对于类模板</strong>）、当我们声明类对象为：<strong>A<int> a</strong>，比如<strong>template<class T>T g(T a, T b){}</strong>，语句调用a.g(2, 3.2)在编译时不会出错，但会有警告，因为在声明类对象的时候已经将T转换为int类型，而第二个实参3.2把模板形参指定为double，在运行时，会对3.2进行强制类型转换为3。当我们声明类的对象为：A<double> a,此时就不会有上述的警告，因为从int到double是自动类型转换。</p><p><strong>2、非类型形参</strong></p><p>　　　　2.1 、非类型模板形参：<strong>模板的非类型形参也就是内置类型形参</strong>，如</p><blockquote><p>  template&lt;class T, int a&gt; class B{};</p></blockquote><p>其中int a就是非类型的模板形参。</p><p>　　　　2.2、 非类型形参在模板定义的内部是常量值，也就是说非类型形参在模板的内部是常量。</p><p>　　　　2.3、 <strong>非类型模板的形参只能是整型，指针和引用</strong>，像double，String, String **这样的类型是不允许的。但是double &amp;，double *，对象的引用或指针是正确的。</p><p>　　　　2.4、 <strong>调用非类型模板形参的实参必须是一个常量表达式</strong>，即他必须能在编译时计算出结果。</p><p>　　　　2.5 、注意：<strong>任何局部对象，局部变量，局部对象的地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参</strong>。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模板形参的实参。</p><p>　　　　2.6、<strong>全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参。</strong></p><p>　　　　2.7 、<strong>sizeof</strong>表达式的结果是一个常量表达式，也能用作非类型模板形参的实参。</p><p>　　　　2.8 、当模板的形参是整型时调用该模板时的实参必须是整型的，且在编译期间是常量，比如</p><blockquote><p>  template &lt;class T, int a&gt; class A{};</p></blockquote><p>如果有int b，这时A&lt;int, b&gt; m;将出错，因为b不是常量，如果const int b，这时A&lt;int, b&gt; m;就是正确的，因为这时b是常量。</p><p>　　　　2.9 、<strong>非类型形参一般不应用于函数模板中</strong>，比如有函数模板</p><blockquote><p>  template&lt;class T, int a&gt; void h(T b){}，</p></blockquote><p>若使用h(2)调用会出现无法为非类型形参a推演出参数的错误，对这种模板函数可以用显示模板实参来解决，如用h&lt;int, 3&gt;(2)这样就把非类型形参a设置为整数3。显示模板实参在后面介绍。</p><p>　　　　2.10、 非类型模板形参的形参和实参间所允许的转换</p><p>　　　　　　1、允许从数组到指针，从函数到指针的转换。如：</p><blockquote><p>  template &lt;int *a&gt; class A{}; int b[1]; A&lt;b&gt; m;</p></blockquote><p>即数组到指针的转换</p><p>　　　　　　2、const修饰符的转换。如：template&lt;const int *a&gt; class A{}; int b; A&lt;&amp;b&gt; m; 即从int *到const int *的转换。</p><p>　　　　　　3、提升转换。如：template<int a> class A{}; const short b=2; A&lt;b&gt; m; 即从short到int 的提升转换</p><p>　　　　　　4、整值转换。如：template<unsigned int a> class A{};   A&lt;3&gt; m; 即从int 到unsigned int的转换。</p><p>　　　　　　5、常规转换。</p><h2 id="四、类模板的默认模板类型形参"><a href="#四、类模板的默认模板类型形参" class="headerlink" title="四、类模板的默认模板类型形参"></a>四、类模板的默认模板类型形参</h2><p>1、可以为类模板的类型形参提供默认值，但不能为函数模板的类型形参提供默认值。函数模板和类模板都可以为模板的非类型形参提供默认值。</p><p>2、类模板的类型形参默认值形式为：</p><blockquote><p>template&lt;class T1, class T2=int&gt; class A{};</p></blockquote><p>为第二个模板类型形参T2提供int型的默认值。</p><p>3、类模板类型形参默认值和函数的默认参数一样，如果有多个类型形参则从第一个形参设定了默认值之后的所有模板形参都要设定默认值，类模板如果有多个类型形参，如果使用类型形参默认值则尽量放在参数列表的末尾，而且默认的参数类型必须相同。在下面示例中：</p><blockquote><p>template&lt;class T1=int, class T2&gt;class A{};</p></blockquote><p>就是错误的，因为T1给出了默认值，而T2没有设定。</p><p>4、在类模板的外部定义类中的成员时template 后的形参表应省略默认的形参类型。比如</p><blockquote><p>template&lt;class  T1, class T2=int&gt; class A{public: void h();}; </p></blockquote><p>定义方法为</p><blockquote><p>template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</span></span><br><span class="line"><span class="comment">//类模板的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">A</span>&#123;</span><span class="keyword">public</span>:<span class="function">T <span class="title">g</span><span class="params">(T a, T b)</span></span>; A();&#125;;  <span class="comment">//定义带有一个类模板类型形参T的类A</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;<span class="title">class</span> <span class="title">B</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义带有两个类模板类型形参T1，T2的类B</span></span><br><span class="line"><span class="comment">//定义类模板的默认类型形参，默认类型形参不适合于函数模板。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>=<span class="title">int</span>&gt; <span class="title">class</span> <span class="title">D</span>&#123;</span><span class="keyword">public</span>: voidg();&#125;; <span class="comment">//定义带默认类型形参的类模板。这里把T2默认设置为int型。</span></span><br><span class="line"><span class="comment">//template&lt;class T1=int, class T2&gt;class E&#123;&#125;; //错误，为T1设了默认类型形参则T1后面的所有形参都必须设置认默值。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//以下为非类型形参的定义</span></span><br><span class="line"><span class="comment">//非类型形参只能是整型，指针和引用，像double，String, String **这样的类型是不允许的。但是double &amp;，double *对象的引用或指</span></span><br><span class="line">针是正确的。</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> <span class="title">a</span>&gt; <span class="title">class</span> <span class="title">Ci</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义模板的非类型形参，形参为整型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> &amp;<span class="title">a</span>&gt;<span class="title">class</span> <span class="title">Cip</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">A</span>&lt;int&gt;* <span class="title">m</span>&gt; <span class="title">class</span> <span class="title">Cc</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义模板的模板类型形参，形参为int型的类A的对象的指针。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">double</span>*<span class="title">a</span>&gt;<span class="title">class</span> <span class="title">Cd</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;;  <span class="comment">//定义模板的非类型形参，形参为double类型的引用。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>&#123;</span>&#125;; <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">E</span> &amp;<span class="title">m</span>&gt; <span class="title">class</span> <span class="title">Ce</span>&#123;</span>&#125;; <span class="comment">//非类型模板形参为对象的引用。</span></span><br><span class="line"><span class="comment">//以下非类型形参的声明是错误的。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,A m&gt;class Cc&#123;&#125;; //错误，对象不能做为非类型形参，非类型模板形参的类型只能是对象的引用或指针。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,double a&gt;class Cc&#123;&#125;; //错误，非类型模板的形参不能是double类型，可以是double的引用。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,A&lt;int&gt; m&gt;class Cc&#123;&#125;; //错误，非类型模板的形参不能是对象，必须是对象的引用或指针。这条规则对于模板型参</span></span><br><span class="line">也不例外。</span><br><span class="line"><span class="comment">//在类模板外部定义各种类成员的方法，</span></span><br><span class="line"><span class="comment">//typeid(变量名).name()的作用是提取变量名的类型，如int a，则cout&lt;&lt;typeid(a).name()将输出int</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;   <span class="title">A</span>&lt;T&gt;:</span>:A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class A goucao"</span>&lt;&lt;<span class="keyword">typeid</span>(T).name()&lt;&lt;<span class="built_in">endl</span>;&#125; <span class="comment">//在类模板外部定义类的构造函数的方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">A</span>&lt;T&gt;:</span>:g(T a,T b)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class A g(T a,T b)"</span>&lt;&lt;<span class="built_in">endl</span>;&#125; <span class="comment">//在类模板外部定义类模板的成员</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;  <span class="title">voidB</span>&lt;T1,T2&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class g f()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="keyword">typeid</span>(T2).name()&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="comment">//在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> <span class="title">a</span>&gt;     <span class="title">voidCi</span>&lt;T1,a&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Ci g()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> &amp;<span class="title">a</span>&gt;    <span class="title">voidCip</span>&lt;T1,a&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Cip g()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="built_in">endl</span>;&#125; </span><br><span class="line"><span class="comment">//在类外部定义类的成员时，template后的模板形参应与要定义的类的模板形参一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">A</span>&lt;int&gt; *<span class="title">m</span>&gt; <span class="title">voidCc</span>&lt;T1,m&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Cc g()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">double</span>* <span class="title">a</span>&gt; <span class="title">voidCd</span>&lt;T1,a&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Cd g()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//带有默认类型形参的模板类，在类的外部定义成员的方法。</span></span><br><span class="line"><span class="comment">//在类外部定义类的成员时，template的形参表中默认值应省略</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;  <span class="title">voidD</span>&lt;T1,T2&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class D g()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="comment">//template&lt;class T1,class T2=int&gt; void D&lt;T1,T2&gt;::g()&#123;cout&lt;&lt;"class D k()"&lt;&lt;endl;&#125; //错误，在类模板外部定义带有默认类型的形</span></span><br><span class="line">参时，在<span class="keyword">template</span>的形参表中默认值应省略。</span><br><span class="line"><span class="comment">//定义一些全局变量。</span></span><br><span class="line"><span class="keyword">int</span> e=<span class="number">2</span>;  doubleed=<span class="number">2.2</span>; <span class="keyword">double</span>*pe=&amp;ed;</span><br><span class="line">A&lt;<span class="keyword">int</span>&gt; mw; A&lt;<span class="keyword">int</span>&gt; *pec=&amp;mw; E me;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// template&lt;class T&gt;void h()&#123;&#125; //错误，模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行。</span></span><br><span class="line"><span class="comment">//A&lt;2&gt; m; //错误，对类模板不存在实参推演问题，类模板必须在尖括号中明确指出其类型。</span></span><br><span class="line"><span class="comment">//类模板调用实例</span></span><br><span class="line">A&lt;<span class="keyword">int</span>&gt; ma; <span class="comment">//输出"class A goucao int"创建int型的类模板A的对象ma。</span></span><br><span class="line">B&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mb; mb.g(); <span class="comment">//输出"class B g() int int"创建类模板B的对象mb，并把类型形参T1和T2设计为int</span></span><br><span class="line"><span class="comment">//非类型形参的调用</span></span><br><span class="line"><span class="comment">//调用非类型模板形参的实参必须是一个常量表达式，即他必须能在编译时计算出结果。任何局部对象，局部变量，局部对象的地址，局部</span></span><br><span class="line">变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能</span><br><span class="line">用作非类型模板形参的实参。</span><br><span class="line"><span class="comment">//全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参。</span></span><br><span class="line"><span class="comment">//调用整型int型非类型形参的方法为名为Ci，声明形式为template&lt;class T1,int a&gt; class Ci</span></span><br><span class="line">Ci&lt;<span class="keyword">int</span>,<span class="number">3</span>&gt;<span class="comment">//正确，数值R是一个int型常量，输出"class Ci g() int"</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a2=<span class="number">3</span>; Ci&lt;<span class="keyword">int</span>,a2&gt; mci1; mci1.g(); <span class="comment">//正确，因为a2在这里是const型的常量。输出"class Ci g() int"</span></span><br><span class="line"><span class="comment">//Ci&lt;int,a&gt; mci; //错误，int型变量a是局部变量，不是一个常量表达式。</span></span><br><span class="line"><span class="comment">//Ci&lt;int,e&gt; mci; //错误，全局int型变量e也不是一个常量表达式。</span></span><br><span class="line"><span class="comment">//调用int&amp;型非类型形参的方法类名为Cip，声明形式为template&lt;class T1,int &amp;a&gt;class Cip</span></span><br><span class="line">Cip&lt;<span class="keyword">int</span>,e&gt; mcip;  <span class="comment">//正确，对全局变量的引用或地址是常量表达式。</span></span><br><span class="line"><span class="comment">//Cip&lt;int,a&gt; mcip1; //错误，局部变量的引用或地址不是常量表达式。</span></span><br><span class="line"><span class="comment">//调用double*类型的非类形形参类名为Cd，声明形式为template&lt;class T1,double *a&gt;class Cd</span></span><br><span class="line">Cd&lt;<span class="keyword">int</span>,&amp;ed&gt; mcd; <span class="comment">//正确，全局变量的引用或地址是常量表达式。</span></span><br><span class="line"><span class="comment">//Cd&lt;int,pe&gt; mcd1; //错误，全局变量指针不是常量表达式。</span></span><br><span class="line"><span class="comment">//double dd=3.3; //错误，局部变量的地址不是常量表达式，不能用作非类型形参的实参</span></span><br><span class="line"><span class="comment">//Cd&lt;int,&amp;e&gt; mcd;  //错误，非类型形参虽允许一些转换，但这个转换不能实现。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//调用模板类型形参对象A&lt;int&gt; *的方法类名为Cc，声名形式为template&lt;class T1,A&lt;int&gt;* m&gt; class Cc</span></span><br><span class="line">Cc&lt;<span class="keyword">int</span>,&amp;mw&gt; mcc; mcc.g(); <span class="comment">//正确，全局对象的地址或者引用是常量表达式</span></span><br><span class="line"><span class="comment">//Cc&lt;int,&amp;ma&gt; mcc;  //错误，局部变量的地址或引用不是常量表达式。</span></span><br><span class="line"><span class="comment">//Cc&lt;int,pec&gt; mcc2;  //错误，全局对象的指针不是常量表达式。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//调用非类型形参E&amp;对象的引用的方法类名为Ce。声明形式为template&lt;class T1,E &amp;m&gt; class Ce</span></span><br><span class="line">E me1; <span class="comment">//Ce&lt;int,me1&gt; mce1; //错误，局部对象不是常量表达式</span></span><br><span class="line">Ce&lt;<span class="keyword">int</span>,me&gt; mce;  <span class="comment">//正确，全局对象的指针或引用是常量表达式。</span></span><br><span class="line"><span class="comment">//非类型形参的转换示例，类名为Ci</span></span><br><span class="line"><span class="comment">//非类型形参允许从数组到指针，从函数到指针的转换，const修饰符的转换，提升转换，整值转换，常规转换。</span></span><br><span class="line"><span class="keyword">const</span> short s=<span class="number">3</span>; Ci&lt;<span class="keyword">int</span>,s&gt; mci4<span class="comment">//正确，虽然short型和int不完全匹配，但这里可以将short型转换为int型</span></span><br></pre></td></tr></table></figure><p>整理参考：<a href="https://www.runoob.com/w3cnote/c-templates-detail.html" target="_blank" rel="noopener">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板（一）</title>
      <link href="/2020/05/06/template1/"/>
      <url>/2020/05/06/template1/</url>
      
        <content type="html"><![CDATA[<p>模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。</p><p>模板是一种对类型进行参数化的工具；</p><p>通常有两种形式：<strong>函数模板</strong>和<strong>类模板</strong>；</p><p>函数模板针对仅参数类型不同的函数；</p><p>类模板针对仅数据成员和成员函数类型不同的类。</p><p>使用模板的目的就是能够让程序员编写与类型无关的代码。比如编写了一个交换两个整型int 类型的swap函数，这个函数就只能实现int 型，对double，字符这些类型无法实现，要实现这些类型的交换就要重新编写另一个swap函数。使用模板的目的就是要让这程序的实现与类型无关，比如一个swap模板函数，即可以实现int 型，又可以实现double型的交换。模板可以应用于函数和类。下面分别介绍。</p><p><strong>注意</strong>：<strong><em>模板的声明或定义只能在全局</em></strong>，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</p><h2 id="一、函数模板通式"><a href="#一、函数模板通式" class="headerlink" title="一、函数模板通式"></a>一、函数模板通式</h2><p>1、函数模板的格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 形参名，<span class="title">class</span> 形参名，......&gt; 返回类型 函数名(参数列表)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中template和class是关见字，class可以用typename 关见字代替，在这里typename 和class没区别，&lt;&gt;括号中的参数叫模板形参，模板形参和函数形参很相像，模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。模板形参需要调用该模板函数时提供的模板实参来初始化模板形参，一旦编译器确定了实际的模板实参类型就称他实例化了函数模板的一个实例。比如swap的模板函数形式为:</p><blockquote><p>template <class T> void swap(T&amp; a, T&amp; b){}，</p></blockquote><p>当调用这样的模板函数时类型T就会被被调用时的类型所代替，比如<strong>swap(a,b)</strong>其中<strong>a</strong>和<strong>b</strong>是<strong>int</strong> 型，这时模板函数swap中的形参<strong>T</strong>就会被<strong>int</strong> 所代替，模板函数就变为<strong>swap(int &amp;a, int &amp;b)</strong>。而当<strong>swap(c,d)</strong>其中<strong>c</strong>和<strong>d</strong>是<strong>double</strong>类型时，模板函数会被替换为<strong>swap(double &amp;a, double &amp;b)</strong>，这样就实现了函数的实现与类型无关的代码。</p><p>2、注意：对于函数模板而言不存在 h(int,int) 这样的调用，<strong>不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行</strong>，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b)。</p><p>函数模板的示例演示在下文涉及.</p><h2 id="二、类模板通式"><a href="#二、类模板通式" class="headerlink" title="二、类模板通式"></a>二、类模板通式</h2><p>1、类模板的格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>  形参名，<span class="title">class</span> 形参名，…&gt;   <span class="title">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure><p>类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如</p><blockquote><p>template<class T> class A{public: T a; T b; T hy(T c, T &amp;d);};</p></blockquote><p>在类A中声明了两个类型为T的成员变量a和b，还声明了一个返回类型为T带两个参数类型为T的函数hy。</p><p>　　2、类模板对象的创建：比如一个模板类A，则使用类模板创建对象的方法为A&lt;int&gt; m;在类A后面跟上一个&lt;&gt;尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A&lt;int, double&gt; m;类型之间用逗号隔开。</p><p>　　3、对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A&lt;2&gt; m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: ‘a’ uses undefined class ‘A<int>‘），<strong>类模板形参不存在实参推演的问题</strong> 。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A&lt;int&gt; m。</p><p>4、在类模板外部定义成员函数的方法为：</p><blockquote><p>template&lt;模板形参列表&gt; 函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}</p></blockquote><p>比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为：</p><blockquote><p>template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。</p></blockquote><p>注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。</p><p>5、再次提醒注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++的运算符重载</title>
      <link href="/2020/05/06/c-operator/"/>
      <url>/2020/05/06/c-operator/</url>
      
        <content type="html"><![CDATA[<h1 id="C-运算符重载基础教程"><a href="#C-运算符重载基础教程" class="headerlink" title="C++运算符重载基础教程"></a>C++运算符重载基础教程</h1><p>函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作。<strong>运算符重载（Operator Overloading）</strong> 也是一个道理，同一个运算符可以有不同的功能。</p><p>实际上，我们已经在不知不觉中使用了运算符重载。例如，<kbd>+</kbd>号可以对不同类型（int、float 等）的数据进行加法操作；<kbd><</kbd>既是位移运算符，又可以配合 cout 向控制台输出数据。C++ 本身已经对这些运算符进行了重载。</p><p>C++ 也允许程序员自己重载运算符.</p><p>下面的代码定义了一个复数类，通过运算符重载，可以用+号实现复数的加法运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现运算符重载</span></span><br><span class="line"><span class="built_in">complex</span> <span class="built_in">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">complex</span> B;</span><br><span class="line">    B.m_real = <span class="keyword">this</span>-&gt;m_real + A.m_real;</span><br><span class="line">    B.m_imag = <span class="keyword">this</span>-&gt;m_imag + A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="built_in">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：6.7 + 9.5i</code></pre><p>本例中义了一个复数类 complex，m_real 表示实部，m_imag 表示虚部.</p><p>运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数。<strong>也就是说，运算符重载是通过函数实现的，它本质上是函数重载。</strong></p><p>运算符重载的格式为：</p><blockquote><p>返回值类型  operator 运算符名称 (形参表列){<br>    //TODO:<br>}</p></blockquote><p><kbd>operator</kbd>是关键字，专门用于定义重载运算符的函数。我们可以将<kbd>operator</kbd> 运算符名称这一部分看做函数名，对于上面的代码，函数名就是<kbd>operator+</kbd>。</p><p><strong>运算符重载函数除了函数名有特定的格式，其它地方和普通函数并没有区别。</strong></p><p>上面的例子中，我们在 complex 类中重载了运算符<kbd>+</kbd>，该重载只对 complex 对象有效。当执行<kbd>c3 = c1 + c2;</kbd>语句时，编译器检测到<kbd>+</kbd>号左边（<kbd>+</kbd>号具有左结合性，所以先检测左边）是一个 complex 对象，就会调用成员函数<kbd>operator+()</kbd>，也就是转换为下面的形式：</p><blockquote><p>c3 = c1.operator+(c2);</p></blockquote><p>c1 是要调用函数的对象，c2 是函数的实参。</p><p>上面的运算符重载还可以有更加简练的定义形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> <span class="built_in">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="keyword">this</span>-&gt;m_real + A.m_real, <span class="keyword">this</span>-&gt;m_imag + A.m_imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return 语句中的<kbd>complex(this->m_real + A.m_real, this->m_imag + A.m_imag)</kbd>会创建一个临时对象，这个对象没有名称，是一个<strong>匿名对象</strong>。在创建临时对象过程中调用构造函数，return 语句将该临时对象作为函数返回值。</p><h2 id="在全局范围内重载运算符"><a href="#在全局范围内重载运算符" class="headerlink" title="在全局范围内重载运算符"></a>在全局范围内重载运算符</h2><p><strong>运算符重载函数不仅可以作为类的成员函数，还可以作为全局函数</strong>。更改上面的代码，在全局范围内重载<kbd>+</kbd>，实现复数的加法运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//声明为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;</span><br><span class="line">    <span class="keyword">double</span> m_imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B);</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在全局范围内重载+</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real + B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag + B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="built_in">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符重载函数不是 complex 类的成员函数，但是却用到了 complex 类的 private 成员变量，所以必须在 complex 类中将该函数声明为友元函数.</p><p>执行<kbd>c3 = c1 + c2;</kbd>语句时，编译器检测到+号两边都是 complex 对象，就会转换为类似下面的函数调用：</p><blockquote><p>c3 = operator+(c1, c2);</p></blockquote><h1 id="C-运算符重载时要遵循的规则"><a href="#C-运算符重载时要遵循的规则" class="headerlink" title="C++运算符重载时要遵循的规则"></a>C++运算符重载时要遵循的规则</h1><p>运算符重载是通过函数重载实现的，概念上大家都很容易理解，这节主要来说一下运算符重载的注意事项。</p><p>1) 并不是所有的运算符都可以重载。能够重载的运算符包括：<br>+  -  *  /  %  ^  &amp;  |  ~  !  =  &lt;  &gt;  +=  -=  *=  /=  %=  ^=  &amp;=  |=  &lt;&lt;  &gt;&gt;  &lt;&lt;=  &gt;&gt;=  ==  !=  &lt;=  &gt;=  &amp;&amp;  ||  ++  –  ,  -&gt;*  -&gt;  ()  []  new  new[]  delete  delete[]</p><p>上述运算符中，<kbd>[]</kbd>是下标运算符，<kbd>()</kbd>是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符<kbd>sizeof</kbd>、条件运算符<kbd>: ?</kbd>、成员选择符<kbd>.</kbd>和域解析运算符<kbd>::</kbd>不能被重载。</p><p>2) 重载不能改变运算符的优先级和结合性。假设上一节的 complex 类中重载了<kbd>+</kbd>号和<kbd>*</kbd>号，并且 c1、c2、c3、c4 都是 complex 类的对象，那么下面的语句：</p><blockquote><p>c4 = c1 + c2 * c3;</p></blockquote><p>等价于：</p><blockquote><p>c4 = c1 + ( c2 * c3 );</p></blockquote><p>乘法的优先级仍然高于加法，并且它们仍然是二元运算符。</p><p>3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。例如<kbd>~</kbd>号右边只有一个操作数，<kbd>+</kbd>号总是出现在两个操作数之间，重载后也必须如此。</p><p>4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。</p><p>5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。</p><p><strong>将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。</strong></p><p>例如，上节的 complex 类中重载了加法运算符：</p><blockquote><p>complex operator+(const complex &amp; A) const;</p></blockquote><p>当执行：</p><blockquote><p>c3 = c1 + c2;</p></blockquote><p>会被转换为：</p><blockquote><p>c3 = c1.operator+(c2);</p></blockquote><p>通过 this 指针隐式的访问 c1 的成员变量。</p><p><strong>将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。</strong></p><p>例如，下面这样是不对的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> + (<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> (a-b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><kbd>+</kbd>号原来是对两个数相加，现在企图通过重载使它的作用改为两个数相减， 如果允许这样重载的话，那么表达式<kbd>4+3</kbd>的结果是 7 还是 1 呢？显然，这是绝对禁止的。</p><p>如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是C ++内置类型的数据，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">int</span> a, <span class="built_in">complex</span> &amp;c)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a+c.real, c.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是使一个整数和一个复数相加。</p><p>另外，将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数。原因很简单，该函数大部分情况下都需要使用类的 private 成员。</p><p>上节的最后一个例子中，我们在全局范围内重载了<kbd>+</kbd>号，并在 complex 类中将运算符重载函数声明为友元函数，因为该函数使用到了 complex 类的 m_real 和 m_imag 两个成员变量，它们都是 private 属性的，默认不能在类的外部访问。</p><p>6) 箭头运算符<kbd>-></kbd>、下标运算符<kbd>[ ]</kbd>、函数调用运算符<kbd>( )</kbd>、赋值运算符<kbd>=</kbd>只能以成员函数的形式重载。</p><h1 id="C-重载数学运算符（实例演示）"><a href="#C-重载数学运算符（实例演示）" class="headerlink" title="C++重载数学运算符（实例演示）"></a>C++重载数学运算符（实例演示）</h1><p>四则运算符（+、-、*、/、+=、-=、*=、/=）和关系运算符（&gt;、&lt;、&lt;=、&gt;=、==、!=）都是数学运算符，它们在实际开发中非常常见，被重载的几率也很高，并且有着相似的重载格式。本节以复数类 Complex 为例对它们进行重载，重在演示运算符重载的语法以及规范。</p><p>复数能够进行完整的四则运算，但不能进行完整的关系运算：我们只能判断两个复数是否相等，但不能比较它们的大小，所以不能对 &gt;、&lt;、&lt;=、&gt;= 进行重载。下面是具体的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//构造函数</span></span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="comment">//以全局函数的形式重载</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="comment">//以成员函数的形式重载</span></span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_imag; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real - c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag - c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符  (a+bi) * (c+di) = (ac-bd) + (bc+ad)i</span></span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real * c2.m_real - c1.m_imag * c2.m_imag;</span><br><span class="line">    c.m_imag = c1.m_imag * c2.m_real + c1.m_real * c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载/运算符  (a+bi) / (c+di) = [(ac+bd) / (c²+d²)] + [(bc-ad) / (c²+d²)]i</span></span><br><span class="line">Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) / (<span class="built_in">pow</span>(c2.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c2.m_imag, <span class="number">2</span>));</span><br><span class="line">    c.m_imag = (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) / (<span class="built_in">pow</span>(c2.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c2.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载!=运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real += c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag += c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real -= c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag -= c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real = <span class="keyword">this</span>-&gt;m_real * c.m_real - <span class="keyword">this</span>-&gt;m_imag * c.m_imag;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag = <span class="keyword">this</span>-&gt;m_imag * c.m_real + <span class="keyword">this</span>-&gt;m_real * c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载/=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real = (<span class="keyword">this</span>-&gt;m_real*c.m_real + <span class="keyword">this</span>-&gt;m_imag*c.m_imag) / (<span class="built_in">pow</span>(c.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag = (<span class="keyword">this</span>-&gt;m_imag*c.m_real - <span class="keyword">this</span>-&gt;m_real*c.m_imag) / (<span class="built_in">pow</span>(c.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">25</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">4</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c5</span><span class="params">(<span class="number">34</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c6</span><span class="params">(<span class="number">80</span>, <span class="number">90</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    Complex c7 = c1 + c2;</span><br><span class="line">    Complex c8 = c1 - c2;</span><br><span class="line">    Complex c9 = c1 * c2;</span><br><span class="line">    Complex c10 = c1 / c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c7 = "</span>&lt;&lt;c7.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c7.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c8 = "</span>&lt;&lt;c8.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c8.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c9 = "</span>&lt;&lt;c9.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c9.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c10 = "</span>&lt;&lt;c10.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c10.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    c3 += c1;</span><br><span class="line">    c4 -= c2;</span><br><span class="line">    c5 *= c2;</span><br><span class="line">    c6 /= c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c3 = "</span>&lt;&lt;c3.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c3.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 = "</span>&lt;&lt;c4.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c4.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c5 = "</span>&lt;&lt;c5.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c5.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c6 = "</span>&lt;&lt;c6.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c6.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(c1 == c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 == c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c1 != c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 != c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>c7 = 35 + 55i<br>c8 = 15 + 15i<br>c9 = -450 + 850i<br>c10 = 1.9 + -0.3i<br>c3 = 26 + 37i<br>c4 = -6 + -11i<br>c5 = 220 + 4460i<br>c6 = 5.2 + 1.592i<br>c1 != c2   </p></blockquote><p>需要注意的是，我们以全局函数的形式重载了 +、-、*、/、==、!=，以成员函数的形式重载了 +=、-=、*=、/=，而且应该坚持这样做，不能一股脑都写作成员函数或者全局函数</p><h2 id="C-重载-gt-gt-和-lt-lt-（输入和输出运算符）详解"><a href="#C-重载-gt-gt-和-lt-lt-（输入和输出运算符）详解" class="headerlink" title="C++重载&gt;&gt;和&lt;&lt;（输入和输出运算符）详解"></a>C++重载&gt;&gt;和&lt;&lt;（输入和输出运算符）详解</h2><ul><li>重载输入运算符&gt;&gt;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, <span class="built_in">complex</span> &amp;A)&#123;</span><br><span class="line">    in &gt;&gt; A.m_real &gt;&gt; A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们以全局函数的形式重载&gt;&gt;，使它能够读入两个 double 类型的数据，并分别赋值给复数的实部和虚部：</p><p>istream 表示输入流，cin 是 istream 类的对象，只不过这个对象是在标准库中定义的。<strong>之所以返回 istream 类对象的引用，是为了能够连续读取复数</strong>，让代码书写更加漂亮，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> c1, c2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c1&gt;&gt;c2;</span><br></pre></td></tr></table></figure><p>如果不返回引用，那就只能一个一个地读取了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> c1, c2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c1;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c2;</span><br></pre></td></tr></table></figure><p>当输入 1.45 2.34↙ 后，这两个小数就分别成为对象 c 的实部和虚部了。</p><blockquote><p>cin&gt;&gt; c;</p></blockquote><p>这一语句其实可以理解为：</p><blockquote><p>operator&lt;&lt;(cin , c);</p></blockquote><ul><li>重载输出运算符&lt;&lt;</li></ul><p>同样地，我们也可以模仿上面的形式对输出运算符&gt;&gt;进行重载，让它能够输出复数，请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="built_in">complex</span> &amp;A)&#123;</span><br><span class="line">    out &lt;&lt; A.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; A.m_imag &lt;&lt;<span class="string">" i "</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ostream 表示输出流，cout 是 ostream 类的对象。由于采用了引用的方式进行参数传递，并且也返回了对象的引用，所以重载后的运算符可以实现连续输出。</p><p>为了能够直接访问 complex 类的 private 成员变量，同样需要将该函数声明为 complex 类的友元函数：</p><blockquote><p>friend ostream &amp; operator&lt;&lt;(ostream &amp;out, complex &amp;A);</p></blockquote><p>综合演示:</p><p>结合输入输出运算符的重载，重新实现 complex 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in, <span class="built_in">complex</span> &amp; A);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; out, <span class="built_in">complex</span> &amp; A);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载加法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real + B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag + B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载减法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real - B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag - B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载乘法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real * B.m_real - A.m_imag * B.m_imag;</span><br><span class="line">    C.m_imag = A.m_imag * B.m_real + A.m_real * B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载除法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    <span class="keyword">double</span> square = A.m_real * A.m_real + A.m_imag * A.m_imag;</span><br><span class="line">    C.m_real = (A.m_real * B.m_real + A.m_imag * B.m_imag)/square;</span><br><span class="line">    C.m_imag = (A.m_imag * B.m_real - A.m_real * B.m_imag)/square;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输入运算符</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in, <span class="built_in">complex</span> &amp; A)&#123;</span><br><span class="line">    in &gt;&gt; A.m_real &gt;&gt; A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输出运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; out, <span class="built_in">complex</span> &amp; A)&#123;</span><br><span class="line">    out &lt;&lt; A.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; A.m_imag &lt;&lt;<span class="string">" i "</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">complex</span> c1, c2, c3;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c1&gt;&gt;c2;</span><br><span class="line"> </span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 + c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c3 = c1 - c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 - c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c3 = c1 * c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 * c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c3 = c1 / c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 / c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>2.4 3.6↙<br>4.8 1.7↙<br>c1 + c2 = 7.2 + 5.3 i<br>c1 - c2 = -2.4 + 1.9 i<br>c1 * c2 = 5.4 + 21.36 i<br>c1 / c2 = 0.942308 + 0.705128 i   </p></blockquote><h2 id="C-重载-（下标运算符"><a href="#C-重载-（下标运算符" class="headerlink" title="C++重载[]（下标运算符)"></a>C++重载[]（下标运算符)</h2><p>C++ 规定，下标运算符[ ]必须以成员函数的形式进行重载。该重载函数在类中的声明格式如下：</p><blockquote><p>返回值类型 &amp; operator[ ] (参数);</p></blockquote><p>或者：</p><blockquote><p>const 返回值类型 &amp; operator[ ] (参数) const;</p></blockquote><p>使用第一种声明方式，[ ]不仅可以访问元素，还可以修改元素。使用第二种声明方式，[ ]只能访问而不能修改元素。在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为通过 const 对象只能调用 const 成员函数，如果不提供第二种形式，那么将无法访问 const 对象的任何元素。</p><p>下面我们通过自定义的 Array 类来实现变长数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> length = <span class="number">0</span>);</span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;  <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> *m_p;  <span class="comment">//指向数组内存的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> length): m_length(length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">        m_p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m_p = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Array::display</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == m_length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;m_p[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;m_p[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="function">Array <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = A.length(); i &lt; len; i++)&#123;</span><br><span class="line">        A[i] = i * <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A.<span class="built_in">display</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">const</span> Array <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;B[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问最后一个元素</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>5↙<br>0, 5, 10, 15, 20<br>33685536   </p></blockquote><p>重载[ ]运算符以后，表达式arr[i]会被转换为：</p><blockquote><p>arr.operator<a href="i"> </a>;</p></blockquote><p>需要说明的是，B 是 const 对象，如果 Array 类没有提供 const 版本的operator[ ]，那么第 60 行代码将报错。虽然第 60 行代码只是读取对象的数据，并没有试图修改对象，但是它调用了非 const 版本的operator[ ]，编译器不管实际上有没有修改对象，只要是调用了非 const 的成员函数，编译器就认为会修改对象（至少有这种风险）。</p><h2 id="C-重载-和–（自增和自减运算符）"><a href="#C-重载-和–（自增和自减运算符）" class="headerlink" title="C++重载++和–（自增和自减运算符）"></a>C++重载++和–（自增和自减运算符）</h2><p>自增++和自减–都是一元运算符，它的前置形式和后置形式都可以被重载。如下例所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//秒表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stopwatch</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stopwatch(): m_min(<span class="number">0</span>), m_sec(<span class="number">0</span>)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setzero</span><span class="params">()</span></span>&#123; m_min = <span class="number">0</span>; m_sec = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">stopwatch <span class="title">run</span><span class="params">()</span></span>;  <span class="comment">// 运行</span></span><br><span class="line">    stopwatch <span class="keyword">operator</span>++();  <span class="comment">//++i，前置形式</span></span><br><span class="line">    stopwatch <span class="keyword">operator</span>++(<span class="keyword">int</span>);  <span class="comment">//i++，后置形式</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;( ostream &amp;, <span class="keyword">const</span> stopwatch &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_min;  <span class="comment">//分钟</span></span><br><span class="line">    <span class="keyword">int</span> m_sec;  <span class="comment">//秒钟</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">stopwatch <span class="title">stopwatch::run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ++m_sec;</span><br><span class="line">    <span class="keyword">if</span>(m_sec == <span class="number">60</span>)&#123;</span><br><span class="line">        m_min++;</span><br><span class="line">        m_sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopwatch stopwatch::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopwatch stopwatch::<span class="keyword">operator</span>++(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    stopwatch s = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;( ostream &amp; out, <span class="keyword">const</span> stopwatch &amp; s)&#123;</span><br><span class="line">    out&lt;&lt;setfill(<span class="string">'0'</span>)&lt;&lt;setw(<span class="number">2</span>)&lt;&lt;s.m_min&lt;&lt;<span class="string">":"</span>&lt;&lt;setw(<span class="number">2</span>)&lt;&lt;s.m_sec;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stopwatch s1, s2;</span><br><span class="line"></span><br><span class="line">    s1 = s2++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s1: "</span>&lt;&lt; s1 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s2: "</span>&lt;&lt; s2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    s1.setzero();</span><br><span class="line">    s2.setzero();</span><br><span class="line"></span><br><span class="line">    s1 = ++s2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s1: "</span>&lt;&lt; s1 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s2: "</span>&lt;&lt; s2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>s1: 00:00<br>s2: 00:01<br>s1: 00:01<br>s2: 00:01   </p></blockquote><p>上面的代码定义了一个简单的秒表类，m_min 表示分钟，m_sec 表示秒钟，setzero() 函数用于秒表清零，run() 函数是用来描述秒针前进一秒的动作，接下来是三个运算符重载函数。</p><p>先来看一下 run() 函数的实现，run() 函数一开始让秒针自增，如果此时自增结果等于60了，则应该进位，分钟加1，秒针置零。</p><p>operator++() 函数实现自增的前置形式，直接返回 run() 函数运行结果即可。</p><p>operator++ (int n) 函数实现自增的后置形式，返回值是对象本身，但是之后再次使用该对象时，对象自增了，所以在该函数的函数体中，先将对象保存，然后调用一次 run() 函数，之后再将先前保存的对象返回。在这个函数中参数n是没有任何意义的，它的存在只是为了区分是前置形式还是后置形式。</p><p>自减运算符的重载与上面类似</p><h2 id="C-重载"><a href="#C-重载" class="headerlink" title="C++重载()"></a>C++重载()</h2><p>在 C++ 中，类型的名字（包括类的名字）本身也是一种运算符，即类型强制转换运算符。</p><p>类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。经过适当重载后，(类型名)对象这个对对象进行强制类型转换的表达式就等价于 <kbd>对象.operator 类型名()</kbd> ，即变成对运算符函数的调用。</p><p>下面的程序对 double 类型强制转换运算符进行了重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) :real(r), imag(i) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> real; &#125;  <span class="comment">//重载强制类型转换运算符 double</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1.2</span>, <span class="number">3.4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">double</span>)c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1.2</span></span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">2</span> + c;  <span class="comment">//等价于 double n = 2 + c. operator double()</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;  <span class="comment">//输出 3.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序的输出结果是：<br>1.2<br>3.2   </p></blockquote><p>第 8 行对 double 运算符进行了重载。重载强制类型转换运算符时，不需要指定返回值类型，因为返回值类型是确定的，就是运算符本身代表的类型，在这里就是 double。</p><p>重载后的效果是，第 13 行的 (double)c 等价于 c.operator double()。</p><p>有了对 double 运算符的重载，在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用。</p><p>例如第 14 行，编译器认为本行中c这个位置如果出现的是 double 类型的数据，就能够解释得通，而 Complex 类正好重载了 double 运算符，因而本行就等价于：</p><blockquote><p>double n = 2 + c.operator double();</p></blockquote><h2 id="C-运算符重载注意事项以及汇总"><a href="#C-运算符重载注意事项以及汇总" class="headerlink" title="C++运算符重载注意事项以及汇总"></a>C++运算符重载注意事项以及汇总</h2><p>在 C++ 中进行运算符重载时，有以下问题需要注意：</p><ul><li>重载后运算符的含义应该符合原有用法习惯。例如重载+运算符，完成的功能就应该类似于做加法，在重载的+运算符中做减法是不合适的。此外，重载应尽量保留运算符原有的特性。</li><li>C++ 规定，运算符重载不改变运算符的优先级。</li><li>以下运算符不能被重载：<kbd>.</kbd>、<kbd>.*</kbd>、<kbd>::</kbd>、<kbd>? :</kbd>、<kbd>sizeof</kbd>。</li><li>重载运算符<kbd>()</kbd>、<kbd>[]</kbd>、<kbd>-></kbd>、或者赋值运算符<kbd>=</kbd>时，只能将它们重载为成员函数，不能重载为全局函数。</li></ul><p>运算符重载的实质是将运算符重载为一个函数，使用运算符的表达式就被解释为对重载函数的调用。</p><p>运算符可以重载为全局函数。此时函数的参数个数就是运算符的操作数个数，运算符的操作数就成为函数的实参。</p><p>运算符也可以重载为成员函数。此时函数的参数个数就是运算符的操作数个数减一，运算符的操作数有一个成为函数作用的对象，其余的成为函数的实参。</p><p>必要时需要重载赋值运算符=，以避免两个对象内部的指针指向同一片存储空间。</p><p>运算符可以重载为全局函数，然后声明为类的友元。</p><p>&lt;&lt; 和 &gt;&gt;是在 iostream 中被重载，才成为所谓的“流插入运算符”和“流提取运算符”的。</p><p>类型的名字可以作为强制类型转换运算符，也可以被重载为类的成员函数。它能使得对象被自动转换为某种类型。</p><p>自增、自减运算符各有两种重载方式，用于区别前置用法和后置用法。</p><p>运算符重载不改变运算符的优先级。重载运算符时，应该尽量保留运算符原本的特性。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 运算符重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串操作</title>
      <link href="/2020/05/06/c-string/"/>
      <url>/2020/05/06/c-string/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h2><p>有了 string 类，我们可以使用 <strong>+</strong> 或 <strong>+=</strong> 运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的 strcat()、strcpy()、malloc() 等函数来拼接字符串了，再也不用担心空间不够会溢出了。</p><p>用+来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个字符数组，或者是一个 string 字符串和一个单独的字符。请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first "</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"second "</span>;</span><br><span class="line">    <span class="keyword">char</span> *s3 = <span class="string">"third "</span>;</span><br><span class="line">    <span class="keyword">char</span> s4[] = <span class="string">"fourth "</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'@'</span>;</span><br><span class="line">    <span class="built_in">string</span> s5 = s1 + s2;</span><br><span class="line">    <span class="built_in">string</span> s6 = s1 + s3;</span><br><span class="line">    <span class="built_in">string</span> s7 = s1 + s4;</span><br><span class="line">    <span class="built_in">string</span> s8 = s1 + ch;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s5&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s6&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s7&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s8&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果:<br> first second<br> first third<br> first fourth<br> first @</p></blockquote><h2 id="string-字符串的增删改查"><a href="#string-字符串的增删改查" class="headerlink" title="string 字符串的增删改查"></a>string 字符串的增删改查</h2><p>C++ 提供的 string 类包含了若干实用的成员函数，大大方便了字符串的增加、删除、更改、查询等操作。</p><h3 id="一-插入字符串"><a href="#一-插入字符串" class="headerlink" title="一. 插入字符串"></a>一. 插入字符串</h3><p>insert() 函数可以在 string 字符串中指定的位置插入另一个字符串，它的一种原型为：</p><figure class="highlight plain"><figcaption><span>insert (size_t pos, const string& str);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;pos 表示要插入的位置，也就是下标；str 表示要插入的字符串，它可以是 string 字符串，也可以是C风格的字符串。</span><br><span class="line"></span><br><span class="line">请看下面的代码：</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 &#x3D; s2 &#x3D; &quot;1234567890&quot;;</span><br><span class="line">    s3 &#x3D; &quot;aaa&quot;;</span><br><span class="line">    s1.insert(5, s3);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    s2.insert(5, &quot;bbb&quot;);</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>12345aaa67890<br>12345bbb67890</p></blockquote><p>insert() 函数的第一个参数有越界的可能，如果越界，则会产生运行时异常。</p><h3 id="二-删除字符串"><a href="#二-删除字符串" class="headerlink" title="二. 删除字符串"></a>二. 删除字符串</h3><p>erase() 函数可以删除 string 中的一个子字符串。它的一种原型为：</p><figure class="highlight plain"><figcaption><span>erase (size_t pos </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;pos 表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len &#x3D; str.length - pos）。</span><br><span class="line"></span><br><span class="line">请看下面的代码：</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 &#x3D; s2 &#x3D; s3 &#x3D; &quot;1234567890&quot;;</span><br><span class="line">    s2.erase(5);</span><br><span class="line">    s3.erase(5, 3);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s3 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>1234567890<br>12345<br>1234590</p></blockquote><p>可能会有这样的担心，在 pos 参数没有越界的情况下， len 参数也可能会导致要删除的子字符串越界。但实际上这种情况不会发生，erase() 函数会从以下两个值中取出最小的一个作为待删除子字符串的长度：</p><blockquote><p>len 的值<br>字符串长度减去 pos 的值。</p></blockquote><p>说得简单一些，待删除字符串最多只能删除到字符串结尾。</p><h3 id="三-提取子字符串"><a href="#三-提取子字符串" class="headerlink" title="三. 提取子字符串"></a>三. 提取子字符串</h3><p>substr() 函数用于从 string 字符串中提取子字符串，它的原型为：</p><figure class="highlight plain"><figcaption><span>substr (size_t pos </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。</span><br><span class="line"></span><br><span class="line">请看下面的代码：</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1 &#x3D; &quot;first second third&quot;;</span><br><span class="line">    string s2;</span><br><span class="line">    s2 &#x3D; s1.substr(6, 6);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br> first second third<br> second</p></blockquote><p>系统对 substr() 参数的处理和 erase() 类似：</p><ul><li>如果 pos 越界，会抛出异常；</li><li>如果 len 越界，会提取从 pos 到字符串结尾处的所有字符。</li></ul><h3 id="四-字符串查找"><a href="#四-字符串查找" class="headerlink" title="四. 字符串查找"></a>四. 字符串查找</h3><p>string 类提供了几个与字符串查找有关的函数，如下所示。<br><strong>1)  find() 函数</strong><br>find() 函数用于在 string 字符串中查找子字符串出现的位置，它其中的两种原型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t find (const string&amp; str, size_t pos &#x3D; 0) const;  </span><br><span class="line">size_t find (const char* s, size_t pos &#x3D; 0) const;</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。</p></blockquote><p>请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first second third"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"second"</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.<span class="built_in">find</span>(s2,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.length())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Found at index : "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Found at index : 6</p></blockquote><p>find() 函数最终返回的是子字符串第一次出现在字符串中的起始下标。本例最终是在下标6处找到了 s2 字符串。如果没有查找到子字符串，那么会返回一个无穷大值 4294967295。</p><p><strong>2) rfind() 函数</strong>   </p><p>rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。</p><p>请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first second third"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"second"</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.rfind(s2,<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.length())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Found at index : "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Found at index : 6   </p></blockquote><p><strong>3) find_first_of() 函数</strong>  </p><p><strong>find_first_of()</strong> 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first second second third"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"asecond"</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.find_first_of(s2);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.length())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Found at index : "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Found at index : 3</p></blockquote><p>本例中 s1 和 s2 共同具有的字符是 ’s’，该字符在 s1 中首次出现的下标是3，故查找结果返回3。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表总结</title>
      <link href="/2020/05/04/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/04/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><strong>链表的定义（来自维基百科）</strong>：</p><p>在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（“links”）。</p><p><strong>链表与顺序表的区别（来自维基百科）</strong>：</p><p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p><p><strong>顺序表与数组的区别</strong>：</p><p>顺序表是在计算机内存中以数组的形式保存的线性表。</p><p>顺序表是指用一组地址连续的存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表，顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。线性表采用指针链接的方式存储就称之为链表。</p><p>线性表是从逻辑结构的角度来说的，除了头和尾之外，它的每一个元素都只有一个前驱元素和一个后驱元素。各种队列（单向、双向、循环队列），栈等都是线性表的不同例子。</p><p>而数组是从物理存贮的角度来说的，线性表可以用数组存贮也可以用链表来存贮。同样的队列和栈也可以用数组和链表存贮，各有利弊。具体使用时，根据具体情况选择。 </p><p>所以说，数组是一个更大的概念。使用数组，不但可以存储线性表，也可存储非线性结构的数据结构。比如堆、完全二叉树、乃至于其它类型的树、图等。</p><p>顺序表与数组都是数据结构，只是描述角度不同。顺序表是从逻辑结构的角度来说的，它的每一个元素都只有一个前驱元素和一个后驱元素除了头和尾，逻辑结构还有队列，堆栈，树，图等。而数组是从物理存贮的角度来说的，顺序表用数组存贮也可以用链表来存贮。同样的队列也可以用数组和链表存贮，各有利弊。具体使用时，根据具体情况选择。</p><blockquote><ol><li>数组就是相同数据类型的元素按一定顺序排列的集合。</li></ol><p>一句话：就是物理上存储在一组联系的地址上。也称为数据结构中的物理结构。</p><ol start="2"><li>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。</li></ol><p>一句话：线性表是数据结构中的逻辑结构。可以存储在数组上，也可以存储在链表上。</p><ol start="3"><li>线性表的结点按逻辑次序依次存放在一组地址连续的存储单元里的方法。用顺序存储方法存储的线性表简称为顺序表。</li></ol><p>一句话：用数组来存储的线性表就是顺序表。</p></blockquote><p><strong>链表的优缺点（来自维基百科）</strong>：</p><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。<br>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p><p><strong>链表的类型（来自维基百科）</strong>：</p><p>单向链表，双向链表以及循环链表。</p><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p><strong>单向链表的定义：</strong></p><p>单向链表是链表类型中最为简单的一种，每个节点包含两个域，一个数据域(data)，一个指针域(next)。单向链表的next节点指向下一节点，而尾节点的next节点为空。</p><p><strong>单向链表节点的定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504153648.png" alt="20200504153648"></p><p><strong>单链表的模板：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListForward</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode* head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyListForward():head(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获得链表中第index个节点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p)<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果为第index节点值为空值则返回-1；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、在链表头部插一个值为val的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode *p=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        p-&gt;next=head;</span><br><span class="line">        head=p;<span class="comment">//更换头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、在链表尾部添加一个值为val的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode *p=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="comment">//链表为空，直接将新节点作为头节点</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head=p;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *q=head;</span><br><span class="line">        <span class="comment">//遍历直到q的next节点为空</span></span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next)&#123;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、在索引为index的节点之前添加值为val的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="comment">//1、index小于等于0，直接在头部插入节点</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">//若index小于等于0，我们仅需要在头节点前面插入新节点就行了</span></span><br><span class="line">        <span class="comment">//注意这里不能使用指针p，因为p=node时，p所指向的地址发生了变化，head指向的地址没有变化，所以我们这里要使用指针head</span></span><br><span class="line">            node-&gt;next=head;</span><br><span class="line">            head=node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="comment">//在索引为index的节点之前插入新节点，我们需要找到它的前驱节点，然后插入在它的前驱节点后面</span></span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、p为索引节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next=p-&gt;next;</span><br><span class="line">            p-&gt;next=node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、删除索引为index的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、index为0，我们直接删除head节点</span></span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>&amp;&amp;head!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *del=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="comment">//删除索引为index的节点，我们需要找到它的前驱节点p，p-&gt;next为需要删除节点</span></span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、index超过链表范围，删除失败</span></span><br><span class="line">        <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//3、index的位置合法，我们找到需要删除的p-&gt;next节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *del=p-&gt;next;</span><br><span class="line">            p-&gt;next=del-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、清空链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ListNode *del=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            del=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyListForward mlf;</span><br><span class="line">    mlf.addAtIndex(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    mlf.addAtIndex(<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">    mlf.addAtIndex(<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mlf.length();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mlf.<span class="built_in">get</span>(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    mlf.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;mlf.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><strong>双向链表的定义：</strong></p><p>双向链表是一种更为复杂的链表，每个节点包含三个域，一个数据域(data)和两个指针域(prev、next)，其中数据域存放节点的数值，prev指向该节点的前一个节点，next指向该节点的后一个节点。</p><p><strong>双向链表节点的定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next,*prev;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>),prev(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504155110.png" alt="20200504155110"></p><p><strong>双向链表的模板：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *next,*prev;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>),prev(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//头节点尾节点都为空，表示为空链表</span></span><br><span class="line">    ListNode *head,*tail;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyList():<span class="built_in">size</span>(<span class="number">0</span>),head(<span class="literal">nullptr</span>),tail(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获得索引为index的节点值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p)<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、在头部插入值为val的新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            node-&gt;next=head;</span><br><span class="line">            head-&gt;prev=node;</span><br><span class="line">            head=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            tail=head;</span><br><span class="line">        &#125;</span><br><span class="line">        ++<span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、在尾部插入值为val的新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            node-&gt;prev=tail;</span><br><span class="line">            tail-&gt;next=node;</span><br><span class="line">            tail=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//尾节点为空，那么头节点也为空，然后首尾节点都为新节点</span></span><br><span class="line">            tail=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            head=tail;</span><br><span class="line">        &#125;</span><br><span class="line">        ++<span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、在index之前添加值为val的新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先排除三种特殊情况的index，然后剩下来的index肯定在链表内</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="built_in">size</span>)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;<span class="built_in">size</span>)<span class="keyword">return</span>;</span><br><span class="line">        ListNode *p=<span class="literal">nullptr</span>,*cur=head;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur&amp;&amp;i&lt;index)&#123;</span><br><span class="line">            p=cur;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="comment">//由于前面已经将特殊情况的index排除了，现在的p和cur都有效，都在链表内</span></span><br><span class="line">        p-&gt;next=node;</span><br><span class="line">        node-&gt;prev=p;</span><br><span class="line">        node-&gt;next=cur;</span><br><span class="line">        cur-&gt;prev=node;</span><br><span class="line">        <span class="built_in">size</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、删除索引为index的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//链表为空时，不能删除</span></span><br><span class="line">        <span class="keyword">if</span>(!head)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *del=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(head)&#123;<span class="comment">//链表有2个以上节点</span></span><br><span class="line">                head-&gt;prev=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//链表只有一个节点，将尾部制空</span></span><br><span class="line">                tail=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">            <span class="built_in">size</span>--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//index为最后为尾节点，我们需要删除尾节点</span></span><br><span class="line">        <span class="keyword">if</span>(index==<span class="built_in">size</span><span class="number">-1</span>)&#123;</span><br><span class="line">            ListNode *del=tail;</span><br><span class="line">            tail=tail-&gt;prev;</span><br><span class="line">            <span class="comment">//注意这里不用处理tail为空，因为tail为空的话，那么链表只有单个节点</span></span><br><span class="line">            <span class="comment">//然而单个节点只能删除0号节点，只有index为0时才能删除，前面已经处理过了index为0的情况了，所以这里不在处理</span></span><br><span class="line">            <span class="keyword">if</span>(tail)&#123;</span><br><span class="line">                tail-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">            <span class="built_in">size</span>--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=<span class="literal">nullptr</span>,*cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==index)&#123;</span><br><span class="line">                ListNode *del=cur;</span><br><span class="line">                p-&gt;next=cur-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next)&#123;</span><br><span class="line">                    cur-&gt;next-&gt;prev=p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> del;</span><br><span class="line">                <span class="built_in">size</span>--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=cur;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、获得链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、清空链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">size</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            deleteAtIndex(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyList ml;</span><br><span class="line">    ml.addAtHead(<span class="number">1</span>);</span><br><span class="line">    ml.addAtTail(<span class="number">3</span>);</span><br><span class="line">    ml.addAtHead(<span class="number">4</span>);</span><br><span class="line">    ml.addAtHead(<span class="number">5</span>);</span><br><span class="line">    ml.addAtIndex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ml.length();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ml.<span class="built_in">get</span>(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ml.deleteAtIndex(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ml.length();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ml.<span class="built_in">get</span>(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ml.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ml.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p><strong>环形链表的定义：</strong></p><p>循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存， 假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。<br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504155514.png" alt="20200504155514"></p><h1 id="习题解析"><a href="#习题解析" class="headerlink" title="习题解析"></a>习题解析</h1><h2 id="链表中的双指针技巧"><a href="#链表中的双指针技巧" class="headerlink" title="链表中的双指针技巧"></a>链表中的双指针技巧</h2><p><a href="https://xiaoneng.blog.csdn.net/article/details/97423144" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a>：<strong>快慢指针法</strong>，起始快指针走n步后，若此时快指针已为空，表示我们删除第一个节点，直接返回head-&gt;next即可；否则此时快慢指针一起走，也就是慢指针走size-n步到达倒数第N个节点的前驱节点，快指针会到达链表的尾节点，此时我们删除slow-&gt;next节点即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103322178" target="_blank" rel="noopener">86. 分隔链表</a>：<strong>双指针法</strong>，before_head链表存放比x小的节点，after_head链表存放比x大于或等于的节点，我们分别用before和after来前面两个链表添加节点，用head来遍历原始链表。当原始链表遍历完成时，我们需要将before_head链表连接上after_head链表，即before-&gt;next=after_head-&gt;next;after-&gt;next=nullptr;。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/103648554" target="_blank" rel="noopener">92. 反转链表 II</a>：<strong>双指针法</strong>，指针pre指针指向m的前驱节点，用来将cur的next节点插入到pre后面，指针cur指向位置m起始节点，该节点保持不变，每次需要将cur连接上nxt后边的部分。换句话说，我们要将[m+1,n]的节点每次都要插到位置m之前，这样就完成了反转。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97416410" target="_blank" rel="noopener">141. 环形链表</a>：<strong>快慢指针法</strong>，若存在环最终快慢指针会相遇；若不存在环，那么快指针一定会先走到链表尾部。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97420675" target="_blank" rel="noopener">142. 环形链表 II</a>：<strong>快慢指针法</strong>，首先利用141的代码判断是否存在环，然后相遇之后将fast指针指向头节点，然后fast和slow现在开始每次走一步，相遇点就是环的入口。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103588663" target="_blank" rel="noopener">143. 重排链表</a>：<strong>首尾指针法</strong>，首先将原始链表的每一个节点存放在一个数组中，然后我们取首尾指针向中间遍历，每次循环我们需要将左指针的节点连上右指针的节点，在节点连上之后，我们需要将右指针连上未排序的首节点。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97421357" target="_blank" rel="noopener">160. 相交链表</a>：本题也属于<strong>快慢指针法</strong>，具体思路更抽象的说就是将链表AB分别变成了A-&gt;B和B-&gt;A（这里假设A更短一点），这里我们用ha遍历A-&gt;B，hb遍历B-&gt;A，然后ha指针先走到A-B的B部分，hb指针还在走在B-A的B部分，当hb走到B-A的A部分时，最终二者会相遇，而相遇部分就是公共部分。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103445269" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a>：<strong>快慢指针法</strong>，用两个指针，一块一慢，快的每次走两步，慢的每次走一步，这样当快指针遍历结束时，慢指针指向的也就是链表的中间位置。这时候把中间位置的节点的值作为二叉搜索树根节点的值。因为二叉搜索树对应的就是一个有序数组，根节点对应的元素值为为有序数组最中间的位置。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/100934558" target="_blank" rel="noopener">206. 反转链表</a>：<strong>双指针法</strong>，指针pre用来表示前驱节点，指针cur用来遍历链表，每次循环改变将pre-&gt;cur的方向改变为pre&lt;-cur，直到遍历结束。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/104034708" target="_blank" rel="noopener">234. 回文链表</a>：<strong>快慢指针法</strong>，快指针走两步，慢指针走一步，找到链表的中点。然后，翻转后半部分。最后从前半部分链表和后半部分链表是否相同。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103995590" target="_blank" rel="noopener">876. 链表的中间结点</a>：<strong>快慢指针法</strong>，快指针走两步，慢指针走一步，等快指针走到链表尾节点时，慢指针的位置就是中位数的位置。</p><h2 id="链表排序问题"><a href="#链表排序问题" class="headerlink" title="链表排序问题"></a>链表排序问题</h2><p><a href="https://blog.csdn.net/qq_43152052/article/details/103662802" target="_blank" rel="noopener">147. 对链表进行插入排序</a>：<strong>插入排序</strong>，我们每次用head-&gt;next来进行插入排序，每次插入排序，我们需要从链表的头部开始寻找插入点，所以我们使用一个指针pre来寻找插入点，若pre-&gt;next的节点值大于等于head-&gt;next的节点时，我们的插入位置就是pre-&gt;next，这里处理起来可能麻烦点，大家仔细看代码即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103661851" target="_blank" rel="noopener">148. 排序链表</a>：<strong>归并排序</strong>，先2个2个的 merge，完成一趟后，再 4个4个的 merge，直到结束。</p><h2 id="链表经典题目"><a href="#链表经典题目" class="headerlink" title="链表经典题目"></a>链表经典题目</h2><p><a href="https://blog.csdn.net/qq_43152052/article/details/89285335" target="_blank" rel="noopener">2. 两数相加</a>：<strong>模拟题</strong>，由于链表是逆序存放数字的，所以链表数字从左至右低位对低位，高位对高位，因此我们从左至右遍历两个链表模拟加法运算即可，注意向高位进位。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97426128" target="_blank" rel="noopener">21. 合并两个有序链表</a>：<strong>模拟题</strong>，每次循环比较l1-&gt;val和l2-&gt;val，若l1-&gt;val<l2->val，则在cur后面添加l1；否则在cur后面添加l2。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103183470" target="_blank" rel="noopener">23. 合并K个排序链表</a>：<strong>方法1：分治法</strong>，将k个链表利用二分分为k个独立子链表，然后两两进行合并，最后形成一个排序链表。<strong>方法2：优雅的暴力法</strong>，利用队列queue来实现两两链表的组合，首先将队列前两个链表合并成一个，然后添加到队列的尾部，直到队列中只有一个链表时，表示k个链表已经合成了。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/100888248" target="_blank" rel="noopener">24. 两两交换链表中的节点</a>：<strong>简单递归</strong>，每次递归交换head与nxt即可，也就是完成了两两交换链表中的节点。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103324877" target="_blank" rel="noopener">25. K 个一组翻转链表</a>：<strong>分治法</strong>，将链表按长度k进行分组，然后每次翻转长度k的链表，注意翻转了长度k的链表后新链表的尾部还要连接未翻转部分。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/89366849" target="_blank" rel="noopener">61. 旋转链表</a>：<strong>模拟题</strong>，先求出链表长度size，若k取余size为空，那么不用旋转了，直接返回head；否则将链表首尾相连形成环形链表，由于k表示尾节点移动k%size位，那么头节点移动size-k%size位。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103544889" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a>：<strong>模拟题</strong>，遍历链表，若head的节点值与head的next节点值不相等，则pre指向head，也就是不重复节点；若相等，我们需要找到重复值子链表的最后一个节点，然后令pre指向head-&gt;next，同时head移动到下一个节点。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103533398" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a>：<strong>模拟题</strong>，直接遍历链表，遇到重复值的节点删除即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/89323912" target="_blank" rel="noopener">138. 复制带随机指针的链表</a>：<strong>模拟题</strong>，分三步，第一步在原链表的每个节点后面拷贝出一个新的节点，第二步拷贝random，第三步断开链表。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/104033912" target="_blank" rel="noopener">203. 移除链表元素</a>：<strong>模拟题</strong>，直接遍历链表确定是否删除节点即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103996408" target="_blank" rel="noopener">445. 两数相加 II</a>：<strong>双栈法</strong>，将两个链表节点值全部压入栈中，然后每次去栈顶元素进行相加，因为这样保证了低位和低位相加，不会出现错位现象。最后直到两个栈为空且进位为0为止，就表示相加完成了。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103995776" target="_blank" rel="noopener">725. 分隔链表</a>：<strong>模拟题</strong>，首先求出链表的长度，然后根据k来求得每段链表的平均长度，顺便求出余数。由于题目要求每部分长度相差不能超过1，而且排在前面的部分长度要大于后面部分的长度，所以我们根据余数的个数，给排在前面的部分长度+1。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/89304371" target="_blank" rel="noopener">430. 扁平化多级双向链表</a>：<strong>模拟题</strong>，迭代法，遍历链表，若发现该链表存在child节点那么就将[child,tail]这段子链表插入到当前节点的后面去，然后继续遍历链表。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103997681" target="_blank" rel="noopener">817. 链表组件</a>：<strong>模拟题</strong>，如果当前的节点在列表G中，并且下一个节点不在列表G中，我们就找到了一个组件的尾节点，将res加1。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103997711" target="_blank" rel="noopener">1171. 从链表中删去总和值为零的连续节点</a>：<strong>模拟题</strong>，直接遍历链表进行删除和为0的连续子链表。</p><blockquote><p>文章转载：<a href="https://xiaoneng.blog.csdn.net/article/details/104007259" target="_blank" rel="noopener">algsup</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0503leetcode</title>
      <link href="/2020/05/03/0503leetcode/"/>
      <url>/2020/05/03/0503leetcode/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0502leetcode</title>
      <link href="/2020/05/02/0502leetcode/"/>
      <url>/2020/05/02/0502leetcode/</url>
      
        <content type="html"><![CDATA[<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><center><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502162145.png" alt="20200502162145"></p></center><p><strong>解题思路：</strong></p><center><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502162430.png" alt="20200502162430"></p></center><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">           fast =fast-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">               fast = fast-&gt;next; </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//else break;</span></span><br><span class="line">           slow =slow-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">               <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(fast == head)</span><br><span class="line">                   <span class="keyword">return</span> fast;</span><br><span class="line">                   fast = fast-&gt;next;</span><br><span class="line">                   head = head-&gt;next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h3><center><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502164548.png" alt="20200502164548"></p></center><p><strong>解题思路：</strong></p><ol><li><p>为链表设置虚拟头结点<strong>dummyhead</strong>，链表设置虚拟头结点dummyhead，这样对链表来说，第一个元素就是dummyhead的next所对应的节点元素，而不是dummyhead所对应的节点元素。dummyhead位置所对应的元素是根本不存在的，这只是未来我们编写逻辑方便而出现的一个虚拟头结点。dummyhead就是索引为0的这个位置的元素的前一个节点。当我们有了dummyhead后，为链表添加一个元素，就不需要对头结点进行特殊处理了，只需要找到等待添加位置的前一个位置的节点，<strong>此时对于链表来说，所有位置都有前一个节点。</strong></p></li><li><p>代码主要分为两部分，一部分负责切割链接，另一部分负责将切割下来的链表反转并将链表头指针返回。</p></li><li><p>Tail的使用</p></li></ol><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502171941.png" alt="20200502171941"></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span> || head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* Tail = dummy;<span class="comment">//Tail是当前已经确定的尾部</span></span><br><span class="line">        <span class="comment">//ListNode* Head = head;//还没有确定的首部</span></span><br><span class="line">        ListNode* p=head;<span class="comment">//游标</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (count &lt; k)) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; k) &#123;<span class="comment">//如果小于k个，则用上一个模块的Tail直接连接首部就可以</span></span><br><span class="line">                Tail-&gt;next = head;</span><br><span class="line">                <span class="keyword">return</span> dummy-&gt;next;<span class="comment">//输出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果不小于k个，</span></span><br><span class="line">                Tail-&gt;next = reversegroup(head, k);<span class="comment">//更新已经确定的尾部</span></span><br><span class="line">                <span class="keyword">while</span> (Tail-&gt;next != <span class="literal">NULL</span>)Tail = Tail-&gt;next;<span class="comment">//更新Tail，把Tail更新到指向为空</span></span><br><span class="line">                head = p;<span class="comment">//更新没有确定的首部</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reversegroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;<span class="comment">//从abcd变成bcda</span></span><br><span class="line">        ListNode* cur;</span><br><span class="line">        ListNode* tail;<span class="comment">//当前已经完成翻转的链表的第一个节点</span></span><br><span class="line">        ListNode* ahead;<span class="comment">//存储旧链表中cur指向的节点</span></span><br><span class="line">        tail = <span class="literal">nullptr</span>;</span><br><span class="line">        cur = <span class="literal">nullptr</span>;</span><br><span class="line">        ahead = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; k) &#123;</span><br><span class="line">            cur = ahead;</span><br><span class="line">            ahead = cur-&gt;next;<span class="comment">//存储旧链表中cur指向的节点</span></span><br><span class="line">            cur-&gt;next = tail;<span class="comment">//指向已经完成翻转的链表的第一个节点</span></span><br><span class="line">            tail = cur;<span class="comment">//更新tail</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        ahead-&gt;next = tail;</span><br><span class="line">        <span class="keyword">return</span> ahead;<span class="comment">//返回小模块的第一个节点，用以作为连接外层循环Tail指向的对象</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/05/01/test/"/>
      <url>/2020/05/01/test/</url>
      
        <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1111111</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/%E5%88%86%E7%B1%BB-%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B.png" alt="分类-守望先锋"></p><table><thead><tr><th>流操纵算子</th><th>作  用</th><th></th></tr></thead><tbody><tr><td>*dec</td><td>以十进制形式输出整数</td><td rowspan="13">常用</td></tr><tr><td>hex</td><td>以十六进制形式输出整数</td><td></td></tr><tr><td>oct</td><td>以八进制形式输出整数</td><td></td></tr><tr><td>fixed</td><td>以普通小数形式输出浮点数</td><td></td></tr><tr><td>scientific</td><td>以科学计数法形式输出浮点数</td><td></td></tr><tr><td>left</td><td>左对齐，即在宽度不足时将填充字符添加到右边</td><td></td></tr><tr><td>*right</td><td>右对齐，即在宽度不足时将填充字符添加到左边</td><td></td></tr><tr><td>setbase(b)</td><td>设置输出整数时的进制，b=8、10 或 16</td><td></td></tr><tr><td>setw(w)</td><td>指定输出宽度为 w 个字符，或输人字符串时读入 w 个字符</td><td></td></tr><tr><td>setfill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td><td></td></tr><tr><td>setprecision(n)</td><td>设置输出浮点数的精度为 n。在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</td><td></td></tr><tr><td>setiosflags(flag)</td><td>将某个输出格式标志置为 1</td><td></td></tr><tr><td>resetiosflags(flag)</td><td>将某个输出格式标志置为 0</td><td></td></tr><tr><td>boolapha</td><td>把 true 和 false 输出为字符串</td><td rowspan="13">不常用</td></tr><tr><td>*noboolalpha</td><td>把 true 和 false 输出为 0、1</td><td></td></tr><tr><td>showbase</td><td>输出表示数值的进制的前缀</td><td></td></tr><tr><td>*noshowbase</td><td>不输出表示数值的进制.的前缀</td><td></td></tr><tr><td>showpoint</td><td>总是输出小数点</td><td></td></tr><tr><td>*noshowpoint</td><td>只有当小数部分存在时才显示小数点</td><td></td></tr><tr><td>showpos</td><td>在非负数值中显示 +</td><td></td></tr><tr><td>*noshowpos</td><td>在非负数值中不显示 +</td><td></td></tr><tr><td>*skipws</td><td>输入时跳过空白字符</td><td></td></tr><tr><td>noskipws</td><td>输入时不跳过空白字符</td><td></td></tr><tr><td>uppercase</td><td>十六进制数中使用 A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td><td></td></tr><tr><td>*nouppercase</td><td>十六进制数中使用 a~e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。</td><td></td></tr><tr><td>internal</td><td>数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/01/hello-world/"/>
      <url>/2020/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
