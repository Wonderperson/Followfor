<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode_300</title>
      <link href="/2020/06/21/letcode-300/"/>
      <url>/2020/06/21/letcode-300/</url>
      
        <content type="html"><![CDATA[<h1 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200621141044.png" alt="20200621141044"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>比较容易想到的是动态规划解法，时间复杂度 <code>O(N^2)</code>，我们借这个问题来由浅入深讲解如何找状态转移方程，如何写出动态规划解法。比较难想到的是利用二分查找，时间复杂度是<code>O(NlogN)</code>，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。</p><p>注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来设计动态规划算法解决这个问题.</p><h3 id="一、动态规划解法-🍕"><a href="#一、动态规划解法-🍕" class="headerlink" title="一、动态规划解法 🍕"></a>一、动态规划解法 🍕</h3><p>动态规划的核心设计思想是数学归纳法。</p><p>相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么<strong>我们先假设这个结论在 <code>k&lt;n</code> 时成立，然后根据这个假设，想办法推导证明出 <code>k=n</code> 的时候此结论也成立</strong>。如果能够证明出来，那么就说明这个结论对于 <code>k</code> 等于任何数都成立。</p><p>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 <code>dp[0...i-1]</code> 都已经被算出来了，然后问自己：怎么通过这些结果算出 <code>dp[i]</code>？</p><p>直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 <code>dp[i]</code> 的值到底代表着什么？</p><p>我们的定义是这样的：<code>dp[i]</code> 表示以 <code>nums[i]</code> 这个数结尾的最长递增子序列的长度。</p><p>根据这个定义，我们就可以推出 base case：<code>dp[i]</code> 初始值为 1，因为以 <code>nums[i]</code> 结尾的最长递增子序列起码要包含它自己。</p><p>举两个例子：</p><ol><li><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200621142101.png" alt="20200621142101"></p></li><li><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200621142201.png" alt="20200621142201"></p></li></ol><p>算法演进的过程是这样的：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F5cc98963f8fb1c6670adc17363d1dc75bff58c3a.gif?alt=media" alt="1"></p><p>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">    res = Math.max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>那我们应该怎么设计算法逻辑来正确计算每个 <code>dp[i]</code> 呢？</p><p><strong>假设我们已经知道了 <code>dp[0..4]</code> 的所有结果，我们如何通过这些已知结果推出 <code>dp[5]</code> 呢？</strong></p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200621142506.png" alt="20200621142506"></p><p>根据刚才我们对 <code>dp</code> 数组的定义，现在想求 <code>dp[5]</code> 的值，也就是想求以 <code>nums[5]</code> 为结尾的最长递增子序列。</p><p><strong><code>nums[5] = 3</code>，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</strong></p><p>显然，可能形成很多种新的子序列，但是我们只选择最长的那一个，把最长子序列的长度作为 <code>dp[5]</code> 的值即可。</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F47f8d07657dd4d10e65e07d45142547c569188fe.gif?alt=media" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[j]) </span><br><span class="line">        dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>i = 5</code> 时，这段代码的逻辑就可以算出 <code>dp[5]</code>。其实到这里，这道算法题我们就基本做完了。<code>dp[4]</code>, <code>dp[3]</code>我们依然可以按照数学归纳法算出。</p><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __max(a,b) (((a) &gt; (b)) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = __max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            res = __max(dp[i], res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二、二分查找解法"><a href="#二、二分查找解法" class="headerlink" title="二、二分查找解法"></a>二、二分查找解法</h3><p>这个解法的时间复杂度为 <code>O(NlogN)</code>，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。</p><p>根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。</p><p>为了简单起见，后文跳过所有数学证明，通过一个简化的例子来理解一下算法思路。</p><p>首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200621142915.png" alt="20200621142915"></p><p><strong>处理这些扑克牌要遵循以下规则：</strong></p><p>只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。</p><p>比如说上述的扑克牌最终会被分成这样 5 堆（我们认为纸牌 A 的牌面是最大的，纸牌 2 的牌面是最小的）。</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200621142941.png" alt="20200621142941"></p><p>为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q）</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200621143014.png" alt="20200621143014"></p><p>按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度，证明略。</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200621143039.png" alt="20200621143039"></p><p>我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是<strong>有序</strong>吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] top = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 牌堆数初始化为 0</span></span><br><span class="line">    <span class="keyword">int</span> piles = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 要处理的扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> poker = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***** 搜索左侧边界的二分查找 *****/</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = piles;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (top[mid] &gt; poker) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (top[mid] &lt; poker) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*********************************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到合适的牌堆，新建一堆</span></span><br><span class="line">        <span class="keyword">if</span> (left == piles) piles++;</span><br><span class="line">        <span class="comment">// 把这张牌放到牌堆顶</span></span><br><span class="line">        top[left] = poker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 牌堆数就是 LIS 长度</span></span><br><span class="line">    <span class="keyword">return</span> piles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，二分查找的解法也讲解完毕。</p><p>这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。</p><p>所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。</p><p>转载自<a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-she-ji-zui-chang-di-zeng-zi-xu-lie" target="_blank" rel="noopener">labuladong</a></p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200621143316.png" alt="20200621143316"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象分析与设计复习提纲</title>
      <link href="/2020/06/19/umllearn/"/>
      <url>/2020/06/19/umllearn/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#面向对象分析与设计复习提纲">面向对象分析与设计复习提纲</a><ul><li><a href="#第一章">第一章</a><ul><li><a href="#应用uml的三种方式">应用UML的三种方式</a></li><li><a href="#应用uml的三种透视图">应用UML的三种透视图</a></li><li><a href="#不同视图中类的含义">不同视图中类的含义</a></li></ul></li><li><a href="#第二章">第二章</a><ul><li><a href="#统一过程的特点">统一过程的特点</a></li><li><a href="#如何在迭代项目中处理变更">如何在迭代项目中处理变更</a></li><li><a href="#早起迭代跟后期迭代的特点">早起迭代跟后期迭代的特点</a></li><li><a href="#迭代开发的优点">迭代开发的优点</a></li><li><a href="#一次迭代的持续时间和时间定量">一次迭代的持续时间和时间定量</a></li><li><a href="#迭代开发举例优先级排序">迭代开发举例，优先级排序</a></li><li><a href="#up的核心思想">UP的核心思想</a></li><li><a href="#up的四个阶段">UP的四个阶段</a></li></ul></li><li><a href="#第四章">第四章</a><ul><li><a href="#初始阶段">初始阶段</a></li><li><a href="#初始阶段需要回答的问题">初始阶段需要回答的问题</a></li><li><a href="#初始阶段会创建的制品">初始阶段会创建的制品</a></li></ul></li><li><a href="#第五章">第五章</a><ul><li><a href="#需求的种类">需求的种类</a></li><li><a href="#up制品如何组织需求">UP制品如何组织需求</a></li><li><a href="#用例的好处">用例的好处</a></li><li><a href="#为什么使用用例">为什么使用用例</a></li><li><a href="#参与者的三种类型三种形式">参与者的三种类型，三种形式。</a></li><li><a href="#用例的三种常用形式">用例的三种常用形式</a></li><li><a href="#详述风格的处理销售">详述风格的处理销售</a></li><li><a href="#ppt611准则">（ppt6.11准则)</a></li><li><a href="#如何发现用例">如何发现用例</a></li><li><a href="#什么样的问题有助于寻找参与者和目标">什么样的问题有助于寻找参与者和目标</a></li><li><a href="#用例的粒度问题">用例的粒度问题</a></li><li><a href="#其他需求补充性规格说明">其他需求，补充性规格说明</a></li><li><a href="#vision设想中的元素">vision设想中的元素</a></li><li><a href="#准则是否应该在设想文档中重复其他需求">准则：是否应该在设想文档中重复其他需求</a></li><li><a href="#准则先写设想还是用例">准则：先写设想还是用例</a></li></ul></li><li><a href="#第8章">第8章</a><ul><li><a href="#细化阶段开始构建的制品">细化阶段开始构建的制品</a></li></ul></li><li><a href="#第9章">第9章</a><ul><li><a href="#领域模型并非表示软件制品或类">领域模型并非表示软件制品或类</a></li><li><a href="#领域模型与数据模型区别">领域模型与数据模型区别</a></li><li><a href="#为什么要创建领域模型">为什么要创建领域模型</a></li><li><a href="#创建领域模型的步骤">创建领域模型的步骤</a></li><li><a href="#如何找到概念类">如何找到概念类！🍧</a></li><li><a href="#使用分类列表了解">使用分类列表（了解）</a></li><li><a href="#模型中是否要包括票据">模型中是否要包括票据</a></li><li><a href="#描述类-什么是描述类为什么要使用使用准则">描述类 什么是描述类，为什么要使用，使用准则</a></li><li><a href="#准则何时添加关联">准则：何时添加关联</a></li><li><a href="#准则避免加入大量关联">准则：避免加入大量关联</a></li><li><a href="#关联是否会在软件中实现">关联是否会在软件中实现</a></li><li><a href="#何时定义新的数据类型类">何时定义新的数据类型类</a></li></ul></li><li><a href="#第10章">第10章</a><ul><li><a href="#什么是系统顺序图什么时候绘制准则">什么是系统顺序图，什么时候绘制（准则）</a></li><li><a href="#为什么绘制ssd对三种事件响应">为什么绘制ssd，对三种事件响应</a></li><li><a href="#操作契约co2">操作契约CO2</a></li><li><a href="#后置条件具体内容">后置条件具体内容</a></li><li><a href="#如何创建和编写契约">如何创建和编写契约</a></li></ul></li><li><a href="#第13章">第13章</a><ul><li><a href="#使用层能解决什么问题">使用层能解决什么问题</a></li><li><a href="#使用层的好处">使用层的好处</a></li><li><a href="#观察者模式选择题">观察者模式（选择题）</a></li><li><a href="#模型视图分离的动机">模型视图分离的动机</a></li><li><a href="#crc卡">CRC卡</a></li><li><a href="#给你交互图类图能写出代码结构类的定义">给你交互图，类图能写出代码结构，类的定义。</a></li><li><a href="#什么是创始消息">什么是创始消息</a></li><li><a href="#1613组合优于聚合">16.13组合优于聚合</a></li><li><a href="#什么是主动类主动对象">什么是主动类，主动对象</a></li></ul></li><li><a href="#第17章">第17章</a><ul><li><a href="#grasp知道英文全称">GRASP（知道英文全称）</a></li><li><a href="#对象的行为职责认知职责">对象的行为职责，认知职责</a></li><li><a href="#设计模式基本要素4个">设计模式基本要素4个</a></li></ul></li><li><a href="#20分原题">@（20分原题）</a><ul><li><a href="#单一职责原则定义">单一职责原则定义</a></li><li><a href="#单一职责原则有什么好处">单一职责原则有什么好处</a></li><li><a href="#进行优化">进行优化</a></li><li><a href="#包括开闭原则依赖倒转-李氏代还-接口隔离合用复用问题方式同上">包括开闭原则，依赖倒转， 李氏代还 接口隔离，合用复用问题方式同上</a></li><li><a href="#迪米特法则-对象其朋友分类5类不涉及大题">迪米特法则 对象其朋友分类，5类（不涉及大题）</a></li><li><a href="#grasp模式">grasp模式</a></li><li><a href="#给一个设计方案应用grasp模式进行评价和改进">给一个设计方案，应用grasp模式进行评价和改进。</a></li><li><a href="#创建者模式信息专家低耦合控制器高内聚-名称问题解决方案">创建者模式，信息专家，低耦合，控制器，高内聚 名称问题解决方案。</a></li><li><a href="#控制器的两种方式什么时候使用">控制器的两种方式，什么时候使用</a></li><li><a href="#浮肿的控制器的征兆解决方案">浮肿的控制器的征兆，解决方案</a></li></ul></li><li><a href="#第19章">第19章</a><ul><li><a href="#对象之间可见性">对象之间可见性</a></li><li><a href="#可见性四种方式">可见性四种方式</a></li></ul></li><li><a href="#第21章">第21章</a><ul><li><a href="#坏味代码特点">坏味代码特点</a><h1 id="面向对象分析与设计复习提纲"><a href="#面向对象分析与设计复习提纲" class="headerlink" title="面向对象分析与设计复习提纲"></a>面向对象分析与设计复习提纲</h1></li></ul></li></ul></li></ul><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="应用UML的三种方式"><a href="#应用UML的三种方式" class="headerlink" title="应用UML的三种方式"></a>应用UML的三种方式</h3><ol><li>UML作为<strong>草图</strong><ul><li>白板上手绘非正式、不完整的图。</li><li>用于探讨问题或解决方案的复杂部分。</li></ul></li><li>UML作为<strong>蓝图</strong>   相对详细的设计图，用于：<ul><li>逆向工程，即以UML图的方式对现有代码进行可视化，使其易于理解。</li><li>代码生成（前向工程）——一般用其生成部分代码，开发人员填充其他代码。</li></ul></li><li>UML作为<strong>编程语言</strong><ul><li>用UML完成软件系统可执行规格说明。</li><li>可执行代码自动生成。</li><li>目前在理论、工具的健壮性和可用性方面仍然处于发展阶段。</li></ul></li></ol><h3 id="应用UML的三种透视图"><a href="#应用UML的三种透视图" class="headerlink" title="应用UML的三种透视图"></a>应用UML的三种透视图</h3><ol><li><strong>概念透视图</strong>： 用图来描述现实世界或关注领域中的事务。</li><li><strong>规格说明（软件）透视图</strong>： 用图（使用与概念透视图中相同的表示法）来描述软件的抽象物或具有规格说明和接口的构件，但是并不约定特定实现。</li><li><strong>实现（软件）透视图</strong>： 用图来描述特定技术中（例如，Java）的软件实现。</li></ol><h3 id="不同视图中类的含义"><a href="#不同视图中类的含义" class="headerlink" title="不同视图中类的含义"></a>不同视图中类的含义</h3><ol><li>概念类： 现实世界中的概念或事物。</li><li>软件类： 无论在过程还是方法中，都表示软件构件在规格说明或实现透视图中的类。</li><li>实现类： 特定OO语言中的类。</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="统一过程的特点"><a href="#统一过程的特点" class="headerlink" title="统一过程的特点"></a>统一过程的特点</h3><ul><li>用例驱动</li><li>以构架为中心</li><li>迭代和增量</li></ul><h3 id="如何在迭代项目中处理变更"><a href="#如何在迭代项目中处理变更" class="headerlink" title="如何在迭代项目中处理变更"></a>如何在迭代项目中处理变更</h3><ul><li>一方面认同和稳定一组需求，另一方面接受需求不断变更的事实。</li><li>每次迭代选择一小组需求，快速设计、实现和测试。</li><li>早期迭代可能并不准确，但是快速实施可以得到快速反馈—-来自用户、开发人员和测试人员的反馈。</li><li>早期迭代中系统偏离正确轨迹的程度会大于后继迭代。随着时间的发展，系统将会收敛。</li><li>最好及早解决和验证具有风险的、关键的设计决策。</li></ul><h3 id="早起迭代跟后期迭代的特点"><a href="#早起迭代跟后期迭代的特点" class="headerlink" title="早起迭代跟后期迭代的特点"></a>早起迭代跟后期迭代的特点</h3><ul><li>早期迭代远离系统的“真实路径”。通过反馈和调整，系统向最适宜的需求和设计收敛。</li><li>在后期迭代中，很少会在需求上产生显著变化，但是存在这种可能性。这种后期的变化可能会给组织带来业务竞争优势。</li></ul><h3 id="迭代开发的优点"><a href="#迭代开发的优点" class="headerlink" title="迭代开发的优点"></a>迭代开发的优点</h3><ul><li>减少项目失败可能性，提高生产率，降低缺陷率。</li><li>在早期（而不是晚期）缓解高风险（技术、需求、目标、可用性等等）。</li><li>早期可见的进展。</li><li>早期反馈、用户参与和调整，会产生更接近涉众真实需求的精华系统</li><li>可控复杂性；团队不会被“分析瘫痪”或长期且复杂的步骤所淹没。</li><li>一次迭代中的经验可以被系统地用于改进开发过程本身，并如此反复进行下去。</li></ul><h3 id="一次迭代的持续时间和时间定量"><a href="#一次迭代的持续时间和时间定量" class="headerlink" title="一次迭代的持续时间和时间定量"></a>一次迭代的持续时间和时间定量</h3><ul><li>大部分迭代方法建议迭代时间在2－6周之内。小步骤、快速反馈和调整是迭代开发的主要思想，时间过长会增加风险。</li><li>1周的迭代不足以获得有意义的产出和反馈，大于6周，复杂性会变得不可控制，反馈将延迟。</li><li>迭代的一个关键思想是时间定量或时长固定。约定了时间，必须按时完成，实在完不成，不能推迟时间，而是剔除一些任务或需求。</li></ul><h3 id="迭代开发举例，优先级排序"><a href="#迭代开发举例，优先级排序" class="headerlink" title="迭代开发举例，优先级排序"></a>迭代开发举例，优先级排序</h3><p>通过咨询首席架构师和业务人员，从高阶需求中选择10％列表项（例如30个用例名中的10%）。这些项目具有重要的架构意义（如果要实现，必须设计、构造和测试的核心架构）、高业务价值（业务真正关心的特性），具有高风险（如能够处理500个并发交易），所选用例UC2、UC11、UC14</p><h3 id="UP的核心思想"><a href="#UP的核心思想" class="headerlink" title="UP的核心思想"></a>UP的核心思想</h3><p>短时间定量迭代、进化和可适应性开发。</p><h3 id="UP的四个阶段"><a href="#UP的四个阶段" class="headerlink" title="UP的四个阶段"></a>UP的四个阶段</h3><ul><li><code>初始（Inception）</code>：大体上的构想、业务案例、范围和模糊评估 ——可行性研究。</li><li><code>细化（Elaboration）</code>: 已精化的构想、 核心架构的迭代实现、 高风险的解决、 确定大多数需求和范围以及进行更为实际的评估。 </li><li><code>构造(Construction)</code>: 对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署 。</li><li><code>移交(Transition)</code>：进行beta测试和部署。</li></ul><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h3><ul><li>初始阶段是建立项目共同设想和基本范围的比较简短的起始步骤 。</li><li>它包括： <ul><li>10％的用例进行分析； </li><li>关键的非功能需求的分析； </li><li>业务案例创建； </li><li>开发环境的准备。 </li></ul></li></ul><h3 id="初始阶段需要回答的问题"><a href="#初始阶段需要回答的问题" class="headerlink" title="初始阶段需要回答的问题"></a>初始阶段需要回答的问题</h3><ul><li>该项目的vision（设想/愿景） 和business case（业务案例） ?</li><li>是否可行?</li><li>购买 or 构造?</li><li>成本的大致估计; 是$10K，100K，1000K?</li><li>项目继续还是停止?</li></ul><h3 id="初始阶段会创建的制品"><a href="#初始阶段会创建的制品" class="headerlink" title="初始阶段会创建的制品"></a>初始阶段会创建的制品</h3><ol><li><p>设想和业务用例（Vision and Business Case）</p><p>描述高阶目标与约束、业务案例，并提供执行摘要。</p></li><li><p>用例模型（Use-Case Model）</p><p>描述功能需求。在初始阶段，确定大部分用例名称，详细分析10%的用例。</p></li><li><p>补充性规格说明（Supplementary Specification）</p><p>描述其他需求，主要是非功能性需求。初始阶段，多考虑关键的非功能性需求，其对架构将会产生主要影响。</p></li><li><p>词汇表（Glossary）</p><p>关键领域术语和数据字典。</p></li><li><p>风险列表和风险管理计划（Risk List&amp;Risk Management Plan）</p><p>描述风险（业务、技术、资源和进度）及应对和缓解的方法。</p></li><li><p>原型和概念验证（Prototypes and Proof-of-concepts）</p><p>澄清设想，验证技术思路。</p></li><li><p>迭代计划（Iteration Plan）</p><p>描述第一个细化迭代的任务。</p></li><li><p>阶段计划和软件开发计划（Phase Plan &amp; Software Development Plan）</p><p>对细化阶段的持续时间和工作量进行粗略估计。工具、人员、教育和其他资源。</p></li><li><p>开发案例（Development Case）</p><p>就待定项目，对UP步骤和制品进行定制的描述。在UP中，通常会为特定项目进行定制。</p></li></ol><p>在初始阶段可能要进行一些编程，其目的是创建”概念验证原型“，通过面向UI的原型澄清一些需求，以及为关键的”显示阻塞“技术问题做一些编程实验</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="需求的种类"><a href="#需求的种类" class="headerlink" title="需求的种类"></a>需求的种类</h3><p>采用FURPS+ 模型 [GRA92], 缩写FURPS 描述了需求的主要类别： </p><ul><li>功能性（Functionality）：特性、功能、安全性。  </li><li>可用性（Usability）：人性化因素、帮助、文档。 </li><li>可靠性（Reliability ）：故障频率、可恢复性、可预测性。 </li><li>性能（Performance ）：响应时间、吞吐量、准确性、有效性、资源利用率。 </li><li>可支持性（Supportability）：适应性、可维护性、国际化、可配置性。</li></ul><h3 id="UP制品如何组织需求"><a href="#UP制品如何组织需求" class="headerlink" title="UP制品如何组织需求"></a>UP制品如何组织需求</h3><p>关键的UP需求制品 </p><ul><li>用例模型－一组使用系统的典型场景。主要用于功能（行为的）需求。</li><li>补充规格说明－基本上是用例之外的所有内容。主要用于所有非功能需求，例如性能或许可发布。 该制品也用来记录没有表示(或不能表示）为用例的功能特性，例如报表生成。 </li><li>词汇表－定义重要的术语，数据字典记录了关于数据的需求，例如有效性规则，容许值等。对象属性、操作调用的参数、报表布局等。 </li><li>设想－概括了高阶需求，这些需求在用例模型和补充性规格说明中进行细化。设想也概括了项目的业务案例。设想是简短的执行概要文档 ，用以快速了解项目的主要思想。</li><li>业务规则－领域规则，描述了凌驾于某一软件项目的需求或政策，这些规则是领域或业务所要求的，并且许多应用应该遵从这些规则。例如政府的税收法规。</li><li>领域规则的细节可以记录在补充性规格说明中，因为这些规则通常更为持久，对不止一个软件项目适用，应将其放入集中的业务规则制品，以便重用。</li></ul><p>UP中，制品可以存储在Web页、板报、各种可以想象到的载体上，在线的RUP含有制品模板，但这些模板只是可选的辅助工具，可以忽略。</p><h3 id="用例的好处"><a href="#用例的好处" class="headerlink" title="用例的好处"></a>用例的好处</h3><ul><li>从用户的角度获取操作性需求。</li><li>对系统的功能进行清晰而一致的描述。</li><li>系统测试的基础。</li><li>提供了从功能需求跟踪到系统中真正的类和操作的能力。</li></ul><h3 id="为什么使用用例"><a href="#为什么使用用例" class="headerlink" title="为什么使用用例"></a>为什么使用用例</h3><ul><li>使工作保持简单的好方法。 </li><li>使领域专家或需求提供者自己编写（或参与编写）用例成为可能。 </li><li>强调了用户的目标和观点。 </li><li>与查询系统特性清单相比更强调以客户为中心。 </li><li>例的优越性在于能够根据需要对复杂程度和形式化程度进行增减删节。 </li></ul><h3 id="参与者的三种类型，三种形式。"><a href="#参与者的三种类型，三种形式。" class="headerlink" title="参与者的三种类型，三种形式。"></a>参与者的三种类型，三种形式。</h3><ol><li><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619220326.png" alt="20200619220326"></li><li><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619220358.png" alt="20200619220358"></li></ol><h3 id="用例的三种常用形式"><a href="#用例的三种常用形式" class="headerlink" title="用例的三种常用形式"></a>用例的三种常用形式</h3><ol><li>摘要－－简洁的一段式概要，通常用于主成功场景。<ul><li>何时使用:  在早期需求分析过程中，为快速了解主体和范围使用。可能只需要几分钟编写。</li></ul></li><li>非正式－－非正式的段落格式。用几个段落覆盖不同场景。<ul><li>何时使用？同上。</li></ul></li><li>详述－－详细编写所有步骤及各种变化，同时具有补充部分，如前置条件和成功保证。 <ul><li>何时使用？确定并以摘要形式编写了大量用例后，在第一次需求讨论会中，详细地编写其中少量的具有重要架构和高价值的用例。 </li></ul></li></ol><h3 id="详述风格的处理销售"><a href="#详述风格的处理销售" class="headerlink" title="详述风格的处理销售"></a>详述风格的处理销售</h3><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619220804.png" alt="20200619220804"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619220815.png" alt="20200619220815"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619220829.png" alt="20200619220829"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619220850.png" alt="20200619220850"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619220900.png" alt="20200619220900"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619220920.png" alt="20200619220920"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619220939.png" alt="20200619220939"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619220950.png" alt="20200619220950"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619221000.png" alt="20200619221000"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619221035.png" alt="20200619221035"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619221047.png" alt="20200619221047"></p><h3 id="（ppt6-11准则"><a href="#（ppt6-11准则" class="headerlink" title="（ppt6.11准则)"></a>（ppt6.11准则)</h3><h3 id="如何发现用例"><a href="#如何发现用例" class="headerlink" title="如何发现用例"></a>如何发现用例</h3><ol><li>选择系统边界  系统紧紧是软件应用，还是将硬件和作用作为整体，是一个人使用，还是整个组织使用。</li><li>寻找主要参与者  通过使用系统的服务实现目标的人或事。</li><li>为每个参与者确定他们的目标。</li><li>定义满足用户目标的用例，根据其目标对用例命名。通常，用户目标级别的用例和用户目标是一一对应的。</li></ol><h3 id="什么样的问题有助于寻找参与者和目标"><a href="#什么样的问题有助于寻找参与者和目标" class="headerlink" title="什么样的问题有助于寻找参与者和目标"></a>什么样的问题有助于寻找参与者和目标</h3><ul><li>谁来启动和停止系统。</li><li>谁来完成用户管理和安全管理。</li><li>谁来完成系统管理。</li><li>“时间”是管理者吗。因为系统要响应时间事件而完成某些活动。</li><li>系统失败时，是否存在监控进程将系统重新启动。</li><li>软件升级是如何处理的，是推模式还是拉模式。</li><li>除了人作为主要参与者外，还有其他外部的软件或自动机器系统调用该系统的服务吗。</li><li>谁来考察系统活动或性能。</li><li>谁来考察日志，是否可以远程检索。</li><li>系统发生错误或故障时应通知谁。</li></ul><h3 id="用例的粒度问题"><a href="#用例的粒度问题" class="headerlink" title="用例的粒度问题"></a>用例的粒度问题</h3><ul><li>大用例<ul><li>我们的企业需要拓宽销售渠道。</li><li>整个系统就只有一个用例!!!</li></ul></li><li>小的用例<ul><li>输入口令。</li><li>系统中可能有成百上千个用例!!!</li></ul></li></ul><h3 id="其他需求，补充性规格说明"><a href="#其他需求，补充性规格说明" class="headerlink" title="其他需求，补充性规格说明"></a>其他需求，补充性规格说明</h3><ul><li>补充性规格说明中的元素包括： <ul><li>FURPS+ 需求-功能性、可用性、可靠性和可支持性。</li><li>报表。</li><li>硬件和软件约束。</li><li>领域 (或者业务) 规则。</li><li>法律问题 – 责任，知识产权，等等。</li><li>包装, 等等。</li></ul></li></ul><h3 id="vision设想中的元素"><a href="#vision设想中的元素" class="headerlink" title="vision设想中的元素"></a>vision设想中的元素</h3><ul><li>设想概括了对项目的“设想”，即执行摘要。该制品为项目主要思想提供简洁描述。<ul><li>设想中的元素包括：<ul><li>修订历史。</li><li>定位。</li><li>涉众描述。</li><li>产品概览。</li><li>系统特性概要。</li><li>其它需求和约束。</li></ul></li></ul></li></ul><h3 id="准则：是否应该在设想文档中重复其他需求"><a href="#准则：是否应该在设想文档中重复其他需求" class="headerlink" title="准则：是否应该在设想文档中重复其他需求"></a>准则：是否应该在设想文档中重复其他需求</h3><ul><li>设想文档中，系统特性简明概括了通常在用例中要详细说明的功能性需求。</li><li>设想文档能对补充性规格说明中详细说明的其他需求（如可靠性和可用性）加以概括。</li><li>尽量避免陷入对自己的重复当中。</li><li>对于其他需求，需避免在设想和补充性规格说明中重复或近于重复。最好在补充性规格说明中记录这些需求，设想中，加以指引。</li></ul><h3 id="准则：先写设想还是用例"><a href="#准则：先写设想还是用例" class="headerlink" title="准则：先写设想还是用例"></a>准则：先写设想还是用例</h3><p>建议如下顺序：</p><ul><li>首先编写简要的设想草案。</li><li>确定用户目标和对应的用例名称。</li><li>详细编写一些用例，并且开始编写补充性规格说明。</li><li>精化设想，对以上制品信息进行概括。</li></ul><h2 id="第8章"><a href="#第8章" class="headerlink" title="第8章"></a>第8章</h2><h3 id="细化阶段开始构建的制品"><a href="#细化阶段开始构建的制品" class="headerlink" title="细化阶段开始构建的制品"></a>细化阶段开始构建的制品</h3><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619224542.png" alt="20200619224542"></p><h2 id="第9章"><a href="#第9章" class="headerlink" title="第9章"></a>第9章</h2><h3 id="领域模型并非表示软件制品或类"><a href="#领域模型并非表示软件制品或类" class="headerlink" title="领域模型并非表示软件制品或类"></a>领域模型并非表示软件制品或类</h3><ul><li>领域模型是对所关注的现实世界领域中事物的可视化，而不是诸如java或C#类的软件对象，或有职责软件对象。</li><li>以下元素不适用于领域模型：软件制品，例如窗口或数据库，职责或方法。</li></ul><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619224736.png" alt="20200619224736"></p><h3 id="领域模型与数据模型区别"><a href="#领域模型与数据模型区别" class="headerlink" title="领域模型与数据模型区别"></a>领域模型与数据模型区别</h3><ul><li>领域模型不是数据模型。</li><li>不会排除需求中没有明确要求记录其相关信息的类。</li><li>不会排除没有属性的概念类。<br>  （包括纯行为角色而不是信息角色的概念类）</li></ul><h3 id="为什么要创建领域模型"><a href="#为什么要创建领域模型" class="headerlink" title="为什么要创建领域模型"></a>为什么要创建领域模型</h3><ul><li>它是一种可视化语言，传达了真实世界中的概念或者该领域中的概念类。</li><li>在UP领域模型中，涉众对领域内重要概念的看法 ——影响设计者，降低差异。</li><li>降低与OO建模之间的表示差异。<ul><li>领域层软件类的名称要源于领域模型中的名称，减少我们的思维与软件模型之间的表示差异。</li></ul></li></ul><h3 id="创建领域模型的步骤"><a href="#创建领域模型的步骤" class="headerlink" title="创建领域模型的步骤"></a>创建领域模型的步骤</h3><ul><li>以当前迭代中所要设计的需求为界：<ol><li>寻找概念类。</li><li>将其绘制为UML类图中的类。</li><li>添加关联和属性。</li></ol></li></ul><h3 id="如何找到概念类！🍧"><a href="#如何找到概念类！🍧" class="headerlink" title="如何找到概念类！🍧"></a>如何找到概念类！🍧</h3><ul><li>找到概念类的三条策略<ol><li>重用和修改现有的模型。<ul><li>库存、金融、卫生等很多领域都存在已经发布的、绘制精细的领域模型和数据模型。</li><li>以此为基础修改为领域模型。</li></ul></li><li>使用分类列表。<ul><li>通常制作概念类候选列表来开始创建领域模型。</li></ul></li><li>通过识别名词短语寻找概念类。<ul><li>语言分析 <ul><li>在对领域的文本描述中识别名词和名词短语，将其作为候选的概念类或属性。 </li><li>注意力要放在下列方面: <ul><li>业务对象。</li><li>真实世界中的对象。</li><li>事件。</li></ul></li></ul></li></ul></li></ol></li></ul><h3 id="使用分类列表（了解）"><a href="#使用分类列表（了解）" class="headerlink" title="使用分类列表（了解）"></a>使用分类列表（了解）</h3><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619225701.png" alt="20200619225701"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619225720.png" alt="20200619225720"></p><h3 id="模型中是否要包括票据"><a href="#模型中是否要包括票据" class="headerlink" title="模型中是否要包括票据"></a>模型中是否要包括票据</h3><p>以下是一些要考虑的因素：</p><ul><li>一般来说，在领域模型中显示其它信息的报表并没有意义，因为其所有信息都是源于或者复制于其它信息源的。</li></ul><p>（也许它只是销售和支付数据的报表，是信息的重复。）</p><ul><li>另外一方面，就业务规则而言，收据又有特殊的作用，在我们退货时，我们需要收据作为凭据。</li></ul><p>本次迭代中没有考虑退货，所以不应该包括票据。</p><p>解决处理退货用例的迭代中，会考虑票据。</p><h3 id="描述类-什么是描述类，为什么要使用，使用准则"><a href="#描述类-什么是描述类，为什么要使用，使用准则" class="headerlink" title="描述类 什么是描述类，为什么要使用，使用准则"></a>描述类 什么是描述类，为什么要使用，使用准则</h3><ol><li><code>描述类</code>：包含描述其它事物的信息<br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619225955.png" alt="20200619225955"></li><li><code>动机</code>：为什么需要描述类<ul><li>Item实例表示商店里实际的商品，他可以拥有一个序列号。</li><li>Item具有描述、价格和ID，这些内容不会在任何其他地方记录。</li><li>商店里每个工作人员都有健忘症。</li><li>每售出一件实际的商品，相应的Item软件实例都会从软件领域中删除。</li></ul></li><li><code>使用准则</code><ul><li>需要有关商品或服务的描述，独立于任何商品或服务的现有实例。</li><li>删除其所描述事务（如Item）的实例后，导致信息丢失，而这些信息是需要维护的，但是被错误地与所删除的事务关联起来。</li><li>减少冗余或重复信息。</li></ul></li></ol><p><strong>描述性类用于描述商品、产品、服务等的描述。</strong></p><h3 id="准则：何时添加关联"><a href="#准则：何时添加关联" class="headerlink" title="准则：何时添加关联"></a>准则：何时添加关联</h3><ul><li>关联表示了需要持续一段时间的关系，根据语境，可能是几毫秒或数年。换言之，我们需要记录哪些对象之间的关系？</li><li>准则：在领域模型中需要考虑如下关联：<ul><li>如果存在需要保持一段时间的关系，将这种语义表示为关联（“需要记住”的关联）。</li><li>可以从常见关联列表中派生的关联。</li><li>需要记录SalesLineItem实例和Sale实例之间的关系。</li><li>否则，无法再现销售、打印票据或计算销售总额。</li><li>需要为账务和法律用途，需要在Leger中记录已完成的Sales.</li><li>领域模型是从概念角度出发，是否需要记录关联，基于现实世界的需要，而不是基于软件的需要，尽管在实现过程中，会出现大量对关联的需要。</li><li>Monopoly领域，需要记住棋子在哪个方格上，否则，游戏无法进行。</li><li>应该记住某个游戏者使用的是哪个棋子。</li><li>需要记录某个棋盘包括哪些方格。</li></ul></li><li>举例：<ul><li>需要记录：<ul><li>棋子在哪个方格上。</li><li>某个游戏者使用的是哪个棋子。</li><li>某个棋盘需要包括哪些方格。</li></ul></li><li>不用记录：<ul><li>指示移动到方格上的骰子点数。</li><li>哪个收银员查询了哪个商品描述。</li></ul></li></ul></li></ul><h3 id="准则：避免加入大量关联"><a href="#准则：避免加入大量关联" class="headerlink" title="准则：避免加入大量关联"></a>准则：避免加入大量关联</h3><ul><li>如果我们有n 个类，将会有n(n-1)个关联。</li><li>“视觉干扰”，使图变得混乱。</li><li>关注“需要记住”的关联。</li></ul><h3 id="关联是否会在软件中实现"><a href="#关联是否会在软件中实现" class="headerlink" title="关联是否会在软件中实现"></a>关联是否会在软件中实现</h3><ul><li>关联不是数据流、数据库外键联系、实例变量或软件方案中的对象连接的语句；</li><li>关联声明的是针对现实领域从纯概念角度看有意义的关系。</li><li>添加关联是为了突出我们对重要关系的大致理解，而非记录对象或数据的结构。</li></ul><h3 id="何时定义新的数据类型类"><a href="#何时定义新的数据类型类" class="headerlink" title="何时定义新的数据类型类"></a>何时定义新的数据类型类</h3><ul><li>在下述情况下，在领域模型里，把最初被认为是数字或字符串的数据类型表示为新的数据类型类：<ul><li>由不同的小节组成（如电话号码、人名、地址）</li><li>具有与之相关的操作，例如解析或校验（如社会安全号）</li><li>具有其他属性（如促销价格有开始日期和结束日期）</li><li>单位的数量（如支付总额具有货币单位）</li><li>具有以上性质的一个或多个类型的抽象（如商品标识符）</li></ul></li><li>对POS领域模型的属性应用这些准则，会产生以下分析：<ul><li>商品标识符为数据类型ItemID类，具有编码规则和校验。</li><li>price和amount属性的数据类型应该是Money类因为它们是货币单位的数量。</li><li>address属性的数据类型应该是Address类，因为其具有不同的小节。</li></ul></li></ul><h2 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h2><h3 id="什么是系统顺序图，什么时候绘制（准则）"><a href="#什么是系统顺序图，什么时候绘制（准则）" class="headerlink" title="什么是系统顺序图，什么时候绘制（准则）"></a>什么是系统顺序图，什么时候绘制（准则）</h3><ul><li>系统顺序图（SSD）<ul><li>是为阐述与所讨论系统相关的输入和输出事件而快速、简单地创建的制品。</li><li>它展示了对一个特定的用例，直接与系统交互的外部参与者、系统（作为黑盒）以及由参与者发起的系统事件。</li><li>用例文本暗示了enteritem事件，SSD将其变得具体明确。</li></ul></li></ul><p>准则：应为每个用例的主成功场景，以及频繁发生的或者复杂的替代场景绘制SSD</p><h3 id="为什么绘制ssd，对三种事件响应"><a href="#为什么绘制ssd，对三种事件响应" class="headerlink" title="为什么绘制ssd，对三种事件响应"></a>为什么绘制ssd，对三种事件响应</h3><p>软件系统要对以下三种事件进行响应：</p><p> （1）来自于参与者（人或计算机）的外部事件。</p><p> （2）时间事件。</p><p> （3）错误或异常（通常源于外部）。</p><h3 id="操作契约CO2"><a href="#操作契约CO2" class="headerlink" title="操作契约CO2"></a>操作契约CO2</h3><ul><li>操作契约：<ul><li>通过领域模型中的对象的状态变换，定义了系统操作执行后的详细的系统行为。</li></ul></li><li>为什么引入契约？<ul><li>用例是统一过程中描述系统行为的主要机制，而且通常也是足够的。</li><li>但是，某些时候我们需要对系统行为进行更详细的描述，而这些描述对于用例而言，所需状态变化和复杂性难以处理或过于细节化。</li></ul></li></ul><h3 id="后置条件具体内容"><a href="#后置条件具体内容" class="headerlink" title="后置条件具体内容"></a>后置条件具体内容</h3><ul><li>后置条件不是在操作过程中执行的活动，是对领域模型对象的观察结果，操作完成后，这些结果为真。</li><li>就像浓烟散去后能清晰看到的事物。</li><li>后置条件描述了领域模型中对象状态的变化。包括：<ul><li>实例创建和删除。</li><li>属性值的变化。</li><li>关联形成和消除。</li></ul></li><li>消除关联比较少见。例如，假设允许删除商品项目，后置条件设置为“所选的SalesLineItem与Sale的关联消除了”。</li><li>后置条件主要是在领域模型对象的语境中表示的，可以创建什么实例？可以形成什么关联等等均来自于领域模型。</li></ul><h3 id="如何创建和编写契约"><a href="#如何创建和编写契约" class="headerlink" title="如何创建和编写契约"></a>如何创建和编写契约</h3><ul><li>为了制定一个契约:<ul><li>从SSD中识别系统操作。</li><li>如果系统操作复杂，其结果可能不明显，或者在用例中表达不清楚的系统操作，构造一个契约。</li><li>为了描述后置条件，使用下列列表。<ul><li>实例创建或删除</li><li>属性修改</li><li>关联形成和清除</li></ul></li></ul></li><li>以说明性的、被动式的过去时态编写后置条件。</li><li>常见的错误是遗漏了关联的形成，特别是当创建了新实例时，通常需要建立与若干对象的关联。<h2 id="第13章"><a href="#第13章" class="headerlink" title="第13章"></a>第13章</h2><h3 id="使用层能解决什么问题"><a href="#使用层能解决什么问题" class="headerlink" title="使用层能解决什么问题"></a>使用层能解决什么问题</h3></li><li>源代码的变更波及整个系统——大部分系统是高度耦合。</li><li>应用逻辑与用户界面交织在一起，因此，无法复用于其他不同界面或分布到其他处理节点之上。</li><li>潜在的一般性技术服务或业务逻辑与更特定于应用的逻辑交织在一起，因此无法被复用、分布到其他节点或方便的使用不同实现替换。</li><li>不同的关注领域之间高度耦合。因此，难以为不同开发者清晰地界定和分配任务。</li></ul><h3 id="使用层的好处"><a href="#使用层的好处" class="headerlink" title="使用层的好处"></a>使用层的好处</h3><ul><li>总的来说，使用层可以做到关系分离、高级服务与低级服务分离、特定于应用的服务与一般性服务分离；</li><li>层可以减少耦合和依赖性、增强内聚性、提高潜在的复用性并且使概念更加清晰。</li><li>封装和分解了相关的复杂性。</li><li>某些层能够用新的实现替换。对于较低级的技术服务层来说不大可能（如，java.util），但对于UI、应用层和领域层来说是可能的。</li><li>较低层包含可复用功能。</li><li>某些层（主要是领域层和技术服务层）可以是分布式的。</li><li>通过逻辑划分，有助于团队开发。</li></ul><h3 id="观察者模式（选择题）"><a href="#观察者模式（选择题）" class="headerlink" title="观察者模式（选择题）"></a>观察者模式（选择题）</h3><ul><li>观察者模式（Observer）是对该原则的合理扩充，即领域对象只能通过PropertyListener(Java中的常用接口)的接口向视图的UI对象发送消息。</li><li>基于这种模式，领域对象不知道UI对象的存在，既不知道他的具体窗口类。领域对象秩序发送消息给实现了PropertyListener接口的对象。</li><li>该原则进一步应用，领域类封装了与应用逻辑相关的信息和行为。窗口类负责输入输出，捕获UI事件，并不维护应用数据或直接提供应用逻辑。</li><li>例如，Java的JFrame窗口不应该拥有计算税金的方法，Web JSP页面不应该包含计算税金的逻辑。</li><li>这些UI元素应该委派给非UI元素完成这些职责。</li></ul><h3 id="模型视图分离的动机"><a href="#模型视图分离的动机" class="headerlink" title="模型视图分离的动机"></a>模型视图分离的动机</h3><ul><li>支持内聚的模型定义，这些定义只关注领域过程，而不是用户界面。</li><li>允许对模型和用户界面层分别进行开发。</li><li>使界面的需求变更对领域层的影响最小化。</li><li>允许新视图能方便地连接到现有的领域层之上，而不会对领域层产生影响。</li><li>允许对同一模型对象同时使用多个视图，例如，销售信息同时具有表格和业务图表视图。</li><li>允许模型层的运行不依赖于用户界面层。例如，消息处理后批处理模式的系统。</li><li>允许简模型层能方便地移植到另一用户接口框架下。</li></ul><h3 id="CRC卡"><a href="#CRC卡" class="headerlink" title="CRC卡"></a>CRC卡</h3><p><code>类职责协助卡</code> ：  Class Responsibility Collaborator</p><h3 id="给你交互图，类图能写出代码结构，类的定义。"><a href="#给你交互图，类图能写出代码结构，类的定义。" class="headerlink" title="给你交互图，类图能写出代码结构，类的定义。"></a>给你交互图，类图能写出代码结构，类的定义。</h3><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200620004332.png" alt="20200620004332"></p><h3 id="什么是创始消息"><a href="#什么是创始消息" class="headerlink" title="什么是创始消息"></a>什么是创始消息</h3><ul><li>最开始的消息在UML称为创始消息（Found Message），以实心圆作为起点表示此类消息。</li><li>创始消息表示没有特定发送者、发送者不明确或消息源众多的消息。</li></ul><h3 id="16-13组合优于聚合"><a href="#16-13组合优于聚合" class="headerlink" title="16.13组合优于聚合"></a>16.13组合优于聚合</h3><ul><li>聚合(aggregation)<ul><li>一种模糊的关联，其不精确地暗示了整体-部分关系。<br>准则：不要在UML中费心去使用聚合。</li></ul></li><li>组合(composition)<ul><li>组合关系有几个含义：<ul><li>在某一时刻，部分的实例（如：Square）只属于一个组成实例(如：Board)。</li><li>部分必须总是属于组成（不存在随意游离的Fingers）。</li><li>组成要负责创建和删除其部分，既可以自己来创建/删除部分，也可以与其他对象协作来创建/删除部分。</li></ul></li><li>如果组成被销毁，其部分也必须被销毁。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200620004531.png" alt="20200620004531"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200620004546.png" alt="20200620004546"><br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200620004620.png" alt="20200620004620"></p><h3 id="什么是主动类，主动对象"><a href="#什么是主动类，主动对象" class="headerlink" title="什么是主动类，主动对象"></a>什么是主动类，主动对象</h3><ul><li>主动对象（active object）运行于自己控制的执行线程之上。</li><li>主动对象的类即为主动类(active class)。</li></ul><h2 id="第17章"><a href="#第17章" class="headerlink" title="第17章"></a>第17章</h2><h3 id="GRASP（知道英文全称）"><a href="#GRASP（知道英文全称）" class="headerlink" title="GRASP（知道英文全称）"></a>GRASP（知道英文全称）</h3><p> <strong>General Responsibility Assignment Software Patterns</strong></p><h3 id="对象的行为职责，认知职责"><a href="#对象的行为职责，认知职责" class="headerlink" title="对象的行为职责，认知职责"></a>对象的行为职责，认知职责</h3><ul><li>对象的行为职责<ul><li>自身执行一些行为，例如创建对象或计算。</li><li>初始化其他对象中的动作。</li><li>控制或者协调其它对象的活动。<br>如：Sale负责创建SalesLineItem。</li></ul></li><li>对象的认知职责<ul><li>对私有封装数据的认知。</li><li>对相关对象的认知。</li><li>对其能够导出或计算的事物的认知。<br>如：Sale负责认知其总额。</li></ul></li></ul><h3 id="设计模式基本要素4个"><a href="#设计模式基本要素4个" class="headerlink" title="设计模式基本要素4个"></a>设计模式基本要素4个</h3><ul><li>模式名称 (Pattern name) </li><li>问题 (Problem) </li><li>解决方案 (Solution) </li><li>效果 (Consequences) </li></ul><h2 id="（20分原题）"><a href="#（20分原题）" class="headerlink" title="@（20分原题）"></a>@（20分原题）</h2><h3 id="单一职责原则定义"><a href="#单一职责原则定义" class="headerlink" title="单一职责原则定义"></a>单一职责原则定义</h3><ul><li>单一职责原则(Single Responsibility Principle, SRP)：<ul><li>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</li></ul></li><li>另一种定义方式如下：<ul><li>就一个类而言，应该仅有一个引起它变化的原因。 </li></ul></li></ul><h3 id="单一职责原则有什么好处"><a href="#单一职责原则有什么好处" class="headerlink" title="单一职责原则有什么好处"></a>单一职责原则有什么好处</h3><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li><li>可读性提高，复杂性降低，可读性提高；</li><li>可维护性提高，更容易维护；</li><li>变更引起的风险降低，变更是必不可少的，接口的单一职责做的好的话，一个接口修改只对相应的实现类有影响。</li></ul><h3 id="进行优化"><a href="#进行优化" class="headerlink" title="进行优化"></a>进行优化</h3><h3 id="包括开闭原则，依赖倒转，-李氏代还-接口隔离，合用复用问题方式同上"><a href="#包括开闭原则，依赖倒转，-李氏代还-接口隔离，合用复用问题方式同上" class="headerlink" title="包括开闭原则，依赖倒转， 李氏代还 接口隔离，合用复用问题方式同上"></a>包括开闭原则，依赖倒转， 李氏代还 接口隔离，合用复用问题方式同上</h3><h3 id="迪米特法则-对象其朋友分类，5类（不涉及大题）"><a href="#迪米特法则-对象其朋友分类，5类（不涉及大题）" class="headerlink" title="迪米特法则 对象其朋友分类，5类（不涉及大题）"></a>迪米特法则 对象其朋友分类，5类（不涉及大题）</h3><ul><li>在迪米特法则中，对于一个对象，其朋友包括以下几类：</li></ul><ol><li>当前对象本身(this)；</li><li>以参数形式传入到当前对象方法中的对象；</li><li>当前对象的成员对象；</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</li><li>当前对象所创建的对象。</li></ol><ul><li>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”<h3 id="grasp模式"><a href="#grasp模式" class="headerlink" title="grasp模式"></a>grasp模式</h3><h3 id="给一个设计方案，应用grasp模式进行评价和改进。"><a href="#给一个设计方案，应用grasp模式进行评价和改进。" class="headerlink" title="给一个设计方案，应用grasp模式进行评价和改进。"></a>给一个设计方案，应用grasp模式进行评价和改进。</h3><h3 id="创建者模式，信息专家，低耦合，控制器，高内聚-名称问题解决方案。"><a href="#创建者模式，信息专家，低耦合，控制器，高内聚-名称问题解决方案。" class="headerlink" title="创建者模式，信息专家，低耦合，控制器，高内聚 名称问题解决方案。"></a>创建者模式，信息专家，低耦合，控制器，高内聚 名称问题解决方案。</h3></li></ul><h3 id="控制器的两种方式，什么时候使用"><a href="#控制器的两种方式，什么时候使用" class="headerlink" title="控制器的两种方式，什么时候使用"></a>控制器的两种方式，什么时候使用</h3><ul><li>外观控制器<ul><li>它代表了整个系统，设备或一个子系统。</li><li>它提供了从UI层往其他层的服务调用的主要入口 <ul><li>对整个物理单元的抽象，例如Register, TelecommSwitch, Phone 或 Robot</li><li>代表了整个软件系统的类，例如POSSystem</li><li>设计者选择用来表示整个系统，子系统的其他概念，例如如果是一个游戏软件，选择ChessGame。</li></ul></li><li>什么时候选择外观控制器?<ul><li>当没有“过多”的系统事件，或者UI不能把系统事件消息重定向到其他控制器（如在消息处理系统中）时，选择外观控制器是合适的。</li></ul></li></ul></li><li>用例控制器<ul><li>对每一个用例设置一个单独的控制器。</li><li>这是支持系统的人工造物。<ul><li>例如，在NextGen应用中，例如Process Sale 等用例可以与 ProcessSaleHandler 类关联。</li></ul></li><li>什么时候选择用例控制器?<ul><li>当有太多的系统事件并设计不同的过程，用例控制器是一个好的选择。它将处理它们的任务分配给那些可管理的单独的类，也提供了一个获知和推理目前进行中的场景的当前状态的基础。</li></ul></li></ul></li></ul><h3 id="浮肿的控制器的征兆，解决方案"><a href="#浮肿的控制器的征兆，解决方案" class="headerlink" title="浮肿的控制器的征兆，解决方案"></a>浮肿的控制器的征兆，解决方案</h3><ul><li>“浮肿的”控制器（Bloated Controllers）<ul><li>如果设计得不合理，控制类内聚性不强-不聚焦并处理了太多领域的责任。</li></ul></li><li>症兆<ul><li>一个控制类接收所有的系统事件。</li><li>控制类自己处理了完成系统事件所需要的太多任务。</li><li>控制器有太多的属性并维持了系统或领域的信息。</li></ul></li><li>解决办法<ul><li>增加控制器（使用用例控制器，非外观控制器）。</li><li>设计控制器：把职责委派给其他对象。</li></ul></li></ul><h2 id="第19章"><a href="#第19章" class="headerlink" title="第19章"></a>第19章</h2><h3 id="对象之间可见性"><a href="#对象之间可见性" class="headerlink" title="对象之间可见性"></a>对象之间可见性</h3><ul><li>可见性Visibility 是对象看到或引用其它对象的能力。</li><li>为了使发送者对象能够向接收者对象发送消息，发送者必须具有接收者的可见性，即发送者必须拥有对接收者对象的某种引用或指针。</li></ul><p>例如：Register发送getProductDescription到ProductCatelog意味着ProductCatalog实例对于Register实例来说是可见的。</p><h3 id="可见性四种方式"><a href="#可见性四种方式" class="headerlink" title="可见性四种方式"></a>可见性四种方式</h3><ul><li>实现对象A到对象B的可见性通常有四种方式:<ul><li>属性可见性Attribute Visibility: B是A的属性。</li><li>参数可见性Parameter visibility: B是A方法中的参数。</li><li>局部可见性Local Visibility: B是A中方法的局部对象（不是参数）。</li><li>全局可见性Global Visibility: B具有某种方式的全局可见性。</li></ul></li><li>动机：为了使对象A能够向对象B发送消息，对于A而言，B必须是可见的</li></ul><h2 id="第21章"><a href="#第21章" class="headerlink" title="第21章"></a>第21章</h2><h3 id="坏味代码特点"><a href="#坏味代码特点" class="headerlink" title="坏味代码特点"></a>坏味代码特点</h3><ul><li>冗余的代码。</li><li>大型方法。</li><li>具有大量实例变量的类。</li><li>具有大量代码的类。</li><li>明显相似的子类。</li><li>在设计中很少使用或者没有使用接口。</li><li>许多对象之间有很多的耦合度。</li><li>包含大量其他的垃圾代码…。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> 笔记整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_tree</title>
      <link href="/2020/06/18/leetcode-tree/"/>
      <url>/2020/06/18/leetcode-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-树的遍历"><a href="#leetcode-树的遍历" class="headerlink" title="leetcode-树的遍历"></a>leetcode-树的遍历</h1><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200618231923.png" alt="20200618231923"></p><h3 id="解法1：采用递归"><a href="#解法1：采用递归" class="headerlink" title="解法1：采用递归"></a>解法1：采用递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        preorderTraversal(root-&gt;left);</span><br><span class="line">        preorderTraversal(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法二：借用栈，迭代算法"><a href="#解法二：借用栈，迭代算法" class="headerlink" title="解法二：借用栈，迭代算法"></a>解法二：借用栈，迭代算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; call;</span><br><span class="line">        call.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!call.empty())&#123;</span><br><span class="line">            TreeNode* temnode = call.top();</span><br><span class="line">            call.pop();</span><br><span class="line">            <span class="keyword">if</span> (temnode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temnode-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    call.push(temnode-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (temnode-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    call.push(temnode-&gt;left);</span><br><span class="line">                call.push(temnode);</span><br><span class="line">                call.push(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result.push_back(call.top()-&gt;val);</span><br><span class="line">                call.pop();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200618232220.png" alt="20200618232220"></p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>解法同样有两种，一种是采用递归，但时间代价大，而且与前序遍历递归相似。采用迭代方法解决同样也跟前序遍历的代码相似，但相比递归不易爆栈，花费时间代价小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; call;</span><br><span class="line">        call.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!call.empty())&#123;</span><br><span class="line">            TreeNode* t = call.top();</span><br><span class="line">            call.pop();</span><br><span class="line">            <span class="keyword">if</span> (t)&#123;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) call.push(t-&gt;right);</span><br><span class="line">            call.push(t);</span><br><span class="line">            call.push(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) call.push(t-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.push_back(call.top()-&gt;val);</span><br><span class="line">            call.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200618232553.png" alt="20200618232553"></p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; call;</span><br><span class="line">        call.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!call.empty())&#123;</span><br><span class="line">            TreeNode* t = call.top();</span><br><span class="line">            call.pop();</span><br><span class="line">            <span class="keyword">if</span>(t)&#123;</span><br><span class="line">                call.push(t);</span><br><span class="line">                call.push(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) call.push(t-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) call.push(t-&gt;left);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(call.top()-&gt;val);</span><br><span class="line">                call.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200618232754.png" alt="20200618232754"></p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>宽度优先搜索，使用<strong>queue</strong>容器辅助，而不是再使用<strong>stack</strong>。从而达到遍历结束一层再去遍历下一层的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode *&gt; call;</span><br><span class="line">        call.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!call.empty())&#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">auto</span> <span class="built_in">size</span> = call.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>;i++)&#123;</span><br><span class="line">                TreeNode *tem = call.front();</span><br><span class="line">                call.pop();</span><br><span class="line">                temp.push_back(tem-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tem-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    call.push(tem-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tem-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    call.push(tem-&gt;right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记</title>
      <link href="/2020/06/09/mysql-learn/"/>
      <url>/2020/06/09/mysql-learn/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录MySQL</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysql -u root -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出MySQL数据库服务器</span></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200609213427.png" alt="20200609213427"></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示所有数据库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示数据库中的所有表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pet (</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    owner <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    species <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    sex <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    birth <span class="built_in">DATE</span>,</span><br><span class="line">    death <span class="built_in">DATE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看数据表结构</span></span><br><span class="line"><span class="comment">-- describe pet;</span></span><br><span class="line">desc pet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> pet;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> pet <span class="keyword">VALUES</span> (<span class="string">'puffball'</span>, <span class="string">'Diane'</span>, <span class="string">'hamster'</span>, <span class="string">'f'</span>, <span class="string">'1990-03-30'</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> pet <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'squirrel'</span> <span class="keyword">where</span> owner = <span class="string">'Diane'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> pet <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'squirrel'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> myorder;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据库</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASES</span> <span class="keyword">TEST</span>;</span><br></pre></td></tr></table></figure><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><table><thead><tr><th>数据类型</th><th>字节数</th><th>带符号最小值</th><th>带符号最大值</th><th>不带符号最小值</th><th>不带符号最大值</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128</td><td>127</td><td>0</td><td>255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768</td><td>32767</td><td>0</td><td>65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608</td><td>8388607</td><td>0</td><td>16777215</td></tr><tr><td>INT</td><td>4</td><td>-2147483648</td><td>2147483647</td><td>0</td><td>4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808</td><td>9223372036854775807</td><td>0</td><td>18446744073709551616</td></tr></tbody></table><p>从实际开发的角度，我们<strong>一定要为合适的列选取合适的数据类型</strong>，即到底用不用得到这种数据类型？举个例子：</p><ul><li>一个枚举字段明明只有0和1两个枚举值，选用TINYINT就足够了，但在开发场景下却使用了BIGINT，这就造成了资源浪费</li><li>简单计算一下，假使该数据表中有100W数据，那么总共浪费了700W字节也就是6.7M左右，如果更多的表这么做了，那么浪费的更多<br>要知道，<strong>MySQL本质上是一个存储</strong>，以Java为例，可以使用byte类型的地方使用了long类型问题不大，因为绝大多数的对象在程序中都是短命对象，方法执行完毕这块内存区域就被释放了，7个字节实际上不存在浪不浪费一说。但是MySQL作为一个存储，8字节的BIGINT放那儿就放那儿了，占据的空间是实实在在的。</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> test_tinyint;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_tinyint (</span><br><span class="line">    <span class="keyword">num</span> <span class="built_in">tinyint</span></span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tinyint <span class="keyword">values</span>(<span class="number">-100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tinyint <span class="keyword">values</span>(<span class="number">255</span>);</span><br></pre></td></tr></table></figure><p>执行第7行的代码时候报错”Out of range value for column ‘num’ at row 1”，即很清楚的我们可以看到插入的数字范围越界了，这也同样反映出<strong>MySQL中整型默认是带符号的</strong>。</p><p>把第3行的num字段定义改为”num tinyint unsigned”第7的插入就不会报错了，但是第6行的插入-100又报错了，因为无符号整型是无法表示负数的。</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200609225102.png" alt="20200609225102"></p><h4 id="整型（N）形式"><a href="#整型（N）形式" class="headerlink" title="整型（N）形式"></a>整型（N）形式</h4><p>在开发中，我们会碰到有些定义整型的写法是int(11)，个人认为是没有多大用。</p><p>int(N)需要记住两点：</p><ul><li>无论N等于多少，int永远占4个字节</li><li><strong>N表示的是显示宽度，不足的用0补足，超过的无视长度而直接显示整个数字，但这要整型设置了unsigned zerofill才有效</strong></li></ul><p>下面举个例子，写一段SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> test_int_width;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_int_width (</span><br><span class="line">    a <span class="built_in">int</span>(<span class="number">5</span>),</span><br><span class="line">    b <span class="built_in">int</span>(<span class="number">5</span>) <span class="keyword">unsigned</span>,</span><br><span class="line">    c <span class="built_in">int</span>(<span class="number">5</span>) <span class="keyword">unsigned</span> zerofill,</span><br><span class="line">    d <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">unsigned</span> zerofill</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_int_width <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1111111111</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_int_width;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200609225454.png" alt="20200609225454"></p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table><thead><tr><th>数据类型</th><th>字节数</th><th>备注</th></tr></thead><tbody><tr><td>float</td><td>4</td><td>单精度浮点型</td></tr><tr><td>double</td><td>8</td><td>双精度浮点型</td></tr></tbody></table><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> test_float;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_float (</span><br><span class="line">    <span class="keyword">num</span> <span class="built_in">float</span>(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_float <span class="keyword">values</span>(<span class="number">1.233</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_float <span class="keyword">values</span>(<span class="number">1.237</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_float <span class="keyword">values</span>(<span class="number">10.233</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_float <span class="keyword">values</span>(<span class="number">100.233</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_float <span class="keyword">values</span>(<span class="number">1000.233</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_float <span class="keyword">values</span>(<span class="number">10000.233</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_float <span class="keyword">values</span>(<span class="number">100000.233</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_float;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200609225828.png" alt="20200609225828"></p><p>float(M,D)、double(M、D)的用法规则：</p><ul><li>D表示浮点型数据小数点之后的精度，假如超过D位则四舍五入，即1.233四舍五入为1.23，1.237四舍五入为1.24</li><li>M表示浮点型数据总共的位数，D=2则表示总共支持五位，即小数点前只支持三位数，所以我们并没有看到1000.23、10000.233、100000.233这三条数据的插入，因为插入都报错了</li><li>当我们不指定M、D的时候，会按照实际的精度来处理</li></ul><h3 id="定点型"><a href="#定点型" class="headerlink" title="定点型"></a>定点型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> test_decimal;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_decimal (</span><br><span class="line">    float_num <span class="built_in">float</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    double_num <span class="keyword">double</span>(<span class="number">20</span>, <span class="number">2</span>),</span><br><span class="line">    decimal_num <span class="built_in">decimal</span>(<span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_decimal <span class="keyword">values</span>(<span class="number">1234567.66</span>, <span class="number">1234567899000000.66</span>, <span class="number">1234567899000000.66</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_decimal <span class="keyword">values</span>(<span class="number">1234567.66</span>, <span class="number">12345678990000000.66</span>, <span class="number">12345678990000000.66</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_decimal;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200609230332.png" alt="20200609230332"></p><p>看到float、double类型存在精度丢失问题，即<strong>写入数据库的数据未必是插入数据库的数据</strong>，而decimal无论写入数据中的数据是多少，都不会存在精度丢失问题，这就是我们要引入decimal类型的原因，decimal类型常见于银行系统、互联网金融系统等对小数点后的数字比较敏感的系统中。</p><p>最后讲一下decimal和float/double的区别，个人总结主要体现在两点上：</p><ul><li>float/double在db中存储的是近似值，而decimal则是以字符串形式进行保存的</li><li>decimal(M,D)的规则和float/double相同，但区别在float/double在不指定M、D时默认按照实际精度来处理而decimal在不指定M、D时默认为decimal(10, 0)</li></ul><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><table><thead><tr><th>数据类型</th><th>字节数</th><th>格式</th><th>备注</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>yyyy-MM-dd</td><td>存储日期值</td></tr><tr><td>time</td><td>3</td><td>HH:mm:ss</td><td>存储时分秒</td></tr><tr><td>year</td><td>1</td><td>yyyy</td><td>存储年</td></tr><tr><td>datetime</td><td>8</td><td>yyyy-MM-dd HH:mm:ss</td><td>存储日期+时间</td></tr><tr><td>timestamp</td><td>4</td><td>yyyy-MM-dd HH:mm:ss</td><td>存储日期+时间，可作时间戳</td></tr></tbody></table><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> test_time;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_time (</span><br><span class="line">    date_value <span class="built_in">date</span>,</span><br><span class="line">    time_value <span class="built_in">time</span>,</span><br><span class="line">    year_value <span class="keyword">year</span>,</span><br><span class="line">    datetime_value datetime,</span><br><span class="line">    timestamp_value <span class="built_in">timestamp</span></span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_time <span class="keyword">values</span>(<span class="keyword">now</span>(), <span class="keyword">now</span>(), <span class="keyword">now</span>(), <span class="keyword">now</span>(), <span class="keyword">now</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> test_time;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200609231118.png" alt="20200609231118"></p><p>datetime与timestamp两种类型的区别：</p><ul><li>datetime占8个字节，timestamp占4个字节</li><li>由于大小的区别，datetime与timestamp能存储的时间范围也不同，datetime的存储范围为1000-01-01 00:00:00——9999-12-31 23:59:59，timestamp存储的时间范围为19700101080001——20380119111407</li><li>datetime默认值为空，当插入的值为null时，该列的值就是null；timestamp默认值不为空，当插入的值为null的时候，mysql会取当前时间</li><li>datetime存储的时间与时区无关，timestamp存储的时间及显示的时间都依赖于当前时区</li></ul><p>在实际工作中，一张表往往我们会有两个默认字段，一个记录创建时间而另一个记录最新一次的更新时间，这种时候可以使用timestamp类型来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create_time timestamp default current_timestamp <span class="keyword">comment</span> <span class="string">"创建时间"</span>,</span><br><span class="line">update_time <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">"修改时间"</span>,</span><br></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>char(n) 和 varchar(n) 中括号中 n 代表<strong>字符的个数</strong>，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</li><li>char是固定长度字符串，其长度范围为0<del>255且与编码方式无关，无论字符实际长度是多少，都会按照指定长度存储，不够的用空格补足；varchar为可变长度字符串，在utf8编码的数据库中其长度范围为0</del>21844</li><li>char实际占用的字节数即存储的字符所占用的字节数，varchar实际占用的字节数为存储的字符+1或+2或+3,标记长度会额外占用存储空间。</li><li>MySQL处理char类型数据时会将结尾的所有空格处理掉而varchar类型数据则不会。</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> test_string;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_string (</span><br><span class="line">    char_value <span class="built_in">char</span>(<span class="number">5</span>),</span><br><span class="line">    varchar_value <span class="built_in">varchar</span>(<span class="number">5</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_string <span class="keyword">values</span>(<span class="string">'a'</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_string <span class="keyword">values</span>(<span class="string">' a'</span>, <span class="string">' a'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_string <span class="keyword">values</span>(<span class="string">'a '</span>, <span class="string">'a '</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_string <span class="keyword">values</span>(<span class="string">' a '</span>, <span class="string">' a '</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">length</span>(char_value), <span class="keyword">length</span>(varchar_value) <span class="keyword">from</span> test_string;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200609232930.png" alt="20200609232930"></p><h2 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><p>他能够唯一确定一张表中的一条记录，也就是我们通过给某个字段添加约束，就可以使得该字段不重复且不为空。</p><ul><li><p>主键约束</p><p>  使某个字段不重复且不得为空，确保表内所有数据的唯一性。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200610182214.png" alt="20200610182214"></p><ul><li><p>联合主键</p><p>  联合主键中的每个字段都不能为空，并且 。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">password</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>, <span class="keyword">name</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200610220243.png" alt="20200610220243"></p><h3 id="自增约束"><a href="#自增约束" class="headerlink" title="自增约束"></a>自增约束</h3><ul><li>自增约束的主键由系统自动递增分配。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200610220308.png" alt="20200610220308"></p><ul><li><p><strong>添加主键约束</strong></p><p>  如果忘记设置主键，还可以通过SQL语句设置（两种方式）：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">drop</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>约束修饰的字段的值不可以重复。</p><ul><li>建表时创建唯一主键<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span>(<span class="keyword">name</span>)</span><br><span class="line">    <span class="comment">-- 或者可以写 UNIQUE(id,name)</span></span><br><span class="line">    <span class="comment">-- 此时 id 跟 name 组合在一起不重复就行</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>或者<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>事后添加唯一约束<br>如果建表时没有设置唯一约束，还可以通过SQL语句设置（两种方式）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">MODIFY</span> <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除唯一约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">DROP</span> <span class="keyword">INDEX</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p>建表时添加非空约束来约束某个字段不能为空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'张三'</span>);</span><br></pre></td></tr></table></figure><p>移除非空约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">MODIFY</span> <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619161208.png" alt="20200619161208"></p><h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><p>建表时添加默认约束来约束某个字段的默认值。<br>当我们插入字段值的时候，如果没有传值，就会使用默认值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user2 (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">10</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2 (<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user2 <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'wangwei'</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>移除默认约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">MODIFY</span> age <span class="built_in">INT</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619161609.png" alt="20200619161609"></p><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>涉及到两个表：父表，子表（主表，副表）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 班级</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> classes (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> classes <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'一班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> classes <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'二班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> classes <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'三班'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> classes <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'四班'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="comment">-- 这里的 class_id 要和 classes 中的 id 字段相关联</span></span><br><span class="line">    class_id <span class="built_in">INT</span>,</span><br><span class="line">    <span class="comment">-- 表示 class_id 的值必须来自于 classes 中的 id 字段值</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(class_id) <span class="keyword">REFERENCES</span> classes(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="number">1001</span>,<span class="string">'张三'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="number">1002</span>,<span class="string">'张三'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="number">1003</span>,<span class="string">'张三'</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="number">1004</span>,<span class="string">'张三'</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">--错误示范：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="number">1005</span>,<span class="string">'lisi'</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200619163818.png" alt="20200619163818"></p><ol><li>主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；</li><li>主表中的记录被副表引用时，主表不可以被删除。</li></ol><h2 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>只要字段值还可以继续拆分，就不满足第一范式。</p><p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 订单表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myorder (</span><br><span class="line">    product_id <span class="built_in">INT</span>,</span><br><span class="line">    customer_id <span class="built_in">INT</span>,</span><br><span class="line">    product_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    customer_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (product_id, customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p><p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myorder (</span><br><span class="line">    order_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    product_id <span class="built_in">INT</span>,</span><br><span class="line">    customer_id <span class="built_in">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myorder (</span><br><span class="line">    order_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    product_id <span class="built_in">INT</span>,</span><br><span class="line">    customer_id <span class="built_in">INT</span>,</span><br><span class="line">    customer_phone <span class="built_in">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myorder (</span><br><span class="line">    order_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    product_id <span class="built_in">INT</span>,</span><br><span class="line">    customer_id <span class="built_in">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    phone <span class="built_in">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p><h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> select_test;</span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="keyword">USE</span> select_test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    <span class="keyword">no</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    sex <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span>, <span class="comment">-- 生日</span></span><br><span class="line">    <span class="keyword">class</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="comment">-- 所在班级</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建教师表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teacher (</span><br><span class="line">    <span class="keyword">no</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    sex <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span>,</span><br><span class="line">    profession <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">-- 职称</span></span><br><span class="line">    department <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="comment">-- 部门</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建课程表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course (</span><br><span class="line">    <span class="keyword">no</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    t_no <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">-- 教师编号</span></span><br><span class="line">    <span class="comment">-- 表示该 tno 来自于 teacher 表中的 no 字段值</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(t_no) <span class="keyword">REFERENCES</span> teacher(<span class="keyword">no</span>) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成绩表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> score (</span><br><span class="line">    s_no <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">-- 学生编号</span></span><br><span class="line">    c_no <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">-- 课程号</span></span><br><span class="line">    degree <span class="built_in">DECIMAL</span>,<span class="comment">-- 成绩</span></span><br><span class="line">    <span class="comment">-- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(s_no) <span class="keyword">REFERENCES</span> student(<span class="keyword">no</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(c_no) <span class="keyword">REFERENCES</span> course(<span class="keyword">no</span>),</span><br><span class="line">    <span class="comment">-- 设置 s_no, c_no 为联合主键</span></span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(s_no, c_no)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看所有表</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加学生表数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">'101'</span>, <span class="string">'曾华'</span>, <span class="string">'男'</span>, <span class="string">'1977-09-01'</span>, <span class="string">'95033'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">'102'</span>, <span class="string">'匡明'</span>, <span class="string">'男'</span>, <span class="string">'1975-10-02'</span>, <span class="string">'95031'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">'103'</span>, <span class="string">'王丽'</span>, <span class="string">'女'</span>, <span class="string">'1976-01-23'</span>, <span class="string">'95033'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">'104'</span>, <span class="string">'李军'</span>, <span class="string">'男'</span>, <span class="string">'1976-02-20'</span>, <span class="string">'95033'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">'105'</span>, <span class="string">'王芳'</span>, <span class="string">'女'</span>, <span class="string">'1975-02-10'</span>, <span class="string">'95031'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">'106'</span>, <span class="string">'陆军'</span>, <span class="string">'男'</span>, <span class="string">'1974-06-03'</span>, <span class="string">'95031'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">'107'</span>, <span class="string">'王尼玛'</span>, <span class="string">'男'</span>, <span class="string">'1976-02-20'</span>, <span class="string">'95033'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">'108'</span>, <span class="string">'张全蛋'</span>, <span class="string">'男'</span>, <span class="string">'1975-02-10'</span>, <span class="string">'95031'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">'109'</span>, <span class="string">'赵铁柱'</span>, <span class="string">'男'</span>, <span class="string">'1974-06-03'</span>, <span class="string">'95031'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加教师表数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher <span class="keyword">VALUES</span>(<span class="string">'804'</span>, <span class="string">'李诚'</span>, <span class="string">'男'</span>, <span class="string">'1958-12-02'</span>, <span class="string">'副教授'</span>, <span class="string">'计算机系'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher <span class="keyword">VALUES</span>(<span class="string">'856'</span>, <span class="string">'张旭'</span>, <span class="string">'男'</span>, <span class="string">'1969-03-12'</span>, <span class="string">'讲师'</span>, <span class="string">'电子工程系'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher <span class="keyword">VALUES</span>(<span class="string">'825'</span>, <span class="string">'王萍'</span>, <span class="string">'女'</span>, <span class="string">'1972-05-05'</span>, <span class="string">'助教'</span>, <span class="string">'计算机系'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher <span class="keyword">VALUES</span>(<span class="string">'831'</span>, <span class="string">'刘冰'</span>, <span class="string">'女'</span>, <span class="string">'1977-08-14'</span>, <span class="string">'助教'</span>, <span class="string">'电子工程系'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加课程表数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(<span class="string">'3-105'</span>, <span class="string">'计算机导论'</span>, <span class="string">'825'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(<span class="string">'3-245'</span>, <span class="string">'操作系统'</span>, <span class="string">'804'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(<span class="string">'6-166'</span>, <span class="string">'数字电路'</span>, <span class="string">'856'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(<span class="string">'9-888'</span>, <span class="string">'高等数学'</span>, <span class="string">'831'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加添加成绩表数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span>(<span class="string">'103'</span>, <span class="string">'3-105'</span>, <span class="string">'92'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span>(<span class="string">'103'</span>, <span class="string">'3-245'</span>, <span class="string">'86'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span>(<span class="string">'103'</span>, <span class="string">'6-166'</span>, <span class="string">'85'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span>(<span class="string">'105'</span>, <span class="string">'3-105'</span>, <span class="string">'88'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span>(<span class="string">'105'</span>, <span class="string">'3-245'</span>, <span class="string">'75'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span>(<span class="string">'105'</span>, <span class="string">'6-166'</span>, <span class="string">'79'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span>(<span class="string">'109'</span>, <span class="string">'3-105'</span>, <span class="string">'76'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span>(<span class="string">'109'</span>, <span class="string">'3-245'</span>, <span class="string">'68'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span>(<span class="string">'109'</span>, <span class="string">'6-166'</span>, <span class="string">'81'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> course;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> teacher;</span><br></pre></td></tr></table></figure><h3 id="1-到-10"><a href="#1-到-10" class="headerlink" title="1 到 10"></a>1 到 10</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 student 表的所有行</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 student 表中的 name、sex 和 class 字段的所有行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, sex, <span class="keyword">class</span> <span class="keyword">FROM</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 teacher 表中不重复的 department 列</span></span><br><span class="line"><span class="comment">-- department: 去重查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department <span class="keyword">FROM</span> teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）</span></span><br><span class="line"><span class="comment">-- BETWEEN xx AND xx: 查询区间, AND 表示 "并且"</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> degree <span class="keyword">BETWEEN</span> <span class="number">60</span> <span class="keyword">AND</span> <span class="number">80</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> degree &gt; <span class="number">60</span> <span class="keyword">AND</span> degree &lt; <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 score 表中成绩为 85, 86 或 88 的行</span></span><br><span class="line"><span class="comment">-- IN: 查询规定中的多个值</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> degree <span class="keyword">IN</span> (<span class="number">85</span>, <span class="number">86</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 student 表中 '95031' 班或性别为 '女' 的所有行</span></span><br><span class="line"><span class="comment">-- or: 表示或者关系</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">class</span> = <span class="string">'95031'</span> <span class="keyword">or</span> sex = <span class="string">'女'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以 class 降序的方式查询 student 表的所有行</span></span><br><span class="line"><span class="comment">-- DESC: 降序，从高到低</span></span><br><span class="line"><span class="comment">-- ASC（默认）: 升序，从低到高</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">class</span> <span class="keyword">DESC</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">class</span> <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以 c_no 升序、degree 降序查询 score 表的所有行</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">ORDER</span> <span class="keyword">BY</span> c_no <span class="keyword">ASC</span>, degree <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 "95031" 班的学生人数</span></span><br><span class="line"><span class="comment">-- COUNT: 统计</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">class</span> = <span class="string">'95031'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。</span></span><br><span class="line"><span class="comment">-- (SELECT MAX(degree) FROM score): 子查询，算出最高分</span></span><br><span class="line"><span class="keyword">SELECT</span> s_no, c_no <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> degree = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(degree) <span class="keyword">FROM</span> score);</span><br><span class="line"></span><br><span class="line"><span class="comment">--  排序查询</span></span><br><span class="line"><span class="comment">-- LIMIT r, n: 表示从第r行开始，查询n条数据</span></span><br><span class="line"><span class="comment">-- LIMIT: 左开右闭区间</span></span><br><span class="line"><span class="keyword">SELECT</span> s_no, c_no, degree <span class="keyword">FROM</span> score <span class="keyword">ORDER</span> <span class="keyword">BY</span> degree <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="分组计算平均成绩"><a href="#分组计算平均成绩" class="headerlink" title="分组计算平均成绩"></a>分组计算平均成绩</h3><p><strong>查询每门课的平均成绩。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- AVG: 平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(degree) <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = <span class="string">'3-105'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(degree) <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = <span class="string">'3-245'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(degree) <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = <span class="string">'6-166'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- GROUP BY: 分组查询</span></span><br><span class="line"><span class="keyword">SELECT</span> c_no, <span class="keyword">AVG</span>(degree) <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no;</span><br></pre></td></tr></table></figure><h3 id="分组条件与模糊查询"><a href="#分组条件与模糊查询" class="headerlink" title="分组条件与模糊查询"></a>分组条件与模糊查询</h3><p><strong>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score;</span><br><span class="line"><span class="comment">-- c_no 课程编号</span></span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先把 c_no, AVG(degree) 通过分组查询出来</span></span><br><span class="line"><span class="keyword">SELECT</span> c_no, <span class="keyword">AVG</span>(degree) <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no</span><br><span class="line">+<span class="comment">-------+-------------+</span></span><br><span class="line">| c_no  | <span class="keyword">AVG</span>(degree) |</span><br><span class="line">+<span class="comment">-------+-------------+</span></span><br><span class="line">| <span class="number">3</span><span class="number">-105</span> |     <span class="number">85.3333</span> |</span><br><span class="line">| <span class="number">3</span><span class="number">-245</span> |     <span class="number">76.3333</span> |</span><br><span class="line">| <span class="number">6</span><span class="number">-166</span> |     <span class="number">81.6667</span> |</span><br><span class="line">+<span class="comment">-------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再查询出至少有 2 名学生选修的课程</span></span><br><span class="line"><span class="comment">-- HAVING: 表示持有</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(c_no) &gt;= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 并且是以 3 开头的课程</span></span><br><span class="line"><span class="comment">-- LIKE 表示模糊查询，"%" 是一个通配符，匹配 "3" 后面的任意字符。</span></span><br><span class="line"><span class="keyword">AND</span> c_no <span class="keyword">LIKE</span> <span class="string">'3%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把前面的SQL语句拼接起来，</span></span><br><span class="line"><span class="comment">-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。</span></span><br><span class="line"><span class="keyword">SELECT</span> c_no, <span class="keyword">AVG</span>(degree), <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(c_no) &gt;= <span class="number">2</span> <span class="keyword">AND</span> c_no <span class="keyword">LIKE</span> <span class="string">'3%'</span>;</span><br><span class="line">+<span class="comment">-------+-------------+----------+</span></span><br><span class="line">| c_no  | AVG(degree) | COUNT(*) |</span><br><span class="line">+<span class="comment">-------+-------------+----------+</span></span><br><span class="line">| 3-105 |     85.3333 |        3 |</span><br><span class="line">| 3-245 |     76.3333 |        3 |</span><br><span class="line">+<span class="comment">-------+-------------+----------+</span></span><br></pre></td></tr></table></figure><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询 - 1"></a>多表查询 - 1</h3><p><strong>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">no</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> student;</span><br><span class="line">+<span class="comment">-----+-----------+</span></span><br><span class="line">| no  | name      |</span><br><span class="line">+<span class="comment">-----+-----------+</span></span><br><span class="line">| 101 | 曾华      |</span><br><span class="line">| 102 | 匡明      |</span><br><span class="line">| 103 | 王丽      |</span><br><span class="line">| 104 | 李军      |</span><br><span class="line">| 105 | 王芳      |</span><br><span class="line">| 106 | 陆军      |</span><br><span class="line">| 107 | 王尼玛    |</span><br><span class="line">| 108 | 张全蛋    |</span><br><span class="line">| 109 | 赵铁柱    |</span><br><span class="line">+<span class="comment">-----+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> s_no, c_no, degree <span class="keyword">FROM</span> score;</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- FROM...: 表示从 student, score 表中查询</span></span><br><span class="line"><span class="comment">-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, c_no, degree <span class="keyword">FROM</span> student, score </span><br><span class="line"><span class="keyword">WHERE</span> student.no = score.s_no;</span><br><span class="line">+<span class="comment">-----------+-------+--------+</span></span><br><span class="line">| name      | c_no  | degree |</span><br><span class="line">+<span class="comment">-----------+-------+--------+</span></span><br><span class="line">| 王丽      | 3-105 |     92 |</span><br><span class="line">| 王丽      | 3-245 |     86 |</span><br><span class="line">| 王丽      | 6-166 |     85 |</span><br><span class="line">| 王芳      | 3-105 |     88 |</span><br><span class="line">| 王芳      | 3-245 |     75 |</span><br><span class="line">| 王芳      | 6-166 |     79 |</span><br><span class="line">| 赵铁柱    | 3-105 |     76 |</span><br><span class="line">| 赵铁柱    | 3-245 |     68 |</span><br><span class="line">| 赵铁柱    | 6-166 |     81 |</span><br><span class="line">+<span class="comment">-----------+-------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="多表查询-2"><a href="#多表查询-2" class="headerlink" title="多表查询 - 2"></a>多表查询 - 2</h3><p><strong>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p><p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_no, c_no, degree <span class="keyword">FROM</span> score;</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><p>然后查询 <code>course</code> 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">-------+-----------------+</span></span><br><span class="line">| no    | name            |</span><br><span class="line">+<span class="comment">-------+-----------------+</span></span><br><span class="line">| 3-105 | 计算机导论      |</span><br><span class="line">| 3-245 | 操作系统        |</span><br><span class="line">| 6-166 | 数字电路        |</span><br><span class="line">| 9-888 | 高等数学        |</span><br><span class="line">+<span class="comment">-------+-----------------+</span></span><br></pre></td></tr></table></figure><p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。</span></span><br><span class="line"><span class="comment">-- as 表示取一个该字段的别名。</span></span><br><span class="line"><span class="keyword">SELECT</span> s_no, <span class="keyword">name</span> <span class="keyword">as</span> c_name, degree <span class="keyword">FROM</span> score, course</span><br><span class="line"><span class="keyword">WHERE</span> score.c_no = course.no;</span><br><span class="line">+<span class="comment">------+-----------------+--------+</span></span><br><span class="line">| s_no | c_name          | degree |</span><br><span class="line">+<span class="comment">------+-----------------+--------+</span></span><br><span class="line">| 103  | 计算机导论      |     92 |</span><br><span class="line">| 105  | 计算机导论      |     88 |</span><br><span class="line">| 109  | 计算机导论      |     76 |</span><br><span class="line">| 103  | 操作系统        |     86 |</span><br><span class="line">| 105  | 操作系统        |     75 |</span><br><span class="line">| 109  | 操作系统        |     68 |</span><br><span class="line">| 103  | 数字电路        |     85 |</span><br><span class="line">| 105  | 数字电路        |     79 |</span><br><span class="line">| 109  | 数字电路        |     81 |</span><br><span class="line">+<span class="comment">------+-----------------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="三表关联查询"><a href="#三表关联查询" class="headerlink" title="三表关联查询"></a>三表关联查询</h3><p><strong>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p><p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score;</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p><p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, c_no, degree <span class="keyword">FROM</span> student, score <span class="keyword">WHERE</span> student.no = score.s_no;</span><br><span class="line">+<span class="comment">-----------+-------+--------+</span></span><br><span class="line">| name      | c_no  | degree |</span><br><span class="line">+<span class="comment">-----------+-------+--------+</span></span><br><span class="line">| 王丽      | 3-105 |     92 |</span><br><span class="line">| 王丽      | 3-245 |     86 |</span><br><span class="line">| 王丽      | 6-166 |     85 |</span><br><span class="line">| 王芳      | 3-105 |     88 |</span><br><span class="line">| 王芳      | 3-245 |     75 |</span><br><span class="line">| 王芳      | 6-166 |     79 |</span><br><span class="line">| 赵铁柱    | 3-105 |     76 |</span><br><span class="line">| 赵铁柱    | 3-245 |     68 |</span><br><span class="line">| 赵铁柱    | 6-166 |     81 |</span><br><span class="line">+<span class="comment">-----------+-------+--------+</span></span><br></pre></td></tr></table></figure><p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 课程表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">no</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> course;</span><br><span class="line">+<span class="comment">-------+-----------------+</span></span><br><span class="line">| no    | name            |</span><br><span class="line">+<span class="comment">-------+-----------------+</span></span><br><span class="line">| 3-105 | 计算机导论      |</span><br><span class="line">| 3-245 | 操作系统        |</span><br><span class="line">| 6-166 | 数字电路        |</span><br><span class="line">| 9-888 | 高等数学        |</span><br><span class="line">+<span class="comment">-------+-----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 由于字段名存在重复，使用 "表名.字段名 as 别名" 代替。</span></span><br><span class="line"><span class="keyword">SELECT</span> student.name <span class="keyword">as</span> s_name, course.name <span class="keyword">as</span> c_name, degree </span><br><span class="line"><span class="keyword">FROM</span> student, score, course</span><br><span class="line"><span class="keyword">WHERE</span> student.NO = score.s_no</span><br><span class="line"><span class="keyword">AND</span> score.c_no = course.no;</span><br></pre></td></tr></table></figure><h3 id="子查询加分组求平均分"><a href="#子查询加分组求平均分" class="headerlink" title="子查询加分组求平均分"></a>子查询加分组求平均分</h3><p><strong>查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p><p>在 <code>score</code> 表中根据 <code>student</code>  表的学生编号筛选出学生的课堂号和成绩：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN (..): 将筛选出的学生号当做 s_no 的条件查询</span></span><br><span class="line"><span class="keyword">SELECT</span> s_no, c_no, degree <span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> s_no <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">class</span> = <span class="string">'95031'</span>);</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c_no, <span class="keyword">AVG</span>(degree) <span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> s_no <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">class</span> = <span class="string">'95031'</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no;</span><br><span class="line">+<span class="comment">-------+-------------+</span></span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+<span class="comment">-------+-------------+</span></span><br><span class="line">| 3-105 |     82.0000 |</span><br><span class="line">| 3-245 |     71.5000 |</span><br><span class="line">| 6-166 |     80.0000 |</span><br><span class="line">+<span class="comment">-------+-------------+</span></span><br></pre></td></tr></table></figure><h3 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询 - 1"></a>子查询 - 1</h3><p><strong>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p><p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score </span><br><span class="line"><span class="keyword">WHERE</span> c_no = <span class="string">'3-105'</span></span><br><span class="line"><span class="keyword">AND</span> degree &gt; (<span class="keyword">SELECT</span> degree <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> s_no = <span class="string">'109'</span> <span class="keyword">AND</span> c_no = <span class="string">'3-105'</span>);</span><br></pre></td></tr></table></figure><h3 id="子查询-2"><a href="#子查询-2" class="headerlink" title="子查询 - 2"></a>子查询 - 2</h3><p><strong>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> degree &gt; (<span class="keyword">SELECT</span> degree <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> s_no = <span class="string">'109'</span> <span class="keyword">AND</span> c_no = <span class="string">'3-105'</span>);</span><br></pre></td></tr></table></figure><h3 id="YEAR-函数与带-IN-关键字查询"><a href="#YEAR-函数与带-IN-关键字查询" class="headerlink" title="YEAR 函数与带 IN 关键字查询"></a>YEAR 函数与带 IN 关键字查询</h3><p><strong>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- YEAR(..): 取出日期中的年份</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">no</span>, <span class="keyword">name</span>, birthday <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(birthday) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(birthday) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="keyword">IN</span> (<span class="number">101</span>, <span class="number">108</span>));</span><br></pre></td></tr></table></figure><h3 id="多层嵌套子查询"><a href="#多层嵌套子查询" class="headerlink" title="多层嵌套子查询"></a>多层嵌套子查询</h3><p><strong>查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</strong></p><p>首先找到教师编号：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NO</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'张旭'</span></span><br></pre></td></tr></table></figure><p>通过 <code>sourse</code> 表找到该教师课程号：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NO</span> <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> t_no = ( <span class="keyword">SELECT</span> <span class="keyword">NO</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'张旭'</span> );</span><br></pre></td></tr></table></figure><p>通过筛选出的课程号查询成绩表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> t_no = ( </span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'张旭'</span> </span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>查询某选修课程多于5个同学的教师姓名。</strong></p><p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 teacher 表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">no</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> teacher;</span><br><span class="line">+<span class="comment">-----+--------+</span></span><br><span class="line">| no  | name   |</span><br><span class="line">+<span class="comment">-----+--------+</span></span><br><span class="line">| 804 | 李诚   |</span><br><span class="line">| 825 | 王萍   |</span><br><span class="line">| 831 | 刘冰   |</span><br><span class="line">| 856 | 张旭   |</span><br><span class="line">+<span class="comment">-----+--------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="comment">-- 在这里找到对应的条件</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>查看和教师编号有有关的表的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> course;</span><br><span class="line"><span class="comment">-- t_no: 教师编号</span></span><br><span class="line">+<span class="comment">-------+-----------------+------+</span></span><br><span class="line">| no    | name            | t_no |</span><br><span class="line">+<span class="comment">-------+-----------------+------+</span></span><br><span class="line">| 3-105 | 计算机导论      | 825  |</span><br><span class="line">| 3-245 | 操作系统        | 804  |</span><br><span class="line">| 6-166 | 数字电路        | 856  |</span><br><span class="line">| 9-888 | 高等数学        | 831  |</span><br><span class="line">+<span class="comment">-------+-----------------+------+</span></span><br></pre></td></tr></table></figure><p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在此之前向 score 插入一些数据，以便丰富查询条件。</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span> (<span class="string">'101'</span>, <span class="string">'3-105'</span>, <span class="string">'90'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span> (<span class="string">'102'</span>, <span class="string">'3-105'</span>, <span class="string">'91'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score <span class="keyword">VALUES</span> (<span class="string">'104'</span>, <span class="string">'3-105'</span>, <span class="string">'89'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 score 表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score;</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 103  | 6-166 |     85 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。</span></span><br><span class="line"><span class="keyword">SELECT</span> c_no <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">5</span>;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| c_no  |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| 3-105 |</span><br><span class="line">+<span class="comment">-------+</span></span><br></pre></td></tr></table></figure><p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_no <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> c_no <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">5</span></span><br><span class="line">);</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| t_no |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 825  |</span><br><span class="line">+<span class="comment">------+</span></span><br></pre></td></tr></table></figure><p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="comment">-- 最终条件</span></span><br><span class="line">    <span class="keyword">SELECT</span> t_no <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="keyword">IN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> c_no <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">5</span></span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="子查询-3"><a href="#子查询-3" class="headerlink" title="子查询 - 3"></a>子查询 - 3</h3><p><strong>查询 “计算机系” 课程的成绩表。</strong></p><p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 通过 teacher 表查询所有 `计算机系` 的教师编号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">no</span>, <span class="keyword">name</span>, department <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> department = <span class="string">'计算机系'</span></span><br><span class="line">+<span class="comment">-----+--------+--------------+</span></span><br><span class="line">| <span class="keyword">no</span>  | <span class="keyword">name</span>   | department   |</span><br><span class="line">+<span class="comment">-----+--------+--------------+</span></span><br><span class="line">| <span class="number">804</span> | 李诚   | 计算机系     |</span><br><span class="line">| <span class="number">825</span> | 王萍   | 计算机系     |</span><br><span class="line">+<span class="comment">-----+--------+--------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过 course 表查询该教师的课程编号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> t_no <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> department = <span class="string">'计算机系'</span></span><br><span class="line">);</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| no    |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| 3-245 |</span><br><span class="line">| 3-105 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据筛选出来的课程号查询成绩表</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> t_no <span class="keyword">IN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> department = <span class="string">'计算机系'</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="UNION-和-NOTIN-的使用"><a href="#UNION-和-NOTIN-的使用" class="headerlink" title="UNION 和 NOTIN 的使用"></a>UNION 和 NOTIN 的使用</h3><p><strong>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- NOT: 代表逻辑非</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> department = <span class="string">'计算机系'</span> <span class="keyword">AND</span> profession <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> profession <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> department = <span class="string">'电子工程系'</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 合并两个集</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> department = <span class="string">'电子工程系'</span> <span class="keyword">AND</span> profession <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> profession <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> department = <span class="string">'计算机系'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="ANY-表示至少一个-DESC-降序"><a href="#ANY-表示至少一个-DESC-降序" class="headerlink" title="ANY 表示至少一个 - DESC ( 降序 )"></a>ANY 表示至少一个 - DESC ( 降序 )</h3><p><strong>查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = <span class="string">'3-105'</span>;</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = <span class="string">'3-245'</span>;</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 103  | 3-245 |     86 |</span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ANY: 符合SQL语句中的任意条件。</span></span><br><span class="line"><span class="comment">-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，</span></span><br><span class="line"><span class="comment">-- 最后根据降序查询结果。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = <span class="string">'3-105'</span> <span class="keyword">AND</span> degree &gt; <span class="keyword">ANY</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> degree <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = <span class="string">'3-245'</span></span><br><span class="line">) <span class="keyword">ORDER</span> <span class="keyword">BY</span> degree <span class="keyword">DESC</span>;</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="表示所有的-ALL"><a href="#表示所有的-ALL" class="headerlink" title="表示所有的 ALL"></a>表示所有的 ALL</h3><p><strong>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只需对上一道题稍作修改。</span></span><br><span class="line"><span class="comment">-- ALL: 符合SQL语句中的所有条件。</span></span><br><span class="line"><span class="comment">-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = <span class="string">'3-105'</span> <span class="keyword">AND</span> degree &gt; <span class="keyword">ALL</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> degree <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = <span class="string">'3-245'</span></span><br><span class="line">);</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 105  | 3-105 |     88 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h3><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询平均分</span></span><br><span class="line"><span class="keyword">SELECT</span> c_no, <span class="keyword">AVG</span>(degree) <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no;</span><br><span class="line">+<span class="comment">-------+-------------+</span></span><br><span class="line">| c_no  | AVG(degree) |</span><br><span class="line">+<span class="comment">-------+-------------+</span></span><br><span class="line">| 3-105 |     87.6667 |</span><br><span class="line">| 3-245 |     76.3333 |</span><br><span class="line">| 6-166 |     81.6667 |</span><br><span class="line">+<span class="comment">-------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 score 表</span></span><br><span class="line"><span class="keyword">SELECT</span> degree <span class="keyword">FROM</span> score;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| degree |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">|     90 |</span><br><span class="line">|     91 |</span><br><span class="line">|     92 |</span><br><span class="line">|     86 |</span><br><span class="line">|     85 |</span><br><span class="line">|     89 |</span><br><span class="line">|     88 |</span><br><span class="line">|     75 |</span><br><span class="line">|     79 |</span><br><span class="line">|     76 |</span><br><span class="line">|     68 |</span><br><span class="line">|     81 |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将表 b 作用于表 a 中查询数据</span></span><br><span class="line"><span class="comment">-- score a (b): 将表声明为 a (b)，</span></span><br><span class="line"><span class="comment">-- 如此就能用 a.c_no = b.c_no 作为条件执行查询了。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score a <span class="keyword">WHERE</span> degree &lt; (</span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(degree) <span class="keyword">FROM</span> score b <span class="keyword">WHERE</span> a.c_no = b.c_no)</span><br><span class="line">);</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 105  | 3-245 |     75 |</span><br><span class="line">| 105  | 6-166 |     79 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">| 109  | 3-245 |     68 |</span><br><span class="line">| 109  | 6-166 |     81 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="子查询-4"><a href="#子查询-4" class="headerlink" title="子查询 - 4"></a>子查询 - 4</h3><p><strong>查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code></strong> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, department <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> <span class="keyword">no</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> t_no <span class="keyword">FROM</span> course);</span><br><span class="line">+<span class="comment">--------+-----------------+</span></span><br><span class="line">| name   | department      |</span><br><span class="line">+<span class="comment">--------+-----------------+</span></span><br><span class="line">| 李诚   | 计算机系        |</span><br><span class="line">| 王萍   | 计算机系        |</span><br><span class="line">| 刘冰   | 电子工程系      |</span><br><span class="line">| 张旭   | 电子工程系      |</span><br><span class="line">+<span class="comment">--------+-----------------+</span></span><br></pre></td></tr></table></figure><h3 id="条件加组筛选"><a href="#条件加组筛选" class="headerlink" title="条件加组筛选"></a>条件加组筛选</h3><p><strong>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看学生表信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student;</span><br><span class="line">+<span class="comment">-----+-----------+-----+------------+-------+</span></span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+<span class="comment">-----+-----------+-----+------------+-------+</span></span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">| 103 | 王丽      | 女  | 1976-01-23 | 95033 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 105 | 王芳      | 女  | 1975-02-10 | 95031 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">+<span class="comment">-----+-----------+-----+------------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">class</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sex = <span class="string">'男'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">class</span> <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt; <span class="number">1</span>;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| class |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| 95033 |</span><br><span class="line">| 95031 |</span><br><span class="line">+<span class="comment">-------+</span></span><br></pre></td></tr></table></figure><h3 id="NOTLIKE-模糊查询取反"><a href="#NOTLIKE-模糊查询取反" class="headerlink" title="NOTLIKE 模糊查询取反"></a>NOTLIKE 模糊查询取反</h3><p><strong>查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- NOT: 取反</span></span><br><span class="line"><span class="comment">-- LIKE: 模糊查询</span></span><br><span class="line">mysql&gt; SELECT * FROM student WHERE name NOT LIKE '王%';</span><br><span class="line">+<span class="comment">-----+-----------+-----+------------+-------+</span></span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+<span class="comment">-----+-----------+-----+------------+-------+</span></span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">+<span class="comment">-----+-----------+-----+------------+-------+</span></span><br></pre></td></tr></table></figure><h3 id="YEAR-与-NOW-函数"><a href="#YEAR-与-NOW-函数" class="headerlink" title="YEAR 与 NOW 函数"></a>YEAR 与 NOW 函数</h3><p><strong>查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, <span class="keyword">YEAR</span>(<span class="keyword">NOW</span>()) - <span class="keyword">YEAR</span>(birthday) <span class="keyword">as</span> age <span class="keyword">FROM</span> student;</span><br><span class="line">+<span class="comment">-----------+------+</span></span><br><span class="line">| name      | age  |</span><br><span class="line">+<span class="comment">-----------+------+</span></span><br><span class="line">| 曾华      |   42 |</span><br><span class="line">| 匡明      |   44 |</span><br><span class="line">| 王丽      |   43 |</span><br><span class="line">| 李军      |   43 |</span><br><span class="line">| 王芳      |   44 |</span><br><span class="line">| 陆军      |   45 |</span><br><span class="line">| 王尼玛    |   43 |</span><br><span class="line">| 张全蛋    |   44 |</span><br><span class="line">| 赵铁柱    |   45 |</span><br><span class="line">| 张飞      |   45 |</span><br><span class="line">+<span class="comment">-----------+------+</span></span><br></pre></td></tr></table></figure><h3 id="MAX-与-MIN-函数"><a href="#MAX-与-MIN-函数" class="headerlink" title="MAX 与 MIN 函数"></a>MAX 与 MIN 函数</h3><p><strong>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(birthday), <span class="keyword">MIN</span>(birthday) <span class="keyword">FROM</span> student;</span><br><span class="line">+<span class="comment">---------------+---------------+</span></span><br><span class="line">| MAX(birthday) | MIN(birthday) |</span><br><span class="line">+<span class="comment">---------------+---------------+</span></span><br><span class="line">| 1977-09-01    | 1974-06-03    |</span><br><span class="line">+<span class="comment">---------------+---------------+</span></span><br></pre></td></tr></table></figure><h3 id="多段排序"><a href="#多段排序" class="headerlink" title="多段排序"></a>多段排序</h3><p><strong>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">class</span> <span class="keyword">DESC</span>, birthday;</span><br><span class="line">+<span class="comment">-----+-----------+-----+------------+-------+</span></span><br><span class="line">| no  | name      | sex | birthday   | class |</span><br><span class="line">+<span class="comment">-----+-----------+-----+------------+-------+</span></span><br><span class="line">| 110 | 张飞      | 男  | 1974-06-03 | 95038 |</span><br><span class="line">| 103 | 王丽      | 女  | 1976-01-23 | 95033 |</span><br><span class="line">| 104 | 李军      | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |</span><br><span class="line">| 101 | 曾华      | 男  | 1977-09-01 | 95033 |</span><br><span class="line">| 106 | 陆军      | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |</span><br><span class="line">| 105 | 王芳      | 女  | 1975-02-10 | 95031 |</span><br><span class="line">| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |</span><br><span class="line">| 102 | 匡明      | 男  | 1975-10-02 | 95031 |</span><br><span class="line">+<span class="comment">-----+-----------+-----+------------+-------+</span></span><br></pre></td></tr></table></figure><h3 id="子查询-5"><a href="#子查询-5" class="headerlink" title="子查询 - 5"></a>子查询 - 5</h3><p><strong>查询 “男” 教师及其所上的课程。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> t_no <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> sex = <span class="string">'男'</span>);</span><br><span class="line">+<span class="comment">-------+--------------+------+</span></span><br><span class="line">| no    | name         | t_no |</span><br><span class="line">+<span class="comment">-------+--------------+------+</span></span><br><span class="line">| 3-245 | 操作系统     | 804  |</span><br><span class="line">| 6-166 | 数字电路     | 856  |</span><br><span class="line">+<span class="comment">-------+--------------+------+</span></span><br></pre></td></tr></table></figure><h3 id="MAX-函数与子查询"><a href="#MAX-函数与子查询" class="headerlink" title="MAX 函数与子查询"></a>MAX 函数与子查询</h3><p><strong>查询最高分同学的 <code>score</code> 表。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找出最高成绩（该查询只能有一个结果）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(degree) <span class="keyword">FROM</span> score;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据上面的条件筛选出所有最高成绩表，</span></span><br><span class="line"><span class="comment">-- 该查询可能有多个结果，假设 degree 值多次符合条件。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> degree = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(degree) <span class="keyword">FROM</span> score);</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 103  | 3-105 |     92 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="子查询-6"><a href="#子查询-6" class="headerlink" title="子查询 - 6"></a>子查询 - 6</h3><p><strong>查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先将李军的性别作为条件取出来</span></span><br><span class="line"><span class="keyword">SELECT</span> sex <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'李军'</span>;</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| sex |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line">| 男  |</span><br><span class="line">+<span class="comment">-----+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据性别查询 name 和 sex</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, sex <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sex = (</span><br><span class="line">    <span class="keyword">SELECT</span> sex <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'李军'</span></span><br><span class="line">);</span><br><span class="line">+<span class="comment">-----------+-----+</span></span><br><span class="line">| name      | sex |</span><br><span class="line">+<span class="comment">-----------+-----+</span></span><br><span class="line">| 曾华      | 男  |</span><br><span class="line">| 匡明      | 男  |</span><br><span class="line">| 李军      | 男  |</span><br><span class="line">| 陆军      | 男  |</span><br><span class="line">| 王尼玛    | 男  |</span><br><span class="line">| 张全蛋    | 男  |</span><br><span class="line">| 赵铁柱    | 男  |</span><br><span class="line">| 张飞      | 男  |</span><br><span class="line">+<span class="comment">-----------+-----+</span></span><br></pre></td></tr></table></figure><h3 id="子查询-7"><a href="#子查询-7" class="headerlink" title="子查询 - 7"></a>子查询 - 7</h3><p><strong>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, sex, <span class="keyword">class</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sex = (</span><br><span class="line">    <span class="keyword">SELECT</span> sex <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'李军'</span></span><br><span class="line">) <span class="keyword">AND</span> <span class="keyword">class</span> = (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">class</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'李军'</span></span><br><span class="line">);</span><br><span class="line">+<span class="comment">-----------+-----+-------+</span></span><br><span class="line">| name      | sex | class |</span><br><span class="line">+<span class="comment">-----------+-----+-------+</span></span><br><span class="line">| 曾华      | 男  | 95033 |</span><br><span class="line">| 李军      | 男  | 95033 |</span><br><span class="line">| 王尼玛    | 男  | 95033 |</span><br><span class="line">+<span class="comment">-----------+-----+-------+</span></span><br></pre></td></tr></table></figure><h3 id="子查询-8"><a href="#子查询-8" class="headerlink" title="子查询 - 8"></a>子查询 - 8</h3><p><strong>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p><p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no = (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'计算机导论'</span></span><br><span class="line">) <span class="keyword">AND</span> s_no <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">no</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sex = <span class="string">'男'</span></span><br><span class="line">);</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| s_no | c_no  | degree |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br><span class="line">| 101  | 3-105 |     90 |</span><br><span class="line">| 102  | 3-105 |     91 |</span><br><span class="line">| 104  | 3-105 |     89 |</span><br><span class="line">| 109  | 3-105 |     76 |</span><br><span class="line">+<span class="comment">------+-------+--------+</span></span><br></pre></td></tr></table></figure><h3 id="按等级查询"><a href="#按等级查询" class="headerlink" title="按等级查询"></a>按等级查询</h3><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grade (</span><br><span class="line">    <span class="keyword">low</span> <span class="built_in">INT</span>(<span class="number">3</span>),</span><br><span class="line">    upp <span class="built_in">INT</span>(<span class="number">3</span>),</span><br><span class="line">    grade <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span> (<span class="number">90</span>, <span class="number">100</span>, <span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span> (<span class="number">80</span>, <span class="number">89</span>, <span class="string">'B'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span> (<span class="number">70</span>, <span class="number">79</span>, <span class="string">'C'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span> (<span class="number">60</span>, <span class="number">69</span>, <span class="string">'D'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span> (<span class="number">0</span>, <span class="number">59</span>, <span class="string">'E'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> grade;</span><br><span class="line">+<span class="comment">------+------+-------+</span></span><br><span class="line">| low  | upp  | grade |</span><br><span class="line">+<span class="comment">------+------+-------+</span></span><br><span class="line">|   90 |  100 | A     |</span><br><span class="line">|   80 |   89 | B     |</span><br><span class="line">|   70 |   79 | C     |</span><br><span class="line">|   60 |   69 | D     |</span><br><span class="line">|    0 |   59 | E     |</span><br><span class="line">+<span class="comment">------+------+-------+</span></span><br></pre></td></tr></table></figure><p><strong>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p><p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> )  在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_no, c_no, grade <span class="keyword">FROM</span> score, grade </span><br><span class="line"><span class="keyword">WHERE</span> degree <span class="keyword">BETWEEN</span> <span class="keyword">low</span> <span class="keyword">AND</span> upp;</span><br><span class="line">+<span class="comment">------+-------+-------+</span></span><br><span class="line">| s_no | c_no  | grade |</span><br><span class="line">+<span class="comment">------+-------+-------+</span></span><br><span class="line">| 101  | 3-105 | A     |</span><br><span class="line">| 102  | 3-105 | A     |</span><br><span class="line">| 103  | 3-105 | A     |</span><br><span class="line">| 103  | 3-245 | B     |</span><br><span class="line">| 103  | 6-166 | B     |</span><br><span class="line">| 104  | 3-105 | B     |</span><br><span class="line">| 105  | 3-105 | B     |</span><br><span class="line">| 105  | 3-245 | C     |</span><br><span class="line">| 105  | 6-166 | C     |</span><br><span class="line">| 109  | 3-105 | C     |</span><br><span class="line">| 109  | 3-245 | D     |</span><br><span class="line">| 109  | 6-166 | B     |</span><br><span class="line">+<span class="comment">------+-------+-------+</span></span><br></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>准备用于测试连接查询的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> testJoin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    cardId <span class="built_in">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> card (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> card <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'饭卡'</span>), (<span class="number">2</span>, <span class="string">'建行卡'</span>), (<span class="number">3</span>, <span class="string">'农行卡'</span>), (<span class="number">4</span>, <span class="string">'工商卡'</span>), (<span class="number">5</span>, <span class="string">'邮政卡'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> card;</span><br><span class="line">+<span class="comment">------+-----------+</span></span><br><span class="line">| id   | name      |</span><br><span class="line">+<span class="comment">------+-----------+</span></span><br><span class="line">|    1 | 饭卡      |</span><br><span class="line">|    2 | 建行卡    |</span><br><span class="line">|    3 | 农行卡    |</span><br><span class="line">|    4 | 工商卡    |</span><br><span class="line">|    5 | 邮政卡    |</span><br><span class="line">+<span class="comment">------+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'张三'</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="string">'李四'</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="string">'王五'</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person;</span><br><span class="line">+<span class="comment">------+--------+--------+</span></span><br><span class="line">| id   | name   | cardId |</span><br><span class="line">+<span class="comment">------+--------+--------+</span></span><br><span class="line">|    1 | 张三   |      1 |</span><br><span class="line">|    2 | 李四   |      3 |</span><br><span class="line">|    3 | 王五   |      6 |</span><br><span class="line">+<span class="comment">------+--------+--------+</span></span><br></pre></td></tr></table></figure><p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- INNER JOIN: 表示为内连接，将两张表拼接在一起。</span></span><br><span class="line"><span class="comment">-- on: 表示要执行某个条件。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person <span class="keyword">INNER</span> <span class="keyword">JOIN</span> card <span class="keyword">on</span> person.cardId = card.id;</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将 INNER 关键字省略掉，结果也是一样的。</span></span><br><span class="line"><span class="comment">-- SELECT * FROM person JOIN card on person.cardId = card.id;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>card</code> 的整张表被连接到了右边。</p></blockquote><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> card <span class="keyword">on</span> person.cardId = card.id;</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">|    3 | 王五   |      6 | NULL | NULL      |</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br></pre></td></tr></table></figure><h4 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h4><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> card <span class="keyword">on</span> person.cardId = card.id;</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    2 | 建行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    4 | 工商卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    5 | 邮政卡    |</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br></pre></td></tr></table></figure><h4 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h4><p>完整显示两张表的全部数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL 不支持这种语法的全外连接</span></span><br><span class="line"><span class="comment">-- SELECT * FROM person FULL JOIN card on person.cardId = card.id;</span></span><br><span class="line"><span class="comment">-- 出现错误：</span></span><br><span class="line"><span class="comment">-- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL全连接语法，使用 UNION 将两张表合并在一起。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> card <span class="keyword">on</span> person.cardId = card.id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> card <span class="keyword">on</span> person.cardId = card.id;</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br><span class="line">| id   | name   | cardId | id   | name      |</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br><span class="line">|    1 | 张三   |      1 |    1 | 饭卡      |</span><br><span class="line">|    2 | 李四   |      3 |    3 | 农行卡    |</span><br><span class="line">|    3 | 王五   |      6 | NULL | NULL      |</span><br><span class="line">| NULL | NULL   |   NULL |    2 | 建行卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    4 | 工商卡    |</span><br><span class="line">| NULL | NULL   |   NULL |    5 | 邮政卡    |</span><br><span class="line">+<span class="comment">------+--------+--------+------+-----------+</span></span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p><p>比如我们的银行转账：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- a -&gt; -100</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b -&gt; +100</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'b'</span>;</span><br></pre></td></tr></table></figure><p>在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。</p><p>因此，在执行多条有关联 SQL 语句时，<strong>事务</strong>可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。</p><h3 id="如何控制事务-COMMIT-ROLLBACK"><a href="#如何控制事务-COMMIT-ROLLBACK" class="headerlink" title="如何控制事务 - COMMIT / ROLLBACK"></a>如何控制事务 - COMMIT / ROLLBACK</h3><p>在 MySQL 中，事务的<strong>自动提交</strong>状态默认是开启的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询事务的自动提交状态</span></span><br><span class="line"><span class="keyword">SELECT</span> @@AUTOCOMMIT;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| @@AUTOCOMMIT |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">|            1 |</span><br><span class="line">+<span class="comment">--------------+</span></span><br></pre></td></tr></table></figure><p><strong>自动提交的作用</strong>：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能<strong>回滚</strong>。</p><p>什么是回滚？举个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> bank;</span><br><span class="line"></span><br><span class="line"><span class="keyword">USE</span> bank;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    money <span class="built_in">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br></pre></td></tr></table></figure><p>可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它<strong>提交</strong>到了数据库中。那么所谓<strong>回滚</strong>的意思就是，撤销执行过的所有 SQL 语句，使其回滚到<strong>最后一次提交</strong>数据时的状态。</p><p>在 MySQL 中使用 <code>ROLLBACK</code> 执行回滚：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 回滚到最后一次提交</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br></pre></td></tr></table></figure><p>由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭自动提交</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询自动提交状态</span></span><br><span class="line"><span class="keyword">SELECT</span> @@AUTOCOMMIT;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| @@AUTOCOMMIT |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">|            0 |</span><br><span class="line">+<span class="comment">--------------+</span></span><br></pre></td></tr></table></figure><p>将自动提交关闭后，测试数据回滚：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'b'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，</span></span><br><span class="line"><span class="comment">-- 发生变化的数据并没有真正插入到数据表中。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据表中的真实数据其实还是：</span></span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 由于数据还没有真正提交，可以使用回滚</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br></pre></td></tr></table></figure><p>那如何将虚拟的数据真正提交到数据库中？使用 <code>COMMIT</code> : </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'b'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">-- 手动提交数据（持久性），</span></span><br><span class="line"><span class="comment">-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交后测试回滚</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次查询（回滚无效了）</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong></p><ol><li><p><strong>自动提交</strong></p><ul><li><p>查看自动提交状态：<code>SELECT @@AUTOCOMMIT</code> ；</p></li><li><p>设置自动提交状态：<code>SET AUTOCOMMIT = 0</code> 。</p></li></ul></li><li><p><strong>手动提交</strong></p><p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>COMMIT</code> 命令提交事务。</p></li><li><p><strong>事务回滚</strong></p><p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>ROLLBACK</code> 命令回滚事务。</p></li></ol></blockquote><p><strong>事务的实际应用</strong>，让我们再回到银行转账项目：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 转账</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 到账</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br></pre></td></tr></table></figure><p>这时假设在转账时发生了意外，就可以使用 <code>ROLLBACK</code> 回滚到最后一次提交的状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设转账发生了意外，需要回滚。</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br></pre></td></tr></table></figure><p>这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：<code>COMMIT</code> 。</p><h3 id="手动开启事务-BEGIN-START-TRANSACTION"><a href="#手动开启事务-BEGIN-START-TRANSACTION" class="headerlink" title="手动开启事务 - BEGIN / START TRANSACTION"></a>手动开启事务 - BEGIN / START TRANSACTION</h3><p>事务的默认提交被开启 ( <code>@@AUTOCOMMIT = 1</code> ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务</span></span><br><span class="line"><span class="comment">-- START TRANSACTION;</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 由于手动开启的事务没有开启自动提交，</span></span><br><span class="line"><span class="comment">-- 此时发生变化的数据仍然是被保存在一张临时表中。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试回滚</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |  1000 |</span><br><span class="line">|  2 | b    |  1000 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br></pre></td></tr></table></figure><p>仍然使用 <code>COMMIT</code> 提交数据，提交后无法再发生本次事务的回滚。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money - <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">set</span> money = money + <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">| id | name | money |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line">|  1 | a    |   900 |</span><br><span class="line">|  2 | b    |  1100 |</span><br><span class="line">+<span class="comment">----+------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交数据</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试回滚（无效，因为表的数据已经被提交）</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><h3 id="事务的-ACID-特征与使用"><a href="#事务的-ACID-特征与使用" class="headerlink" title="事务的 ACID 特征与使用"></a>事务的 ACID 特征与使用</h3><p><strong>事务的四大特征：</strong></p><ul><li><strong>A 原子性</strong>：事务是最小的单位，不可以再分割；</li><li><strong>C 一致性</strong>：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；</li><li><strong>I 隔离性</strong>：事务1 和 事务2 之间是具有隔离性的；</li><li><strong>D 持久性</strong>：事务一旦结束 ( <code>COMMIT</code> ) ，就不可以再返回了 ( <code>ROLLBACK</code> ) 。</li></ul><h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p><strong>事务的隔离性可分为四种 ( 性能从低到高 )</strong> ：</p><ol><li><p><strong>READ UNCOMMITTED ( 读取未提交 )</strong></p><p>如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。</p></li><li><p><strong>READ COMMITTED ( 读取已提交 )</strong></p><p>只能读取到其他事务<strong>已经提交的数据</strong>。</p></li><li><p><strong>REPEATABLE READ ( 可被重复读 )</strong></p><p>如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。</p></li><li><p><strong>SERIALIZABLE ( 串行化 )</strong></p><p>所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong>。</p></li></ol><p>查看当前数据库的默认隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。</span></span><br><span class="line"><span class="keyword">SELECT</span> @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line"><span class="keyword">SELECT</span> @@TRANSACTION_ISOLATION;</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| REPEATABLE-READ                | <span class="comment">-- MySQL的默认隔离级别，可以重复读。</span></span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL 5.x</span></span><br><span class="line"><span class="keyword">SELECT</span> @@GLOBAL.TX_ISOLATION;</span><br><span class="line"><span class="keyword">SELECT</span> @@TX_ISOLATION;</span><br></pre></td></tr></table></figure><p>修改隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> UNCOMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询系统隔离级别，发现已经被修改。</span></span><br><span class="line"><span class="keyword">SELECT</span> @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| READ-UNCOMMITTED               |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br></pre></td></tr></table></figure><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>测试 <strong>READ UNCOMMITTED ( 读取未提交 )</strong> 的隔离性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'小明'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'淘宝店'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启一个事务操作数据</span></span><br><span class="line"><span class="comment">-- 假设小明在淘宝店买了一双800块钱的鞋子：</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> money = money - <span class="number">800</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> money = money + <span class="number">800</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'淘宝店'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 然后淘宝店在另一方查询结果，发现钱已到账。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br></pre></td></tr></table></figure><p>由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 <code>ROLLBACK</code> 命令，会发生什么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 小明所处的事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时无论对方是谁，如果再去查询结果就会发现：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br></pre></td></tr></table></figure><p>这就是所谓的<strong>脏读</strong>，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。</p><h4 id="读取已提交"><a href="#读取已提交" class="headerlink" title="读取已提交"></a>读取已提交</h4><p>把隔离级别设置为 <strong>READ COMMITTED</strong> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> COMMITTED;</span><br><span class="line"><span class="keyword">SELECT</span> @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| READ-COMMITTED                 |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br></pre></td></tr></table></figure><p>这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正在操作数据事务（当前事务）</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> money = money - <span class="number">800</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> money = money + <span class="number">800</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'淘宝店'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，</span></span><br><span class="line"><span class="comment">-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 假设此时在远程开启了一个新事务，连接到数据库。</span></span><br><span class="line">$ mysql -u root -p12345612</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时远程连接查询到的数据只能是已经提交过的</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br></pre></td></tr></table></figure><p>但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 小张在查询数据的时候发现：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |   200 |</span><br><span class="line">|  4 | 淘宝店    |  1800 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在小张求表的 money 平均值之前，小王做了一个操作：</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">'c'</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时表的真实数据是：</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(money) <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">| AVG(money) |</span><br><span class="line">+<span class="comment">------------+</span></span><br><span class="line">|  820.0000  |</span><br><span class="line">+<span class="comment">------------+</span></span><br></pre></td></tr></table></figure><p>虽然 <strong>READ COMMITTED</strong> 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是<strong>在读取同一个表的数据时，可能会发生前后不一致的情况。</strong>这被称为<strong>不可重复读现象 ( READ COMMITTED )</strong> 。</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>将隔离级别设置为 <strong>REPEATABLE READ ( 可被重复读取 )</strong> :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| REPEATABLE-READ                |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br></pre></td></tr></table></figure><p>测试 <strong>REPEATABLE READ</strong> ，假设在两个不同的连接上分别执行 <code>START TRANSACTION</code> :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 小张 - 成都</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'d'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小王 - 北京</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小张 - 成都</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。</p><p>无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br></pre></td></tr></table></figure><p>这是<strong>因为小王在此之前开启了一个新的事务 ( <code>START TRANSACTION</code> ) **，那么</strong>在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。</p><p>然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'d'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'</span></span><br></pre></td></tr></table></figure><p>报错了，操作被告知已存在主键为 <code>6</code> 的字段。这种现象也被称为<strong>幻读，一个事务提交的数据，不能被其他事务读取到</strong>。</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>顾名思义，就是所有事务的<strong>写入操作</strong>全都是串行化的。什么意思？把隔离级别修改成 <strong>SERIALIZABLE</strong> :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SERIALIZABLE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @@GLOBAL.TRANSACTION_ISOLATION;</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| @@GLOBAL.TRANSACTION_ISOLATION |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br><span class="line">| SERIALIZABLE                   |</span><br><span class="line">+<span class="comment">--------------------------------+</span></span><br></pre></td></tr></table></figure><p>还是拿小张和小王来举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 小张 - 成都</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 小王 - 北京</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启事务之前先查询表，准备操作数据。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | name      | money |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 | a         |   900 |</span><br><span class="line">|  2 | b         |  1100 |</span><br><span class="line">|  3 | 小明      |  1000 |</span><br><span class="line">|  4 | 淘宝店    |  1000 |</span><br><span class="line">|  5 | c         |   100 |</span><br><span class="line">|  6 | d         |  1000 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 发现没有 7 号王小花，于是插入一条数据：</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">'王小花'</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>此时会发生什么呢？由于现在的隔离级别是 <strong>SERIALIZABLE ( 串行化 )</strong> ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。</p><p>根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 <code>COMMIT</code> 结束它所处的事务，或者出现等待超时。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 笔记整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识 size_t</title>
      <link href="/2020/06/08/size-t/"/>
      <url>/2020/06/08/size-t/</url>
      
        <content type="html"><![CDATA[<h1 id="初识-size-t"><a href="#初识-size-t" class="headerlink" title="初识 size_t"></a>初识 size_t</h1><h2 id="size-t-类型"><a href="#size-t-类型" class="headerlink" title="size_t 类型"></a>size_t 类型</h2><p>size_t实际上是无符号整型，它并不是一个全新的数据类型，更不是一个关键字。size_t是由typedef定义而来的，我们在很多标准库头文件中都能发现它的身影。</p><ul><li>在 32 位架构中被普遍定义为：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">size_t</span>;</span><br></pre></td></tr></table></figure><ul><li>在 64 位架构中被普遍定义为：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">size_t</span>;</span><br></pre></td></tr></table></figure><p>但在本机 vscode 下，size_t的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line">__MINGW_EXTENSION <span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int64 <span class="keyword">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _WIN64 */</span></span></span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __int64 long long</span></span><br></pre></td></tr></table></figure><p><strong>????</strong></p><h2 id="使用size-t的原因"><a href="#使用size-t的原因" class="headerlink" title="使用size_t的原因"></a>使用size_t的原因</h2><p>size_t 实际上是 size type 的意思，它是一种计数类型。取值范围与机器架构与操作系统相关。32位机器一般是 unsigned int ，占4字节；64位机器一般是 unsigned long，占8字节。</p><p>size_t 常被用作计数，例如，sizeof 运算符得到对象所占的字节数，字符串函数 strlen 返回字符串的长度等等，都是 size_t 类型的。</p><p>size_t 类型<strong>理论上能容纳此机器中所能建立最大对象的字节大小</strong>。常被应用在数组索引，内存管理函数中。<br>最初设计 size_t 类型，是为了程序的跨平台兼容。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在下列示例中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">strlen</span>(<span class="string">"hello"</span>)) &#123;</span><br><span class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"Hello !!!\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>Hello !!!</p></blockquote><p>原因是触发了C的隐式自动类型转换机制，size_t 的类型是unsigned long int，带符号整型变量 i 会被自动转换成unsigned int，即无符号整型，-1 被转化成无符号数是4294967295，远大于5。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://en.cppreference.com/w/c/types/size_t" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://zihengcat.github.io/2017/06/02/C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%90%86%E8%A7%A3size_t/" target="_blank" rel="noopener">ziheng’s Blog</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言结构体struct所占字节数求解</title>
      <link href="/2020/06/06/20200606/"/>
      <url>/2020/06/06/20200606/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言结构体struct所占字节数求解"><a href="#c语言结构体struct所占字节数求解" class="headerlink" title="c语言结构体struct所占字节数求解"></a>c语言结构体struct所占字节数求解</h1><p>在求解结构体struct所占字节数的问题的时候涉及到内存字节对齐的问题。从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是事实上不是如此，实际上访问特定类型的的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列，而不是简单地顺序排列，这就是内存对齐。</p><p>　  在C99标准中，对于内存对齐的细节没有作过多的描述，具体的实现交由编译器去处理，所以在不同的编译环境下，内存对齐可能略有不同，但是对齐的最基本原则是一致的，对于结构体的字节对齐主要有下面两点：</p><ol><li><p>结构体每个成员相对结构体首地址的偏移量(offset)是对齐参数的整 数倍，如有需要会在成员之间填充字节。编译器在为结构体成员开辟空间时，首先检查预开辟空间的地址相对于结构体首地址的偏移量是否为对齐参数的整数倍，若是，则存放该成员；若不是，则填充若干字节，以达到整数倍的要求。</p></li><li><p>结构体变量所占空间的大小是对齐参数大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是对齐参数大小的整数倍。</p></li></ol><p>而上面这两点就是解题的关键所在。</p><p>在windows下各种类型的变量的自身对齐参数就是该类型变量所占字节数的大小,除了变量的自身对齐参数外，还有一个对齐参数，就是每个编译器默认的对齐参数#pragma pack(n)，这个值可以通过代码去设定，如果没有设定，则取系统的默认值.n的取值可以为1、2、4、8等一般默认情况下为8。</p><p>了解了这2个概念之后，可以理解上面2条原则了。对于第一条原则，每个变量相对于结构体的首地址的偏移量必须是对齐参数的整数倍，<strong>这句话中的对齐参数是取每个变量自身对齐参数和系统默认对齐参数#pragma pack(n)中较小的一个</strong>。举个简单的例子，比如在结构体A中有变量int a，a的自身对齐参数为4（环境为windows/DEV），而DEV默认的对齐参数为8，取较小者，则对于a，它相对于结构体A的起始地址的偏移量必须是4的倍数。</p><p>对于第二条原则，结构体变量所占空间的大小是对齐参数的整数倍。这句话中的对齐参数有点复杂，<strong>它是取结构体中所有变量的对齐参数的最大值和系统默认对齐参数#pragma pack(n)比较，较小者作为对齐参数</strong>。举个例子假如在结构体A中先后定义了两个变量int a;double b;对于变量a，它的自身对齐参数为4，而#pragma pack(n)值默认为8，则a的对齐参数为4；b的自身对齐参数为8，而#pragma pack(n)的默认值为8，则b的对齐参数为8。即结构体内的每个遍历也要取自身的对齐参数和默认对齐参数比较，取较小者作为这个变量的对齐参数。由于a的最终对齐参数为4，b的最终对齐参数为8，那么两者较大者是8，<strong>然后再拿8和#pragma pack(n)作比较，取较小者作为对齐参数，也就是8，即意味着结构体最终的大小必须能被8整除</strong>。</p><p>实例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">short d;</span><br><span class="line">&#125;A</span><br></pre></td></tr></table></figure><blockquote><p>答案： 12</p></blockquote><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200606221701.png" alt="20200606221701"></p><p>实例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">short d;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;B;</span><br></pre></td></tr></table></figure><blockquote><p>答案： 8</p></blockquote><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200606221757.png" alt="20200606221757"></p><p>实例3：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">short d;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;C;</span><br></pre></td></tr></table></figure><blockquote><p>答案： 4</p></blockquote><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200606221905.png" alt="20200606221905"></p><p>其中 a 是静态变量，而静态数据成员的存放位置与结构体实例的存储地址无关(注意只有在C++中结构体中才能含有静态数据成员，而C中结构体中是不允许含有静态数据成员的)。a是单独存放在静态数据区的，因此用siezof计算其大小时没有将a所占的空间计算进来。</p><p>实例4：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">       <span class="keyword">double</span> b;</span><br><span class="line">       <span class="keyword">int</span> c;</span><br><span class="line">   &#125;D;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">       <span class="keyword">bool</span> a;</span><br><span class="line">       D d;</span><br><span class="line">       <span class="keyword">double</span> b;</span><br><span class="line">       <span class="keyword">int</span> c;</span><br><span class="line">   &#125;E;</span><br></pre></td></tr></table></figure><p>在默认对齐参数下pragma pack(8)下结果是（上述实例也是）</p><blockquote><p>D 16<br>E 40</p></blockquote><p>结构体D所占字节数为16,但这是在对齐参数下 pragma pack(8) 下的结果，当pragma pack(4)的时候结果应该会12。</p><p>对于E来说：</p><p>对于变量a，其自身对齐参数为1，#pragma pack(n)为8，则a的最终对齐参数为1，为它分配1字节的空间，它相对于结构体起始地址的偏移量为0，能被1整除；</p><p>对于d，它的自身对齐参数为8（对于结构体变量，它的自身对齐参数为它里面各个变量最终对齐参数的最大值），#pragma pack(n)为8，所以d的最终对齐参数为8，接下来的地址相对于结构体起始地址的偏移量为1，不能被8整除，所以需要在a后面填充7字节达到8，为其分配16字节的空间；</p><p>对于变量b，它的自身对齐参数为8，#pragma pack(n)的默认值为8，则b的最终对齐参数为8，接下来的地址相对于结构体起始地址的偏移量为24，能被8整除，再为b分配8字节的空间；</p><p>对于变量c，它的自身对齐参数为4，#pragma pack(n)的默认值为8，则c的最终对齐参数为4，接下来相对于结构体其实地址的偏移量为32，能够被4整除，所以直接为c分配4字节的空间。</p><p>此时结构体所占字节数为1+7+16+8+4=36字节。</p><p>对于整个结构体来说，各个变量的最终对齐参数为1，8，8，4，最大值为8，#pragma pack(n)默认值为8，所以最终结构体的大小必须是8的倍数，因此需要在最后面填充4字节达到40字节。其存储如下：</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200606223102.png" alt="20200606223102"></p><p><strong>注意：</strong> 对于字符数组的类型，<strong>在结构体中，数组是按照单个变量一个一个进行摆放的</strong>，不是视为整体。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inline 函数————内联函数</title>
      <link href="/2020/06/05/c-inline/"/>
      <url>/2020/06/05/c-inline/</url>
      
        <content type="html"><![CDATA[<h1 id="inline-函数——内联函数"><a href="#inline-函数——内联函数" class="headerlink" title="inline 函数——内联函数"></a>inline 函数——内联函数</h1><p><strong>内容梗概</strong>：内联函数inline是为了提高程序执行效率的。我们在使用inline时需要将其放在函数的定义处，而非声明处。而且，我们也仅仅是将比较短小的函数写成内联函数。</p><h2 id="为什么使用inline内联函数？"><a href="#为什么使用inline内联函数？" class="headerlink" title="为什么使用inline内联函数？"></a>为什么使用inline内联函数？</h2><p>目的是提高程序执行效率。内联函数是用函数体替换调用语句，这样执行时就不需要做保存断点，恢复调用前的状态等工作，从而提高<br>程序执行效率。 </p><p>但是，不可以都写成内联函数，因为这样会增加程序的长度，反而会降低效率的。所以，一般将比较短小的函数写成内联函数。</p><h2 id="既然inline可以免去函数的调用，那为什么不每个函数都用inline呢？？"><a href="#既然inline可以免去函数的调用，那为什么不每个函数都用inline呢？？" class="headerlink" title="既然inline可以免去函数的调用，那为什么不每个函数都用inline呢？？"></a>既然inline可以免去函数的调用，那为什么不每个函数都用inline呢？？</h2><ul><li><p>因为不是每一个函数都能在编译期在调用处展开,如虚函数就不能；</p></li><li><p>因为对于大函数来说，inline展开会令代码长度增加，带来的消耗反而更大。</p></li></ul><p>如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？内联是以 <strong>代码膨胀（复制）</strong> 为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p><h2 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h2><p><strong>在函数声明或定义中函数返回类型前加上关键字inline即把min（）指定为内联。</strong></p><blockquote><p>inline int min(int first, int secend) {/****/};</p></blockquote><p>inline 函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。当然，对于同一程序的不同文件，如果inline函数出现的话，其定义必须相同。对于由两个文件comp.c和draw.c构成的程序来说，程序员不能定义这样的min()函数，它在comp.c中指一件事情，而在draw.c中指另外一件事情。如果两个定义不相同，程序将会有未定义的行为。</p><p>为保证不会发生这样的事情，<strong>建议把inline函数的定义放到头文件中</strong>。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。</p><h2 id="内联函数的编程风格"><a href="#内联函数的编程风格" class="headerlink" title="内联函数的编程风格"></a>内联函数的编程风格</h2><p><strong>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。</strong></p><p>如下风格的函数Foo 不能成为内联函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// inline 仅与函数声明放在一起</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>而如下风格的函数Foo 则成为内联函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125; <span class="comment">// inline 与函数定义体放在一起</span></span><br></pre></td></tr></table></figure><p>所以说，inline 是一种 <strong>“用于实现的关键字”</strong>，而不是一种 <strong>“用于声明的关键字”</strong>。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</p><p><strong>定义在类声明之中的成员函数将自动地成为内联函数</strong></p><p>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  &#125; <span class="comment">// 自动地成为内联函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">A::Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="使用内联函数的优点"><a href="#使用内联函数的优点" class="headerlink" title="使用内联函数的优点"></a>使用内联函数的优点</h2><p>从一个用户的角度来看，内联函数看起来和普通函数一样， 它可以有参数和返回值，也可以有自己的作用域，然而它却不会引入一般函数调用所带来的负担。另外，它可以比宏更安全更容易调试。</p><h2 id="不宜使用内联的情况："><a href="#不宜使用内联的情况：" class="headerlink" title="不宜使用内联的情况："></a>不宜使用内联的情况：</h2><ul><li>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</li><li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以<strong>不要随便地将构造函数和析构函数的定义体放在类声明中</strong>。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>inline对编译器只是一个提示说明，编译器可以对你的函数inline也可以不inline。 所以即使你的函数都写上inline，最后的结果，也可能一个inline也没有。如果有些函数确实想采用inline，但是又怕编译给忽略掉，可以采用 <strong>__inline</strong> ，并在编译时刻选择以 <strong>__inline</strong> 方式内联而不是默认方式内联就可。</p><p>一般情况下编译器是决定函数内联与否的关键性因素包括函数体的大小，是否有局部对象被声明，函数的复杂性等等。  </p><p>如果一个函数被声明为inline但是却没有被内联会发生什么？理论上，当编译器拒绝内联一个函数的时候，那个函数会像普通函数一样被对待，但是还会出现一些其他的问题。例如下面这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   filename   Time.h  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;  </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"> <span class="keyword">using</span>   <span class="keyword">namespace</span>   <span class="built_in">std</span>;  </span><br><span class="line"> <span class="class"><span class="keyword">class</span>   <span class="title">Time</span>  </span></span><br><span class="line"><span class="class"> &#123;</span>  </span><br><span class="line"> <span class="keyword">public</span>:  </span><br><span class="line">         <span class="function"><span class="keyword">inline</span>   <span class="keyword">void</span>   <span class="title">Show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">         </span>&#123;  </span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span>   i   =   <span class="number">0</span>;   i&lt;<span class="number">10</span>;   i++)</span><br><span class="line">                 <span class="built_in">cout</span>&lt;&lt;time(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         &#125;  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>因为成员函数 Time::Show() 包括一个 局部变量 和一个 for 循环，所以编译器一般拒绝inline，并且把它当作一个普通的成员函数。但是这个包含类声明的头文件会被单独的#include进各个独立的编译单元中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   filename   f1.cpp  </span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">"Time.h"</span>  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>   <span class="title">f1</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">          Time   t1;  </span><br><span class="line">          t1.Show();  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//   filename   f2.cpp  </span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">"Time.h"</span>  </span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>   <span class="title">f2</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">          Time   t2;  </span><br><span class="line">          t2.Show();  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p> 结果编译器为这个程序生成了两个相同成员函数的拷贝：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">f1</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span>   <span class="title">f2</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">          f1();    </span><br><span class="line">          f2();  </span><br><span class="line">          <span class="keyword">return</span>   <span class="number">0</span>;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>程序被链接的时候，linker将会面对两个相同的Time::Show()拷贝，于是函数重定义的连接错误发生。但是老一些的C++实现对付这种情况的办法是通过把一个un-inlined函数当作static来处理。因此每一份函数拷贝仅仅在自己的编译单元中可见，这样链接错误就解决了，但是在程序中却会留下多份函数拷贝。在这种情况下，程序的性能不但没有提升，反而增加了编译和链接时间以及最终可执行体的大小。但是幸运的是，新的C++标准中关于un-inlined函数的说法已经改变。一个符合标准C++实现应该只生成一份函数拷贝。然而，要想所有的编译器都支持这一点可能还需要很长时间。</p><p>另外关于内联函数还有两个更令人头疼的问题。第一个问题是该如何进行维护。一个函数开始的时候可能以内联的形式出现，但是随着系统的扩展，函数体可能要求添加额外的功能，结果内联函数就变得不太可能，因此需要把inline   specifier去除以及把函数体放到一个单独的源文件中。另一个问题是当内联函数被应用在代码库的时候产生。当内联函数改变的时候，用户必须重新编译他们的代码以反映这种改变。然而对于一个非内联函数，用户仅仅需要重新链接就可以了。 </p><p>这里想要说的是，内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果，但是如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。最令人烦恼的还是当编译器拒绝内联的时候。在老的实现中，结果很不尽人意，虽然在新的实现中有很大的改善，但是仍然还是不那么完善的。一些编译器能够足够的聪明来指出哪些函数可以内联哪些不能，但是，大多数编译器就不那么聪明了，因此这就需要我们的经验来判断。如果内联函数不能增强行能，就避免使用它！  </p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><p><a href="https://blog.csdn.net/weixin_41249411/article/details/84328401?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase" target="_blank" rel="noopener">CSDN</a></p></li><li><p><a href="https://www.cnblogs.com/berry/articles/1582702.html" target="_blank" rel="noopener">博客园</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宏定义</title>
      <link href="/2020/06/05/c-define/"/>
      <url>/2020/06/05/c-define/</url>
      
        <content type="html"><![CDATA[<h1 id="C-宏定义"><a href="#C-宏定义" class="headerlink" title="C++ 宏定义"></a>C++ 宏定义</h1><h2 id="define基本用法"><a href="#define基本用法" class="headerlink" title="define基本用法"></a>define基本用法</h2><p>#define　命令是C语言中的一个宏定义命令，它用来将一个标识符(宏名)定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。程序编译之前，编译的时候所有的宏名都会被定义的字符串替换，这便是宏替换。</p><p><strong>理解宏定义的关键在于 “替换”。</strong></p><p>该命令有两种格式：一种是简单的宏定义，另一种是带参数的宏定义。</p><p>(1)简单的宏定义：</p><blockquote><p>#define &lt;宏名&gt;　&lt;字符串&gt;</p></blockquote><p>例： </p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200606165637.png" alt="20200606165637"></p><p>程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> pi2 = PI * <span class="number">2</span>;<span class="comment">//pi2 = 6.28</span></span><br></pre></td></tr></table></figure><p>(2) 带参数的宏定义</p><blockquote><p>#define &lt;宏名&gt; (&lt;参数表&gt;) &lt;宏体&gt;</p></blockquote><p>例：</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200606170038.png" alt="20200606170038"></p><p>程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> pi2 = PI * <span class="number">2</span>;<span class="comment">//pi2 = 6.28</span></span><br><span class="line">pi2 = AddOne(pi2);<span class="comment">// pi2 = 7.28</span></span><br></pre></td></tr></table></figure><h2 id="宏替换发生的时机"><a href="#宏替换发生的时机" class="headerlink" title="宏替换发生的时机"></a>宏替换发生的时机</h2><p>为了能够真正理解#define的作用，让我们来了解一下对C语言源程序的处理过程。当我们在一个集成的开发环境如Turbo C中将编写好的源程序进行编译时，实际经过了预处理、编译、汇编和连接几个过程。其中预处理器产生编译器的输出，它实现以下的功能：</p><p><strong>（1）文件包含</strong></p><p>可以把源程序中的#include 扩展为文件正文，即把包含的.h文件找到并展开到#include 所在处。</p><p><strong>（2）条件编译</strong></p><p>预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。</p><p><strong>（3）宏展开</strong></p><p>预处理器将源程序文件中出现的对宏的引用展开成相应的宏定义，即本文所说的#define的功能，由预处理器来完成。经过预处理器处理的源程序与之前的源程序有所有不同，在这个阶段所进行的工作<strong>只是纯粹的替换与展开</strong>，没有任何计算功能，所以在学习#define命令时只要能真正理解这一点，这样才不会对此命令引起误解并误用。</p><h2 id="宏替换错误举例"><a href="#宏替换错误举例" class="headerlink" title="宏替换错误举例"></a>宏替换错误举例</h2><p>只要严格遵守“<strong>直接替换</strong>”，就不会出现下面的问题</p><p>比如下面的宏定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Square(x) x*x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> temp = Square(<span class="number">3</span>+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//程序的本意可能是要计算6*6=36，但由于宏定义执行的是直接替换，本身并不做计算，因此实际的结果为 3+3*3+3=15</span></span><br><span class="line"><span class="comment">//想要避免这个问题，只需要修改如下：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Square(x) ((x)*(x))</span></span><br></pre></td></tr></table></figure><h2 id="宏定义的特点"><a href="#宏定义的特点" class="headerlink" title="宏定义的特点"></a>宏定义的特点</h2><p>（1）宏名一般用大写，且末尾不加分号。</p><p>（2）宏定义的参数是无类型的，不做语法检查，不做表达式求解，只做替换。</p><p>（3）宏定义通常在文件的最开头，可以使用</p><blockquote><p>#undef 宏名</p></blockquote><p>命令终止宏定义的作用域。</p><p>（4）宏定义可以嵌套，但字符串” “中永远不包含宏。</p><p>（5）宏展开使源程序变长，函数调用不会；宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）。</p><p>（6）函数调用在编译后程序运行时进行，并且分配内存。宏替换在编译前进行，不分配内存。</p><p>（7）使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义，常量pi常用宏定义</p><h2 id="define中的三个特殊符号：-，-，"><a href="#define中的三个特殊符号：-，-，" class="headerlink" title="define中的三个特殊符号：##，#，#@"></a>define中的三个特殊符号：##，#，#@</h2><h3 id="1"><a href="#1" class="headerlink" title="1.##"></a>1.##</h3><blockquote><p>#define Conn(x,y) x##y</p></blockquote><p>x连接y，例如：int n = Conn(123,456); 结果就是 n=123456;</p><p>char* str = Conn(“asdf”, “adf”); 结果就是 str = “asdfadf”;</p><p><strong>注意</strong>：</p><p>a、当用##连接形参时，##前后的空格可有可无。</p><pre><code>如：  #define exampleNum( n )       num ## n                          // 相当于 #define exampleNum( n )      num##n</code></pre><p>b、连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。</p><p>c、如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开。</p><h3 id="2"><a href="#2" class="headerlink" title="2.#@"></a>2.#@</h3><blockquote><p>#define ToChar(x) #@x</p></blockquote><p>给x加上单引号，结果返回是一个const char。例如：char a = ToChar(1);结果就是a=’1’;做个越界试验char a = ToChar(123);结果就错了;但是如果你的参数超过四个字符，编译器就会给你报错 ：error C2015: too many characters in constant   ：P </p><h3 id="3"><a href="#3" class="headerlink" title="3.#"></a>3.#</h3><blockquote><p>#define ToString(x) #x</p></blockquote><p>x加双引号,例如：char* str = ToString(123132);  就成了str=”123132”;</p><p><strong>注意</strong>：对空格的处理：</p><p> a、忽略传入参数名前面和后面的空格。</p><pre><code>如：str=example1(   abc );      将会被扩展成 str=&quot;abc&quot;；</code></pre><p> b、当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串之间以一个空格连接，忽略剩余空格。</p><pre><code>如：str=exapme( abc    def);        将会被扩展成 str=&quot;abc def&quot;；</code></pre><h3 id="续行操作符"><a href="#续行操作符" class="headerlink" title="\ 续行操作符"></a>\ 续行操作符</h3><p>当定义的宏不能用一行表达完整时，可以用”&quot;表示下一行继续此宏的定义。</p><p>注意 \ 前留空格</p><h2 id="常用宏定义"><a href="#常用宏定义" class="headerlink" title="常用宏定义"></a>常用宏定义</h2><p>(1) 防止一个头文件被重复包含</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BODYDEF_H </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BODYDEF_H </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//头文件内容 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>(2) 得到指定地址上的一个字节或字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_B( x ) ( *( (byte *) (x) ) ) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_W( x ) ( *( (word *) (x) ) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">int</span> bTest = <span class="number">0x123456</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> m = MEM_B((&amp;bTest));<span class="comment">/*m=0x56*/</span></span><br><span class="line"><span class="keyword">int</span> n = MEM_W((&amp;bTest));<span class="comment">/*n=0x3456*/</span></span><br></pre></td></tr></table></figure><p>(3) 得到一个field在结构体(struct)中的偏移量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSETOF( type, field ) ( (size_t) &amp;(( type *) 0)-&gt; field )</span></span><br></pre></td></tr></table></figure><p>(4) 得到一个结构体中field所占用的字节数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field )</span></span><br></pre></td></tr></table></figure><p>(5) 得到一个变量的地址（word宽度）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_PTR( var ) ( (byte *) (void *) &amp;(var) ) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W_PTR( var ) ( (word *) (void *) &amp;(var) )</span></span><br></pre></td></tr></table></figure><p>(6) 将一个字母转换为大写</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define UPCASE( c ) ( ((c) &gt;= ''a'' &amp;&amp; (c) &lt;= ''z'') ? ((c) - 0x20) : (c) )</span><br></pre></td></tr></table></figure><p>(7) 防止溢出的一个方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_SAT( val ) (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))</span></span><br></pre></td></tr></table></figure><p>(8) 返回数组元素的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )</span></span><br></pre></td></tr></table></figure><p>(9) 使用一些宏跟踪调试</p><p><strong>ANSI标准说明了五个预定义的宏名</strong>。它们是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__LINE__：在源代码中插入当前源代码行号；</span><br><span class="line"></span><br><span class="line">__FILE__：在源文件中插入当前源文件名；</span><br><span class="line"></span><br><span class="line">__DATE__：在源文件中插入当前的编译日期</span><br><span class="line"></span><br><span class="line">__TIME__：在源文件中插入当前编译时间；</span><br><span class="line"></span><br><span class="line">__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；</span><br><span class="line"></span><br><span class="line">__cplusplus：当编写C++程序时该标识符被定义</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础面试题整理</title>
      <link href="/2020/06/05/cwork/"/>
      <url>/2020/06/05/cwork/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言-C-基础面试知识大集合"><a href="#C语言-C-基础面试知识大集合" class="headerlink" title="C语言/C++基础面试知识大集合"></a>C语言/C++基础面试知识大集合</h1><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li><p>修饰变量，说明该变量不可以被改变；</p></li><li><p>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</p></li><li><p>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</p></li><li><p>修饰成员函数，说明该成员函数内不能修改成员变量。</p></li></ol><h3 id="const-的指针与引用"><a href="#const-的指针与引用" class="headerlink" title="const 的指针与引用"></a>const 的指针与引用</h3><ol><li>指针</li></ol><ul><li>指向常量的指针（pointer to const）</li><li>自身是常量的指针（常量指针，const pointer）</li></ul><ol start="2"><li>引用</li></ol><ul><li>指向常量的引用（reference to const）</li><li>没有 const reference，因为<strong>引用本身就是 const pointer</strong></li></ul><p>（为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 指针变量，指向常对象</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ol><li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li><li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li><li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ol><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><ol><li>this 指针是一个隐含于每一个非静态成员函数中的特殊指针。<strong>它指向调用该成员函数的那个对象</strong>。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li>this 指针被隐含地声明为: ClassName const this，<em>这意味着不能给 this 指针赋值</em>；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；。</li><li>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（<strong>不能 &amp;this</strong>）。</li></ol><p>在以下场景中，经常需要显式引用 this 指针：</p><ul><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 list。</li></ul><h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了<strong>虚函数</strong>的其他函数都会自动隐式地当成内联函数。</li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>inline 使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure><h3 id="编译器对-inline-函数处理步骤"><a href="#编译器对-inline-函数处理步骤" class="headerlink" title="编译器对 inline 函数处理步骤"></a>编译器对 inline 函数处理步骤</h3><ol><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ul><h3 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h3><ul><li><p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</p></li><li><p>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</p></li><li><p>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p></li></ul><p>虚函数内联使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。</span></span><br><span class="line">Base b;</span><br><span class="line">b.who();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。</span></span><br><span class="line">Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">ptr-&gt;who();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile int i = 10;</p><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul><h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><p>断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <strong>NDEBUG</strong> 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。</p><p><strong>assert() 使用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h2><ul><li>sizeof 对数组，得到整个数组所占空间大小。</li><li>sizeof 对指针，得到指针本身所占空间大小。</li></ul><h2 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a>#pragma pack(n)</h2><p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p><p><strong>#pragma pack(n) 使用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><blockquote><p>Bit mode: 2; // mode 占 2 位</p></blockquote><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p><ul><li>位域在内存中的布局是与机器有关的</li><li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li><li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li></ul><h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的</li></ul><p>extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p><h3 id="extern-“C”-使用"><a href="#extern-“C”-使用" class="headerlink" title="extern “C” 使用"></a>extern “C” 使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="struct-和-typedef-struct"><a href="#struct-和-typedef-struct" class="headerlink" title="struct 和 typedef struct"></a>struct 和 typedef struct</h2><h3 id="C中"><a href="#C中" class="headerlink" title="C中"></a>C中</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; S;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>typedef struct Student S; 此时 S 等价于 struct Student，但两个标识符名称空间不相同。</p><p>另外还可以定义与 struct Student 不冲突的 void Student() {}。</p><h3 id="C-中"><a href="#C-中" class="headerlink" title="C++中"></a>C++中</h3><p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p><p>1.如果在类标识符空间定义了 struct Student {…};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。</p><p>即表现为可以使用 Student 也可以使用 struct Student，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure><p>2.若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-中-struct-和-class"><a href="#C-中-struct-和-class" class="headerlink" title="C++ 中 struct 和 class"></a>C++ 中 struct 和 class</h2><p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p><p><strong>区别:</strong></p><p>最本质的一个区别就是默认的访问控制</p><ul><li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li><li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li></ul><h2 id="union-联合"><a href="#union-联合" class="headerlink" title="union 联合"></a>union 联合</h2><p>联合（union）是一种节省空间的特殊的<strong>类</strong>，一个 union 可以有多个数据成员，<strong>但是在任意时刻只有一个数据成员可以有值</strong>。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li><strong>匿名 union 在定义所在作用域可直接访问 union 成员</strong></li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul><h3 id="union-使用"><a href="#union-使用" class="headerlink" title="union 使用"></a>union 使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;                       <span class="comment">//匿名 union 在定义所在作用域可直接访问 union 成员</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;                       <span class="comment">//局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C语言实现C-类"><a href="#C语言实现C-类" class="headerlink" title="C语言实现C++类"></a>C语言实现C++类</h2><p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p><ul><li>封装：使用函数指针把属性与方法封装到结构体中</li><li>继承：结构体嵌套</li><li>多态：父类与子类方法的函数指针不同</li></ul><h2 id="explicit（显式）关键字"><a href="#explicit（显式）关键字" class="headerlink" title="explicit（显式）关键字"></a>explicit（显式）关键字</h2><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外</li></ul><h3 id="explicit-使用"><a href="#explicit-使用" class="headerlink" title="explicit 使用"></a>explicit 使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">A(<span class="keyword">int</span>) &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">// OK：直接初始化</span></span><br><span class="line">A a2 = <span class="number">1</span>;<span class="comment">// OK：复制初始化</span></span><br><span class="line">A a3&#123; <span class="number">1</span> &#125;;<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">A a4 = &#123; <span class="number">1</span> &#125;;<span class="comment">// OK：复制列表初始化</span></span><br><span class="line">A a5 = (A)<span class="number">1</span>;<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">doA(<span class="number">1</span>);<span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line"><span class="keyword">if</span> (a1);<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line"><span class="keyword">bool</span> a6（a1）;<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line"><span class="keyword">bool</span> a7 = a1;<span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line"><span class="keyword">bool</span> a8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">// OK：直接初始化</span></span><br><span class="line">B b2 = <span class="number">1</span>;<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">B b3&#123; <span class="number">1</span> &#125;;<span class="comment">// OK：直接列表初始化</span></span><br><span class="line">B b4 = &#123; <span class="number">1</span> &#125;;<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">B b5 = (B)<span class="number">1</span>;<span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">doB(<span class="number">1</span>);<span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line"><span class="keyword">if</span> (b1);<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;<span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line"><span class="keyword">bool</span> b7 = b1;<span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line"><span class="keyword">bool</span> b8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p>在C++中，可以使用构造函数将一个指定类型的数据转换为类的对象，也可以使用 <strong>类型转换函数 (type conversion function)</strong> 将一个类对象转换为其他类型的数据。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den = <span class="number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) m_numerator/m_denominator; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_numerator;        <span class="comment">// 分子</span></span><br><span class="line">        <span class="keyword">int</span> m_denominator;      <span class="comment">// 分母</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>; </span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.2</span> + f;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.2</strong> 是一个浮点类型的变量，而 <strong>f</strong> 是一个 <strong>Fraction</strong> 类型的变量，因此不能直接相加，于是编译器会到分数类中寻找，找到了 <strong>operator double</strong> 函数，该函数可以将类型对象转换为一个浮点类型的变量。因此该函数就是我们所说的<strong>类型转换函数(type conversion function)</strong>。通过分数类中的转换函数，我们给出转换函数的一般形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> 类型名称() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// 实现转换      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>转换函数必须是类的成员函数</li><li>转换函数不能声明返回类型</li><li>形参列表必须为空</li><li>类型转换函数通常应该是const</li></ol><p>类型转换运算符是隐式执行的，因此对象 f 就拥有了双重类型，既可以是类类型，也可以是double类型。</p><h3 id="类型转换函数-与-explicit"><a href="#类型转换函数-与-explicit" class="headerlink" title="类型转换函数 与 explicit"></a>类型转换函数 与 explicit</h3><p>既然可以调用类型转换函数将该 <strong>Fraction</strong> 类型转换为 <strong>double</strong> 类型，那么也可以通过重载+将double类型转换为类类型。因此该类的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den = <span class="number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span> + (<span class="keyword">const</span> Fraction&amp; f) &#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(f.m_numerator + <span class="keyword">this</span>-&gt;m_numerator , f.m_denominator + <span class="keyword">this</span>-&gt;m_denominator); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>; </span><br><span class="line">    Fraction d = f + <span class="number">3.2</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们将 <strong>f + 3.2</strong> 的值赋值给 <strong>d</strong> 实例时， <strong>3.2</strong> 就通过构造函数转换为<strong>Fraction</strong> 类型，然后调用 <strong>operator +</strong> 函数将两个实例加起来赋值给 <strong>d</strong> 对象。</p><p>但是如果同时存在类型转换函数，则会可能出现以下情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* explicit */</span> Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den = <span class="number">1</span>) : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line">    <span class="comment">/* explicit */</span><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) m_numerator/m_denominator; </span><br><span class="line">    &#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span> + (<span class="keyword">const</span> Fraction&amp; f) &#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(f.m_numerator+<span class="keyword">this</span>-&gt;m_numerator, f.m_denominator+<span class="keyword">this</span>-&gt;m_denominator); </span><br><span class="line">        <span class="comment">//设计有缺陷，应该先通分再合并</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>; </span><br><span class="line">    <span class="keyword">double</span> d = f + <span class="number">3.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译上述的代码可能就会立刻报错：<strong>ambiguous overload for ‘operator+’ (operand types are ‘Fraction’ and ‘double’)</strong></p><p>因为存在了二义性。我们来具体分析以下：</p><ul><li>f对象可以通过类型转换函数将类类型转换为double类型，然后加上3.2赋值给d。</li><li>3.2也可以通过构造函数将double类型转换为Fraction类型，然后两个类类型相加，又可以通过类型转换函数转换为double类型，所以这种方法也可以。</li><li>因此，以上两种方式都可以，所以编译器会报<strong>二义性</strong>的错误。</li></ul><p>解决的办法就是，使用<strong>explicit</strong>关键字的限制，使用方法也有两种：</p><ul><li>直接在构造函数前加上explicit关键字，防止double类型的变量隐式的转换为类类型。</li><li>在转换构造函数operator double前加上explicit关键字，表示只有显示的将类类型转换为double类型时才调用该函数。</li></ul><p>例如：</p><blockquote><p>double d = static_cast<double>(f) + 3.2</p></blockquote><p>后面的方法是<strong>C++11</strong>新引入的显示的类型转换运算符。</p><p>我们要尽量避免有二义性的类型转换，如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式，否则将出现二义性。</p><h2 id="friend-友元类和友元函数"><a href="#friend-友元类和友元函数" class="headerlink" title="friend 友元类和友元函数"></a>friend 友元类和友元函数</h2><ul><li>能访问私有成员</li><li>破坏封装性</li><li>友元关系不可传递</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><h3 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h3><p><strong>using 声明 (using declaration)</strong> 是将命名空间中单个名字注入到<strong>当前作用域</strong>的机制，使得在<strong>当前作用域</strong>下访问另一个作用域下的成员时无需使用限定符 <strong>::</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; the_map; <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; the_map2;  <span class="comment">//error，不在作用域内</span></span><br></pre></td></tr></table></figure><p>using 声明将其它 namespace 的成员引入本命名空间的 当前作用域 <strong>(包括其嵌套作用域)</strong> 。一个 using 声明一次只引入一个命名空间成员，它使得无论程序中使用哪些名字，都非常准确。</p><p>利用 using 声明，可以改变派生类对父类成员的访问控制:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> bn1;</span><br><span class="line">    <span class="keyword">int</span> bn2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::bn1;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedAgain</span>:</span> <span class="keyword">public</span> Derived&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    DerivedAgain da; </span><br><span class="line">    d.bn1 = <span class="number">1</span>;</span><br><span class="line">    d.bn2 = <span class="number">2</span>; <span class="comment">//error, 'bn2' is a private member of 'Base'</span></span><br><span class="line">    da.bn1 = <span class="number">3</span>;  <span class="comment">//ok</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;d.bn1&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管 Derived 对 base 是私有继承，但通过 using 声明，我们还是可以在 Derived 中访问其成员，且后续的继承同样不受 private 限定的影响。</p><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p><blockquote><p>Derived(parms) : Base(args) { }</p></blockquote><h3 id="using-指示-引入命名空间"><a href="#using-指示-引入命名空间" class="headerlink" title="using 指示 (引入命名空间)"></a>using 指示 (引入命名空间)</h3><p>using 指示 (using directive) 是使一个命名空间中的 所有 名字都在该作用域中可见的机制。这是最常用的方式了。需要注意的是命名冲突问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> n1&#123; </span><br><span class="line">    <span class="keyword">int</span> n1_member = <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">11</span>; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> m = <span class="number">12</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> n1; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;n1_member&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;m&lt;&lt;std::endl;  //error 命名冲突</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;::m&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">13</span>; <span class="comment">//ok, 局部变量屏蔽命名空间变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Notice</strong>: 尽管 using指示很方便，但在实际工作中应该尽量避免：它一下子将另一个 namespace 中的成员全部引入了，一不小心就会出现<strong>命名空间污染</strong>问题。</p><h3 id="类型重定义，取代-typedef"><a href="#类型重定义，取代-typedef" class="headerlink" title="类型重定义，取代 typedef"></a>类型重定义，取代 typedef</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> alias = <span class="keyword">typename</span></span><br></pre></td></tr></table></figure><p>这是 C++11 中的新用法，比 typedef 更能表达别名的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> fun = <span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//typedef void (*fun)(int, int); //与上一句等价</span></span><br><span class="line"><span class="keyword">using</span> int16 = short;</span><br><span class="line"><span class="comment">//typedef short int16; //与上一句等价</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(int16)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_no.151</title>
      <link href="/2020/06/03/leetcode-151/"/>
      <url>/2020/06/03/leetcode-151/</url>
      
        <content type="html"><![CDATA[<h1 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200618231103.png" alt="20200618231103"></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> front, <span class="built_in">end</span>;</span><br><span class="line">        <span class="built_in">end</span> = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front &lt;= <span class="built_in">end</span> &amp;&amp; s[front] == <span class="string">' '</span>) ++front;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (front &lt;= <span class="built_in">end</span> &amp;&amp; s[<span class="built_in">end</span>] == <span class="string">' '</span>) --<span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line">        s = s.substr(front, <span class="built_in">end</span> - front + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">end</span> = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        front = <span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">while</span>(front &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">end</span> = front;</span><br><span class="line">            <span class="keyword">while</span>(s[front] != <span class="string">' '</span> &amp;&amp; front &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                front--;</span><br><span class="line">                <span class="keyword">if</span>(front == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (front &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans += s.substr(front + <span class="number">1</span>, <span class="built_in">end</span> - front );</span><br><span class="line">                ans += <span class="string">' '</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                </span><br><span class="line">                ans += s.substr(front, <span class="built_in">end</span> - front + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(s[front] == <span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(front == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">                front--;                </span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_no.5</title>
      <link href="/2020/06/03/leetcode5/"/>
      <url>/2020/06/03/leetcode5/</url>
      
        <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200603091947.png" alt="20200603091947"></p><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>将字符串 s 反转得到字符串 rev，再求他们的最长公共子串，再判断该最长公共子串是否就是我们要找的最长回文子串。仅比暴力法高效一点点。不是很可取，建议使用动态规划或者中心扩展算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span> s;<span class="comment">//大小为1的字符串必为回文串</span></span><br><span class="line">        <span class="built_in">string</span> rev=s;<span class="comment">//rev存放s反转结果</span></span><br><span class="line">        <span class="built_in">string</span> res;<span class="comment">//存放结果</span></span><br><span class="line">        <span class="built_in">std</span>::reverse(rev.<span class="built_in">begin</span>(),rev.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(rev==s) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;<span class="comment">//存放回文子串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)<span class="comment">//查找s与rev的最长公共子串</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp;<span class="comment">//存放待验证子串</span></span><br><span class="line">            <span class="keyword">if</span>(len &gt; s.length() - i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                temp=temp+s[j];</span><br><span class="line">                <span class="keyword">if</span>(len&gt;=temp.length())</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(rev.<span class="built_in">find</span>(temp)!=<span class="number">-1</span>)<span class="comment">//在rev中找到temp</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> q=temp;<span class="comment">//q用来验证temp是否是回文子串</span></span><br><span class="line">                    <span class="built_in">std</span>::reverse(q.<span class="built_in">begin</span>(),q.<span class="built_in">end</span>());</span><br><span class="line">                    <span class="keyword">if</span>(q==temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        len=temp.length();</span><br><span class="line">                        res=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=<span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法二：-动态规划"><a href="#解法二：-动态规划" class="headerlink" title="解法二： 动态规划"></a>解法二： 动态规划</h3><p><strong>思路总结：</strong></p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200603100755.png" alt="20200603100755"></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;      <span class="comment">//创建一个n*n的二维数组</span></span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> beginat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j + <span class="number">1</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j)  dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[j]) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123; </span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) </span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]; </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlen)&#123;</span><br><span class="line">                    maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                    beginat = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(beginat, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n^2)，其中 n 是字符串的长度。动态规划的状态总数为 O(n^2)，对于每个状态，我们需要转移的时间为 O(1)。</p></li><li><p>空间复杂度：O(n^2)，即存储动态规划状态需要的空间。</p></li></ul><h3 id="解法三：中心扩展算法"><a href="#解法三：中心扩展算法" class="headerlink" title="解法三：中心扩展算法"></a>解法三：中心扩展算法</h3><p><strong>思路与算法</strong></p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200603101104.png" alt="20200603101104"></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;int,int&gt; expandAroundCenter(const string&amp; s, int left, int right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">          <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">              <span class="keyword">auto</span> [left1, right1] = expandAroundCenter(s, i, i);</span><br><span class="line">              <span class="keyword">auto</span> [left2, right2] = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">if</span>(right1 - left1 &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">                  <span class="built_in">end</span> = right1;</span><br><span class="line">                  start = left1;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(right2 - left2 &gt; <span class="built_in">end</span> - start)&#123;</span><br><span class="line">                  <span class="built_in">end</span> = right2;</span><br><span class="line">                  start = left2;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> s.substr(start, <span class="built_in">end</span> - start + <span class="number">1</span>);    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n^2)，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和  n−1 个，每个回文中心最多会向外扩展 O(n) 次。</p></li><li><p>空间复杂度：O(1)。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0602leetcode_2</title>
      <link href="/2020/06/02/202006022-2/"/>
      <url>/2020/06/02/202006022-2/</url>
      
        <content type="html"><![CDATA[<h1 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498. 对角线遍历"></a>498. 对角线遍历</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200602204854.png" alt="20200602204854"></p><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><p>设置一个bool类型的值用来判断对角线遍历的方向是从下往上的还是从上往下的。然后再采取不同的措施。注意开始判断二维数组为空的情况，经测试只能放在开头才不会报错，原因不知。两种判断方式均可，但用 <strong>empty()</strong> 函数据说效率会高一点。</p><p>注意好各种边界值的判断就好做了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//if (matrix.size() == 0 || matrix[0].size() == 0) return &#123;&#125;;</span></span><br><span class="line">            <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            <span class="keyword">bool</span> updown = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> cl = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pac;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; row &amp;&amp; j &lt; cl)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(updown == <span class="literal">true</span>)&#123;         <span class="comment">//从上往下遍历</span></span><br><span class="line">                        pac.push_back(matrix[i][j]);</span><br><span class="line">                        <span class="keyword">while</span>((j - <span class="number">1</span> &gt; <span class="number">0</span> || j - <span class="number">1</span> == <span class="number">0</span>) &amp;&amp; i + <span class="number">1</span> &lt; row )&#123;</span><br><span class="line">                            pac.push_back(matrix[++i][--j]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(i == row - <span class="number">1</span>)   <span class="comment">//换行判断</span></span><br><span class="line">                            j++;</span><br><span class="line">                        <span class="keyword">else</span> i++;</span><br><span class="line">                        updown = <span class="literal">false</span>;   <span class="comment">//改变方向</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(updown == <span class="literal">false</span>)&#123;     <span class="comment">//从下往上遍历</span></span><br><span class="line">                        pac.push_back(matrix[i][j]);</span><br><span class="line">                        <span class="keyword">while</span>((i - <span class="number">1</span> &gt; <span class="number">0</span> || i - <span class="number">1</span> == <span class="number">0</span>) &amp;&amp; j + <span class="number">1</span> &lt; cl )&#123;</span><br><span class="line">                            pac.push_back(matrix[--i][++j]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(j == cl - <span class="number">1</span>)</span><br><span class="line">                            i++;</span><br><span class="line">                        <span class="keyword">else</span> j++;</span><br><span class="line">                        updown = <span class="literal">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pac;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200602212119.png" alt="20200602212119"> </p><h3 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h3><p>较简单，选第一个字符串为基值与后面几个相比较，遇见不一样的就把不一样的往后都删掉，与所有字符串比较完成后得到的即为最终结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;   <span class="comment">//判断容器是否为空</span></span><br><span class="line">        <span class="built_in">string</span> result = strs[<span class="number">0</span>];      <span class="comment">//选取第一个用作基值对照</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (result[j] == strs[i][j]) <span class="comment">//相等则跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    result.erase(j);   <span class="comment">//不等则删掉包括不等的后面的字符</span></span><br><span class="line">                    <span class="keyword">break</span>;             <span class="comment">//跳出循环，进入下一个单词判断过程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0602leetcode</title>
      <link href="/2020/06/02/20200602/"/>
      <url>/2020/06/02/20200602/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a>面试题 01.07. 旋转矩阵</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200602161159.png" alt="20200602161159"></p><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>解法一为常规方法，即新开一个数组用于保存旋转后生成的数组。坐标 <strong>[i][j]</strong> 经过旋转后即变为 <strong>[j][n-i-1]</strong>(n为数组长度)。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">auto</span> matrix_new = matrix;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.<span class="built_in">size</span>(); j++)</span><br><span class="line">               matrix_new[i][j] = matrix[matrix.<span class="built_in">size</span>()-j<span class="number">-1</span>][i];</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           matrix = matrix_new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(N^2)，其中 NN 是 matrix 的边长。</p></li><li><p>空间复杂度：O(N^2)，我们需要使用一个和 matrix 的大小相同的辅助数组。</p></li></ul><h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>解法二是直接在原数组上进行操作，所以空间复杂度由方法一的<strong>O(N^2)</strong>变为<strong>O(1)</strong>,但由于是双重循环，因此时间复杂度没有变化，仍然为<strong>O(N^2)</strong>。解法二比较难想，不过想明白了就比较简单。</p><p>我们只需要枚举矩阵左上角高为 ⌊n/2⌋，宽为 ⌊(n+1)/2⌋ 的子矩阵即可。</p><p>具体坐标变换为 [i][j] –&gt; [j][n-i-1] –&gt; [n-i-1][n-j-1] –&gt; [n-j-1][i]</p><center><p><img src="https://pic.leetcode-cn.com/194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate.gif" alt="leetcode_picture"></p></center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(N^2)，其中 N 是 matrix 的边长。我们需要枚举的子矩阵大小为 O([n/2]×[(n+1)/2])=O(N^2)。</p></li><li><p>空间复杂度：O(1)，为原地旋转。</p></li></ul><h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>此方法同样也是在原数组上进行操作，但比较方法二更容易理解：</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200602162701.png" alt="20200602162701"></p><p>通过两次翻转操作即可得到最终的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(N^2)其中 N 是 matrix 的边长。对于每一次翻转操作，我们都需要枚举矩阵中一半的元素。</p></li><li><p>空间复杂度：O(1)，为原地翻转得到的原地旋转。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0601leetcode_2</title>
      <link href="/2020/06/01/20200601-2/"/>
      <url>/2020/06/01/20200601-2/</url>
      
        <content type="html"><![CDATA[<h1 id="724-寻找数组的中心索引"><a href="#724-寻找数组的中心索引" class="headerlink" title="724. 寻找数组的中心索引"></a>724. 寻找数组的中心索引</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200601174312.png" alt="20200601174312"></p><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p> 解法一是刚看到题目时解题想到的方法，另作一个函数递归求解问题，如果左边和大就<strong>mid–</strong>,反之<strong>mid++</strong>。效率比较低，工作量比较大，提交代码时也出现了超时的提示，故此方法不可取。具体实现代码如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Isequal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> mid, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">if</span>(mid &lt; <span class="number">0</span> || mid &gt; num.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">            id = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; mid;i++)</span><br><span class="line">            sum1 += num[i];</span><br><span class="line">        <span class="keyword">int</span> sum2 = sum - sum1 - num[mid];</span><br><span class="line">        <span class="keyword">if</span>(sum1 == sum2) id = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum1 &gt; sum2) id = Isequal(num, --mid, sum);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum1 &lt; sum2) id = Isequal(num, ++mid, sum);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">size</span>;i++)&#123;</span><br><span class="line">           sum += nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Isequal(nums, <span class="built_in">size</span>/<span class="number">2</span>, sum);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p> 解法二是在网上看了网友解题评论才知道的，即判断<strong>左边和×2+中间值</strong>是不是等于<strong>sum</strong>即可，简洁高效！！</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> sumleft = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (sumleft * <span class="number">2</span> + nums[i] == sum)</span><br><span class="line">             <span class="keyword">return</span> i;</span><br><span class="line">         sumleft += nums[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0601leetcode_3</title>
      <link href="/2020/06/01/20200601-3/"/>
      <url>/2020/06/01/20200601-3/</url>
      
        <content type="html"><![CDATA[<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200601231420.png" alt="20200601231420"></p><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><p>先进行size判断，过滤掉一部分输入。然后对二维数组进行排序。然后新建一个二维数组存放最终结果。</p><p><img src="https://pic.leetcode-cn.com/50417462969bd13230276c0847726c0909873d22135775ef4022e806475d763e-56-2.png" alt="after_sort"></p><p>我们用数组 tem 存储最终的答案。</p><p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 tem 数组中，并按顺序依次考虑之后的每个区间：</p><ul><li><p>如果当前区间的左端点在数组 tem 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 tem 的末尾；</p></li><li><p>否则，它们重合，我们需要用当前区间的右端点更新数组 tem 中最后一个区间的右端点，将其置为二者的较大值。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">tem</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tem;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(tem.<span class="built_in">size</span>() == <span class="number">0</span> || tem.back()[<span class="number">1</span>] &lt; left)&#123;</span><br><span class="line">            tem.push_back(&#123;left, right&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tem.back()[<span class="number">1</span>] = <span class="built_in">max</span>(tem.back()[<span class="number">1</span>], right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0601leetcode</title>
      <link href="/2020/06/01/20200601/"/>
      <url>/2020/06/01/20200601/</url>
      
        <content type="html"><![CDATA[<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200601171125.png" alt="20200601171125"></p><h3 id="解法一-："><a href="#解法一-：" class="headerlink" title="解法一 ："></a>解法一 ：</h3><p>分为两步进行，第一个循环找出除掉重复数后数组的个数，第二个循环是对数组进行排序整理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>( len &lt; <span class="number">2</span> ) <span class="keyword">return</span> len;</span><br><span class="line">        <span class="keyword">int</span> count = len;</span><br><span class="line">         <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>( i &lt; len - <span class="number">1</span> )&#123;</span><br><span class="line">             <span class="keyword">int</span> j = i+<span class="number">1</span> ;</span><br><span class="line">             <span class="keyword">if</span>(nums[i] == nums[j])</span><br><span class="line">             count--;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;    </span><br><span class="line">         i = <span class="number">0</span> ; <span class="keyword">int</span> j =<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(i &lt; count - <span class="number">1</span> )&#123;</span><br><span class="line">           <span class="keyword">if</span>( nums[i] == nums[j] )&#123;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">              nums[++i] = nums[j];</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="解法二-："><a href="#解法二-：" class="headerlink" title="解法二 ："></a>解法二 ：</h3><p>  一步到位，判断加移位，不是很好想。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != nums[i])</span><br><span class="line">                nums[++j] = nums[i];</span><br><span class="line">        <span class="keyword">return</span> ++j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入输出流</title>
      <link href="/2020/05/12/inout/"/>
      <url>/2020/05/12/inout/</url>
      
        <content type="html"><![CDATA[<h2 id="流的定义以及C-流类和流对象"><a href="#流的定义以及C-流类和流对象" class="headerlink" title="流的定义以及C++流类和流对象"></a>流的定义以及C++流类和流对象</h2><p>程序中常用的 cin 和 cout，分别用于从键盘输入数据和向屏幕输出数据（简称为标准 I/O）。除此之外，程序还可以从文件中读入数据，以及向文件中写入数据（简称为文件 I/O)。</p><p>数据输入和输出的过程也是数据传输的过程。数据像水一样从一个地方流动到另一个地方，因此，在 C++ 中将此过程称为 “流（stream）”。</p><p>在 C++ 的标准类库中，将用于进行数据输入输出的类统称为“流类”。cin 是流类 istream 的对象，cout 是流类 ostream 的对象。要使用流类，需要在程序中包含 iostream 头文件。</p><p>C++ 中常用的几个流类及其相互关系如图所示：</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200512161251.png" alt="20200512161251"></p><p>图1中的箭头代表派生关系。例如，ios 是抽象的基类，它派生出 istream 和 ostream。 istream 和 ostream 又共同派生了 iostream 类。</p><p>为了避免多继承的二义性，从 ios 派生出 istream 和 ostream 时，均使用了 <strong>virtual 关键字（虚继承）</strong>。</p><ul><li>istream 是用于输入的流类，cin 就是该类的对象。</li><li>ostream 是用于输出的流类，cout 就是该类的对象。</li><li>ifstream 是用于从文件读取数据的类。</li><li>ofstream 是用于向文件写入数据的类。</li><li>iostream 是既能用于输入，又能用于输出的类。</li><li>fstream 是既能从文件读取数据，又能向文件写入数据的类。</li></ul><h3 id="标准流对象"><a href="#标准流对象" class="headerlink" title="标准流对象"></a>标准流对象</h3><p>iostream 头文件中定义了四个标准流对象，它们是 cin、cout、cerr 和 clog。</p><ul><li>cin 对应于标准输入流，用于从键盘读取数据，也<strong>可以被重定向</strong>为从文件中读取数据。</li><li>cout 对应于标准输出流，用于向屏幕输出数据，也<strong>可以被重定向</strong>为向文件写入数据。</li><li>cerr 对应于标准错误输出流，用于向屏幕输出出错信息，<strong>不能被重定向</strong>。</li><li>clog 对应于标准错误输出流，用于向屏幕输出出错信息，<strong>不能被重定向</strong>。</li></ul><p>cerr 和 clog的区别在于：cerr 不使用缓冲区，直接向显示器输出信息；而输出到 clog 中的信息会先被存放到缓冲区，缓冲区满或者刷新时才输出到屏幕。</p><p>ostream 类的无参构造函数和复制构造函数都是私有的，因此在程序中一般无法定义 ostream 类的对象，<strong>唯一能用</strong>的 ostream 类的对象就是 cout。</p><p>当然，上面关于 cout 对象的定义语句说明 ostream 类是有一个公有构造函数的，如果知道这个构造函数是什么样的，那么也能自己定义 ostream 类的对象——但这么做并无必要。</p><p>cout 可以被重定向，而 cerr 不能。所谓重定向，就是将输入的源或输出的目的地改变。例如，cout 本来是输出到屏幕上的，但是经过重定向，本该输出到屏幕上的东西就可以被输出到文件中。</p><p>例如下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">freopen是被包含于C标准库头文件stdio.h中的一个函数，用于重定向输入输出流。该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">C89函数声明：</span></span><br><span class="line"><span class="comment">*FILE freopen( const char filename, const char mode, FILE stream );</span></span><br><span class="line"><span class="comment">形参说明：</span></span><br><span class="line"><span class="comment">filename：需要重定向到的文件名或文件路径。</span></span><br><span class="line"><span class="comment">mode：代表文件访问权限的字符串。例如，"r"表示“只读访问”、"w"表示“只写访问”、"a"表示“追加写入”。</span></span><br><span class="line"><span class="comment">stream：需要被重定向的文件流。</span></span><br><span class="line"><span class="comment">返回值：如果成功，则返回该指向该输出流的文件指针，否则返回为NULL。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    freopen(<span class="string">"test.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);  <span class="comment">//将标准输出重定向到 test.txt文件</span></span><br><span class="line">    <span class="keyword">if</span>( y == <span class="number">0</span> )  <span class="comment">//除数为0则输出错误信息</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"error."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x /y ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重定向之后，所有对 cout 的输出都不再出现在屏幕上，而是出现在 test.txt 文件中。</p><p>test.txt 文件会和本程序的可执行文件出现在同一个文件夹中。重定向仅对本程序有效，不影响其他程序。</p><p>运行本程序，输入</p><blockquote><p>6 2↙</p></blockquote><p>程序没有输出，但是打开 test.txt文件，可以看到文件中有</p><blockquote><p>3</p></blockquote><p>如果输入</p><blockquote><p>4 0↙</p></blockquote><p>则程序在屏幕上输出</p><blockquote><p>error.</p></blockquote><p>说明 cerr <strong>不会被重定向</strong>。</p><p>cin 也是可以被重定向的。如果在程序中加入</p><blockquote><p>freopen(“input.dat”, “r”, stdin);</p></blockquote><p>第二个参数 r 代表读入方式，第三个参数 stdin 代表标准输入。执行此语句后，cin 就不再从键盘读入数据，而是从 input.dat 文件中读人数据，input.dat 文件中有什么，就相当于从键盘输入了什么。</p><h2 id="cout格式化输出（输出格式）"><a href="#cout格式化输出（输出格式）" class="headerlink" title="cout格式化输出（输出格式）"></a>cout格式化输出（输出格式）</h2><p>有时希望按照一定的格式进行输出，如按十六进制输出整数，输出浮点数时保留小数点后面两位，输出整数时按 6 个数字的宽度输出，宽度不足时左边补 0，等等。C语言中的 printf() 函数使用以%开头的格式控制符，例如 %X、%.2f、%6d 等；C++ 中的 cout 对象则使用<strong>流操作算子</strong>（你也可以叫做格式控制符）或者<strong>成员函数</strong>进行控制。</p><h3 id="使用流操作算子"><a href="#使用流操作算子" class="headerlink" title="使用流操作算子"></a>使用流操作算子</h3><p>C++ 中常用的输出流操纵算子如下表所示，它们都是在头文件 iomanip 中定义的；要使用这些流操纵算子，必须包含该头文件。</p><blockquote><p>注意：“流操纵算子”一栏中的星号*不是算子的一部分，星号表示在没有使用任何算子的情况下，就等效于使用了该算子。例如，在默认情况下，整数是用十进制形式输出的，等效于使用了 dec 算子。</p></blockquote><table><thead><tr><th>流操纵算子</th><th>作  用</th><th style="text-align:right"></th></tr></thead><tbody><tr><td>*dec</td><td>以十进制形式输出整数</td><td style="text-align:right" rowspan="13">常用</td></tr><tr><td>hex</td><td>以十六进制形式输出整数</td></tr><tr><td>oct</td><td>以八进制形式输出整数</td></tr><tr><td>fixed</td><td>以普通小数形式输出浮点数</td></tr><tr><td>scientific</td><td>以科学计数法形式输出浮点数</td></tr><tr><td>left</td><td>左对齐，即在宽度不足时将填充字符添加到右边</td></tr><tr><td>*right</td><td>右对齐，即在宽度不足时将填充字符添加到左边</td></tr><tr><td>setbase(b)</td><td>设置输出整数时的进制，b=8、10 或 16</td></tr><tr><td>setw(w)</td><td>指定输出宽度为 w 个字符，或输人字符串时读入 w 个字符</td></tr><tr><td>setfill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td></tr><tr><td>setprecision(n)</td><td>1.设置输出浮点数的精度为 n。<p>2.在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。</p><p>3.在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</td></p></tr><tr><td>setiosflags(flag)</td><td>将某个输出格式标志置为 1</td></tr><tr><td>resetiosflags(flag)</td><td>将某个输出格式标志置为 0</td></tr><tr><td>boolapha</td><td>把 true 和 false 输出为字符串</td><td style="text-align:right" rowspan="13">不常用</td></tr><tr><td>*noboolalpha</td><td>把 true 和 false 输出为 0、1</td></tr><tr><td>showbase</td><td>输出表示数值的进制的前缀</td></tr><tr><td>*noshowbase</td><td>不输出表示数值的进制.的前缀</td></tr><tr><td>showpoint</td><td>总是输出小数点</td></tr><tr><td>*noshowpoint</td><td>只有当小数部分存在时才显示小数点</td></tr><tr><td>showpos</td><td>在非负数值中显示 +</td></tr><tr><td>*noshowpos</td><td>在非负数值中不显示 +</td></tr><tr><td>*skipws</td><td>输入时跳过空白字符</td></tr><tr><td>noskipws</td><td>输入时不跳过空白字符</td></tr><tr><td>uppercase</td><td>十六进制数中使用 A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td></tr><tr><td>*nouppercase</td><td>十六进制数中使用 a~e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。</td></tr><tr><td>internal</td><td>数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td></tr></tbody></table><p><strong>流操作算子的使用方法</strong></p><p>使用这些算子的方法是将算子用 &lt;&lt; 和 cout 连用。例如：</p><blockquote><p>cout &lt;&lt; hex &lt;&lt; 12 &lt;&lt; “,” &lt;&lt; 24;</p></blockquote><p>这条语句的作用是指定以十六进制形式输出后面两个数，因此输出结果是：</p><blockquote><p>c, 18</p></blockquote><p><strong>setiosflags() 算子</strong><br>setiosflags() 算子实际上是一个库函数，它以一些标志作为参数，这些标志可以是在 iostream 头文件中定义的以下几种取值，它们的含义和同名算子一样。</p><table><thead><tr><th>标 志</th><th>作 用</th></tr></thead><tbody><tr><td>ios::left</td><td>输出数据在本域宽范围内向左对齐</td></tr><tr><td>ios::right</td><td>输出数据在本域宽范围内向右对齐</td></tr><tr><td>ios::internal</td><td>数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</td></tr><tr><td>ios::dec</td><td>设置整数的基数为 10</td></tr><tr><td>ios::oct</td><td>设置整数的基数为 8</td></tr><tr><td>ios::hex</td><td>设置整数的基数为 16</td></tr><tr><td>ios::showbase</td><td>强制输出整数的基数（八进制数以 0 开头，十六进制数以 0x 打头）</td></tr><tr><td>ios::showpoint</td><td>强制输出浮点数的小点和尾数 0</td></tr><tr><td>ios::uppercase</td><td>在以科学记数法格式 E 和以十六进制输出字母时以大写表示</td></tr><tr><td>ios::showpos</td><td>对正数显示“+”号</td></tr><tr><td>ios::scientific</td><td>浮点数以科学记数法格式输出</td></tr><tr><td>ios::fixed</td><td>浮点数以定点格式（小数形式）输出</td></tr><tr><td>ios::unitbuf</td><td>每次输出之后刷新所有的流</td></tr><tr><td>ios::stdio</td><td>每次输出之后清除 stdout, stderr</td></tr></tbody></table><p>这些标志实际上都是仅有某比特位为 1，而其他比特位都为 0 的整数。</p><p>多个标志可以用|运算符连接，表示同时设置。例如：</p><blockquote><p>cout &lt;&lt; setiosflags(ios::scientific|ios::showpos) &lt;&lt; 12.34;</p></blockquote><p>输出结果是：</p><blockquote><p>+1.234000e+001</p></blockquote><p>如果两个相互矛盾的标志同时被设置，如先设置 setiosflags(ios::fixed)，然后又设置 setiosflags(ios::scientific)，那么结果可能就是两个标志都不起作用。因此，在设置了某标志，又要设置其他与之矛盾的标志时，就应该用 resetiosflags 清除原先的标志。例如下面三条语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; <span class="number">12.34</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; resetiosflags(ios::fixed) &lt;&lt; setiosflags(ios::scientific | ios::showpos) &lt;&lt; <span class="number">12.34</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; resetiosflags(ios::showpos) &lt;&lt; <span class="number">12.34</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//清除要输出正号的标志</span></span><br></pre></td></tr></table></figure><p>输出结果是：   </p><blockquote><p>12.340000<br>+1.234000e+001<br>1.234000e+001   </p></blockquote><p><strong>综合示例</strong><br>关于流操纵算子的使用，来看下面的程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">141</span>;</span><br><span class="line">    <span class="comment">//1) 分别以十六进制、十进制、八进制先后输出 n</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1)"</span> &lt;&lt; hex &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; dec &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; oct &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">1234567.89</span>, y = <span class="number">12.34567</span>;</span><br><span class="line">    <span class="comment">//2)保留5位有效数字</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2)"</span> &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//3)保留小数点后面5位</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3)"</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//4)科学计数法输出，且保留小数点后面5位</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4)"</span> &lt;&lt; scientific &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//5)非负数显示正号，输出宽度为12字符，宽度不足则用 * 填补</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5)"</span> &lt;&lt; showpos &lt;&lt; fixed &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; setfill(<span class="string">'*'</span>) &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//6)非负数不显示正号，输出宽度为12字符，宽度不足则右边用填充字符填充</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6)"</span> &lt;&lt; noshowpos &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; left &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//7)输出宽度为 12 字符，宽度不足则左边用填充字符填充</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"7)"</span> &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; right &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//8)宽度不足时，负号和数值分列左右，中间用填充字符填充</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"8)"</span> &lt;&lt; setw(<span class="number">12</span>) &lt;&lt; internal &lt;&lt; <span class="number">-12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"9)"</span> &lt;&lt; <span class="number">12.1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)<span class="number">8</span>d <span class="number">141</span> <span class="number">215</span>    </span><br><span class="line"><span class="number">2</span>)<span class="number">1.2346e+06</span> <span class="number">12.346</span>      </span><br><span class="line"><span class="number">3</span>)<span class="number">1234567.89000</span> <span class="number">12.34567</span>      </span><br><span class="line"><span class="number">4</span>)<span class="number">1.23457e+06</span> <span class="number">1.23457e+01</span>      </span><br><span class="line"><span class="number">5</span>)***+<span class="number">12.10000</span>     </span><br><span class="line"><span class="number">6</span>)<span class="number">12.10000</span>****     </span><br><span class="line"><span class="number">7</span>)****<span class="number">12.10000</span>     </span><br><span class="line"><span class="number">8</span>)-***<span class="number">12.10000</span>     </span><br><span class="line"><span class="number">9</span>)<span class="number">12.10000</span></span><br></pre></td></tr></table></figure><p>需要注意的是，setw() 算子所起的作用是一次性的，即只影响下一次输出。每次需要指定输出宽度时都要使用 setw()。因此可以看到，第 9) 行的输出因为没有使用 setw()，输出的宽度就不再是前面指定的 12 个字符。但是setprecision(5)的影响并不是一次性的。</p><p>在读入字符串时，setw() 还能影响 cin 的行为。例如下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; setw(<span class="number">4</span>) &gt;&gt; s1 &gt;&gt; setw(<span class="number">3</span>) &gt;&gt; s2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="string">","</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：</p><blockquote><p>1234567890↙</p></blockquote><p>程序的输出结果是：</p><blockquote><p>1234,567</p></blockquote><p>说明setw(4)使得读入 s1 时，只读入 4 个字符，其后的setw(3)使得读入 s2 时只读入 3 个字符。</p><p>setw() 用于 cin 时，<strong>同样只影响下一次的输入</strong>。</p><h3 id="调用cout的成员函数"><a href="#调用cout的成员函数" class="headerlink" title="调用cout的成员函数"></a>调用cout的成员函数</h3><p>stream 类有一些成员函数，通过 cout 调用它们也能用于控制输出的格式，其作用和流操纵算子相同，如表所示:</p><table><thead><tr><th>成员函数</th><th>作用相同的流操纵算子</th><th>说明</th></tr></thead><tbody><tr><td>precision(n)</td><td>setprecision(n)</td><td>设置输出浮点数的精度为 n。</td></tr><tr><td>width(w)</td><td>setw(w)</td><td>指定输出宽度为 w 个字符。</td></tr><tr><td>fill(c)</td><td>setfill (c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）。</td></tr><tr><td>setf(flag)</td><td>setiosflags(flag)</td><td>将某个输出格式标志置为 1。</td></tr><tr><td>unsetf(flag)</td><td>resetiosflags(flag)</td><td>将某个输出格式标志置为 0。</td></tr></tbody></table><p>setf 和 unsetf 函数用到的<strong>flag</strong>，与 setiosflags 和 resetiosflags 用到的完全相同。</p><p>这些成员函数的用法十分简单。例如下面的三行程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::scientific);</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">12.23</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>1.22300000e+01</p></blockquote><h2 id="C-cout-put-：输出单个字符"><a href="#C-cout-put-：输出单个字符" class="headerlink" title="C++ cout.put()：输出单个字符"></a>C++ cout.put()：输出单个字符</h2><p>C++ 程序中一般用 ostream 类的 cout 输出流对象和 &lt;&lt; 输出运算符实现输出，并且 cout 输出流在内存中有相应的缓冲区。但有时用户还有特殊的输出需求，例如只输出一个字符，这种情况下可以借助该类提供的 put() 成员方法实现。</p><p>put() 方法专用于向输出流缓冲区中添加单个字符，其语法格式如下：</p><blockquote><p>ostream＆put(char c);</p></blockquote><p>其中，参数 c 为要输出的字符。</p><p>可以看到，该函数会返回一个 ostream 类的引用对象，可以理解返回的是 cout 的引用。这意味着，我们可以像下面这样使用 put() 函数：</p><blockquote><p>cout.put(c1).put(c2).put(c3);</p></blockquote><p>因为 cout.put(c1) 向输出流缓冲区中添加 c1 字符的同时，返回一个引用形式的 cout 对象，所以可以继续用此对象调用 put(c2)，依次类推。 </p><p>【实例1】输出单个字符 a。</p><blockquote><p>cout.put(‘a’);</p></blockquote><p>调用该方法的结果是在屏幕上显示一个字符 a。</p><p>【实例2】put() 函数的参数可以是字符或字符的 ASCII 代码（也可以是一个整型表达式）。</p><blockquote><p>cout.put(65 + 32);<br>cout.put(97);</p></blockquote><p>上面两行代码都输出字符 a，因为 97 是字符 a 的 ASCII 代码。</p><p>【实例3】可以在一个语句中连续调用 put() 函数，例如：</p><blockquote><p>cout.put(71).put(79).put(79). put(68).put(‘\n’);</p></blockquote><p>在屏幕上显示GOOD。</p><p>【实例4】有一个字符串 “abcdefg”，要求把它们按相反的顺序输出:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">cout</span>.<span class="built_in">put</span>(str[i]);  <span class="comment">//从最后一个字符开始输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>.<span class="built_in">put</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>gfedcba</p></blockquote><p>除了使用 cout.put() 函数输出一个字符外，还可以用 putchar() 函数输出一个字符。putchar() 函数是C语言中使用的，C++保留了这个函数，在 &lt;iostream&gt; 头文件中定义。<br>下面是 putchar() 函数的声明。</p><blockquote><p>int putchar(int char)</p></blockquote><p>下面的实例演示了 putchar() 函数的用法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(ch = <span class="string">'A'</span> ; ch &lt;= <span class="string">'Z'</span> ; ch++) &#123;</span><br><span class="line">      <span class="built_in">putchar</span>(ch);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>ABCDEFGHIJKLMNOPQRSTUVWXYZ</p></blockquote><h2 id="C-cin判断输入结束（读取结束）"><a href="#C-cin判断输入结束（读取结束）" class="headerlink" title="C++ cin判断输入结束（读取结束）"></a>C++ cin判断输入结束（读取结束）</h2><p>cin 可以用来从键盘输入数据；将标准输入重定向为文件后，cin 也可以用来从文件中读入数据。在输入数据的多少不确定，且没有结束标志的情况下，该如何判断输入数据已经读完了呢？</p><p>其实在控制台中输入特殊的控制字符就表示输入结束：</p><ul><li>在 Windows 系统中，通过键盘输入时，按 Ctrl+Z 组合键后再按回车键，就代表输入结束。</li><li>在 UNIX/Linux/Mac OS 系统中，Ctrl+D 代表输入结束。</li></ul><p><strong>不管是文件末尾，还是 Ctrl+Z 或者 Ctrl+D，它们都是结束标志；cin 在正常读取时返回 true，遇到结束标志时返回 false，我们可以根据 cin 的返回值来判断是否读取结束。</strong></p><h3 id="cin-判断控制台（键盘）读取结束"><a href="#cin-判断控制台（键盘）读取结束" class="headerlink" title="cin 判断控制台（键盘）读取结束"></a>cin 判断控制台（键盘）读取结束</h3><p>输入若干个正整数，输出其中的最大值，程序该如何编写？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> maxN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)&#123;  <span class="comment">//输入没有结束，cin 就返回 true，条件就为真</span></span><br><span class="line">        <span class="keyword">if</span> (maxN &lt; n)</span><br><span class="line">            maxN = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxN &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Windows 下运行该程序，先输入以下整数：</p><blockquote><p>10<br>30<br>93<br>206<br>8      </p></blockquote><p>然后在按下 Ctrl+Z 组合键（可以在当前行，也可以在新的一行），接着按下回车键，输入就结束了，此时 cin 返回 false，循环结束，得到了最大值。</p><p>完整的输入输出结果如下所示：</p><blockquote><p>10↙<br>30↙<br>93↙<br>206↙<br>8↙<br>^Z↙<br>206     </p></blockquote><p>↙表示回车键，^Z表示 Ctrl+Z 组合键。</p><h3 id="cin-判断文件读取结束"><a href="#cin-判断文件读取结束" class="headerlink" title="cin 判断文件读取结束"></a>cin 判断文件读取结束</h3><p>cin 读到文件末尾时，cin&gt;&gt;n就会返回 false，从而导致程序结束。例如，假定 test.txt 文件中的内容如下所示：</p><blockquote><p>112<br>23123<br>34 444 55<br>44           </p></blockquote><p>代码及演示如下图：<br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200512181848.png" alt="20200512181848"></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>重载部分提到过 istream 类将 &gt;&gt; 重载为成员函数，而且这些成员函数的返回值是 cin 的引用。准确地说，cin&gt;&gt; n 的返回值的确是 istream &amp; 类型的，而 while 语句中的条件表达式的返回值应该是 bool 类型、整数类型或其他和整数类型兼容的类型，istream &amp; 显然和整数类型不兼容，为什么while(cin&gt;&gt;n)还能成立呢？</p><p>这是因为，<strong>istream 类对强制类型转换运算符 bool 进行了重载</strong>，这使得 cin 对象可以被自动转换成 bool 类型。所谓自动转换的过程，就是调用 cin 的 operator bool() 这个成员函数，而该成员函数可以返回某个标志值，该标志值在 cin 没有读到输入结尾时为 true，读到输入结尾后变为 false。对该标志值的设置，在 operator &lt;&lt;() 成员函数中进行。</p><p>如果 cin 在读取过程中发生了错误，cin&gt;&gt;n这样的表达式也会返回 false。例如下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序本该输入整数，如果输入了一个字母，则程序就会结束。因为，应该读入整数时却读入了字母也算读入出错。</p><h2 id="cin-get-：C-读取单个字符"><a href="#cin-get-：C-读取单个字符" class="headerlink" title="cin.get()：C++读取单个字符"></a>cin.get()：C++读取单个字符</h2><p>get() 是 istream 类的成员函数，它有多种重载形式，此处只介绍最简单最常用的一种：</p><blockquote><p>int get();</p></blockquote><p>此函数从输入流中读入一个字符，返回值就是该字符的 ASCII 码。如果碰到输入的末尾，则返回值为 EOF。</p><p>EOF 是 End of File 的缩写。istream 类中从输入流（包括文件）中读取数据的成员函数，在把输入数据都读取完后再进行读取，就会返回 EOF。<strong>EOF 是在 iostream 类中定义的一个整型常量，值为 -1。</strong></p><p>get() 函数<strong>不会跳过空格、制表符、回车等特殊字符</strong>，所有的字符都能被读入。例如下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">cin</span>.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">        <span class="built_in">cout</span>.<span class="built_in">put</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行情况如下：</p><blockquote><p>abcdefg↙<br>abcdefg<br>C++ Tutorial↙<br>C++ Tutorial<br>^Z↙</p></blockquote><p>↙表示回车键，^Z表示 Ctrl+Z 组合键。</p><p>程序中的变量 c 应为 int 类型，而不能是 char 类型。在输入流中碰到 ASCII 码等于 0xFF 的字符时，cin.get() 返回 0xFF，0xFF 赋值给 c，此时如果 c 是 char 类型的，那么其值就是 -1（因为符号位为 1 代表负数），即等于 EOF，于是程序就错误地认为输入已经结束。</p><p>而在 c 为 int 类型的情况下，将 0xFF 赋值给 c，c 的值是 255（因为符号位为 0，是正数），而非 -1，即除非读到输入末尾，c 的值都不可能是 -1。</p><p>要将文本文件 test.txt 中的全部内容原样显示出来，程序可以如下编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    freopen(<span class="string">"test.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);  <span class="comment">//将标准输入重定向为 test.txt</span></span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">cin</span>.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">        <span class="built_in">cout</span>.<span class="built_in">put</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图如下：</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200512210019.png" alt="20200512210019"></p><h2 id="cin-getline-：C-读入一行字符串（整行数据）"><a href="#cin-getline-：C-读入一行字符串（整行数据）" class="headerlink" title="cin.getline()：C++读入一行字符串（整行数据）"></a>cin.getline()：C++读入一行字符串（整行数据）</h2><p>getline() 是 istream 类的成员函数，它有如下两个重载版本：</p><blockquote><p>istream &amp; getline(char* buf, int bufSize);<br>istream &amp; getline(char* buf, int bufSize, char delim);</p></blockquote><p>第一个版本从输入流中读取 bufSize-1 个字符到缓冲区 buf，或遇到\n为止（<strong>哪个条件先满足就按哪个执行</strong>）。函数会自动在 buf 中读入数据的结尾添加\0。</p><p>第二个版本和第一个版本的区别在于，第一个版本是读到\n为止，第二个版本是读到 delim 字符为止。\n或 delim 都不会被读入 buf，但会被从输入流中取走。</p><p>这两个函数的返回值就是函数所作用的对象的引用。如果输入流中\n或 delim 之前的字符个数达到或超过 bufSize，就会导致读入出错，其结果是：虽然本次读入已经完成，但是之后的读入都会失败。</p><p>从输入流中读入一行，可以用第一个版本。用cin &gt;&gt; str这种写法是不行的，因为此种读法在碰到行中的空格或制表符时就会停止，因此就不能保证 str 中读入的是整行。</p><p>第一个版本的 getline 函数的用法示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> szBuf[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">120</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">cin</span>.getline(szBuf,<span class="number">6</span>))  <span class="comment">//如果输入流中一行字符超过5个，就会出错</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; szBuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">//clear能够清除cin内部的错误标记，使之恢复正常</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行过程如下：</p><blockquote><p>ab cd↙<br>ab cd<br>33↙<br>33<br>44↙<br>44        </p></blockquote><p>在上面的输入情况下，程序是正常的。程序运行过程中还可能出现如下情况：</p><blockquote><p>ab cd123456k↙<br>error<br>ab cd<br>120<br>123456       </p></blockquote><p>第 7 行，读入时因字符串超长导致出错，于是第 11 行并没有从输入流读入 n，n 维持了原来的值 120。</p><p>第 12 行，调用 istream 的成员函数 clear() 清除 cin 内部的错误标记，此后 cin 又能正常读入了。因此，123456 在第 13 行被读入 n。</p><p>可以用 getline() 函数的返回值（为 false 则输入结束）来判断输入是否结束。例如，要将文件 test.txt 中的全部内容（假设文件中一行最长有 10 000个字符）原样显示，程序可以如下编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LINE_LEN = <span class="number">10000</span>;  <span class="comment">//假设文件中一行最长 10000 个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> szBuf[MAX_LINE_LEN + <span class="number">10</span>];</span><br><span class="line">    freopen(<span class="string">"test.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);  <span class="comment">//将标准输入重定向为 test.txt</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>.getline(szBuf, MAX_LINE_LEN + <span class="number">5</span>))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; szBuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序每次读入文件中的一行到 szBuf 并输出。szBuf 中不会读入回车符，因此输出 szBuf 后要再输出 endl 以换行。</p><h2 id="cin-ignore-：C-跳过（忽略）指定字符"><a href="#cin-ignore-：C-跳过（忽略）指定字符" class="headerlink" title="cin.ignore()：C++跳过（忽略）指定字符"></a>cin.ignore()：C++跳过（忽略）指定字符</h2><p>ignore() 是 istream 类的成员函数，它的原型是：</p><blockquote><p>istream &amp; ignore(int n =1, int delim = EOF);</p></blockquote><p>此函数的作用是跳过输入流中的 n 个字符，或跳过 delim 及其之前的所有字符，哪个条件先满足就按哪个执行。两个参数都有默认值，因此 cin.ignore() 就等效于 cin.ignore(1, EOF)， 即跳过一个字符。</p><p>该函数常用于跳过输入中的无用部分，以便提取有用的部分。例如，输入的电话号码形式是 Tel:63652823 ，Tel: 就是无用的内容。例如下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>.ignore(<span class="number">5</span>, <span class="string">'A'</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行过程可能如下：</p><blockquote><p>abcde34↙<br>34</p></blockquote><p>cin.ignore() 跳过了输入中的前 5 个字符，其余内容被当作整数输入 n 中。</p><p>该程序的运行过程也可能如下：</p><blockquote><p>abA34↙<br>34</p></blockquote><p>cin.ignore() 跳过了输入中的 ‘A’ 及其前面的字符，其余内容被当作整数输入 n 中。</p><h2 id="cin-peek-：C-查看输入流中的下一个字符"><a href="#cin-peek-：C-查看输入流中的下一个字符" class="headerlink" title="cin.peek()：C++查看输入流中的下一个字符"></a>cin.peek()：C++查看输入流中的下一个字符</h2><p>peek() 是 istream 类的成员函数，它的原型是：</p><blockquote><p>int peek();</p></blockquote><p>此函数返回输入流中的下一个字符，但是并不将该字符从输入流中取走——相当于只是看了一眼下一个字符，因此叫 peek。</p><p>cin.peek() 不会跳过输入流中的空格、回车符。在输入流已经结束的情况下，cin.peek() 返回 EOF。</p><p>在输入数据的格式不同，需要预先判断格式再决定如何输入时，peek() 就能起到作用。</p><p>例题：编写一个日期格式转换程序，输入若干个日期，每行一个，要求全部转换为“mm-dd-yyyy”格式输出。输入的日期格式可以是“2011.12.24”（中式格式），也可以是“Dec 24 2011”（西式格式）。要求该程序对于以下输入数据：</p><blockquote><p>Dec 3 1990<br>2011.2.3<br>458.12.1<br>Nov 4 1998<br>Feb 12 2011             </p></blockquote><p>输出结果应为：</p><blockquote><p>12-03-1990<br>02-03-2011<br>12-01-0458<br>11-04-1998<br>02-12-2011       </p></blockquote><p>输入数据中的 Ctrl+Z 略去不写，因为输入数据也可能来自于文件。</p><p>编写这个程序时，如果输入的是中式格式，就用 cin&gt;&gt;year（假设 year 是 int 类型变量）读取年份，然后再读取后面的内容；如果输入是西式格式，就用 cin&gt;&gt;sMonth（假设 sMonth 是 string 类型对象）读取月份，然后读取后面的内容。</p><p>可是，如果没有将数据从输入流中读取出来，就无法判断输入到底是哪种格式。即便用 cin.get() 读取一个字符后再作判断，也很不方便。例如，在输入为2011.12.24的情况下，读取第一个字符2后就知道是格式一，问题是输入流中的已经被读取了，剩下的表示年份的部分只有011，如何将这个011和前面读取的2奏成一个整数 2011，也是颇费周折的事情。使用 peek() 函数很容易解决这个问题。</p><p>示例程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> Months[<span class="number">12</span>] = &#123; <span class="string">"Jan"</span>,<span class="string">"Feb"</span>,<span class="string">"Mar"</span>,<span class="string">"Apr"</span>,<span class="string">"May"</span>,<span class="string">"Jun"</span>,<span class="string">"Jul"</span>,<span class="string">"Aug"</span>, <span class="string">"Sep"</span>,<span class="string">"Oct"</span>,<span class="string">"Nov"</span>,<span class="string">"Dec"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">cin</span>.<span class="built_in">peek</span>()) != EOF) &#123; <span class="comment">//取输入流中的第一个字符进行查看</span></span><br><span class="line">         <span class="keyword">int</span> year,month,day;</span><br><span class="line">         <span class="keyword">if</span>(c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) &#123; <span class="comment">//美国日期格式</span></span><br><span class="line">            <span class="built_in">string</span> sMonth;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; sMonth &gt;&gt; day &gt;&gt; year;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">12</span>; ++i)  <span class="comment">//查找月份</span></span><br><span class="line">                   <span class="keyword">if</span>(sMonth == Months[i]) &#123;</span><br><span class="line">                    month = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//中国日期格式</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; year ;</span><br><span class="line">            <span class="built_in">cin</span>.ignore() &gt;&gt; month ; <span class="comment">//用ignore跳过 "2011.12.3"中的'.'</span></span><br><span class="line">            <span class="built_in">cin</span>.ignore() &gt;&gt; day;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>.ignore();   <span class="comment">//跳过行末 '\n'</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; month ;<span class="comment">//设置填充字符'\0'，输出宽度2</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; day &lt;&lt; <span class="string">"-"</span> &lt;&lt; setw(<span class="number">4</span>) &lt;&lt; year &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>istream 还有一个成员函数 istream &amp; putback(char c)，可以将一个字符插入输入流的最前面。对于上面的例题，也可以在用 get() 函数读取一个字符并判断是中式格式还是西式格式时，将刚刚读取的字符再用 putback() 成员函数放回流中，然后再根据判断结果进行不同方式的读入。</p><h2 id="C-处理输入输出错误"><a href="#C-处理输入输出错误" class="headerlink" title="C++处理输入输出错误"></a>C++处理输入输出错误</h2><p>当处理输入输出时，我们必须预计到其中可能发生的错误并给出相应的处理措施。</p><ul><li>当我们输入时，可能会由于人的失误（错误理解了指令、打字错误、允许自家的小猫在键盘上散步等）、文件格式不符、错误估计了情况等原因造成读取失败。</li><li>当我们输出时，如果输出设备不可用、队列满或者发生了故障等，都会导致写入失败。</li></ul><p>发生输入输出错误的可能情况是无限的！但 C++ 将所有可能的情况归结为四类，称为流状态（stream state）。每种流状态都用一个 iostate 类型的标志位来表示。</p><table><thead><tr><th>标志位</th><th>意义</th></tr></thead><tbody><tr><td>badbit</td><td>发生了（或许是物理上的）致命性错误，流将不能继续使用。</td></tr><tr><td>eofbit</td><td>输入结束（文件流的物理结束或用户结束了控制台流输入，例如用户按下了 Ctrl+Z 或 Ctrl+D 组合键。</td></tr><tr><td>failbit</td><td>I/O 操作失败，主要原因是非法数据（例如，试图读取数字时遇到字母）。流可以继续使用，但会设置 failbit 标志。</td></tr><tr><td>goodbit</td><td>一切止常，没有错误发生，也没有输入结束。</td></tr><tr><td>ios_base 类定义了以上四个标志位以及 iostate 类型，但是 ios 类又派生自 ios_base 类，所以可以使用 ios::failbit 代替 ios_base::failbit 以节省输入。</td><td></td></tr></tbody></table><p>一旦流发生错误，对应的标志位就会被设置，我们可以通过下表列出的函数检测流状态。</p><table><thead><tr><th>检测函数</th><th>对应的标志位</th><th>说明</th></tr></thead><tbody><tr><td>good()</td><td>goodbit</td><td>操作成功，没有发生任何错误。</td></tr><tr><td>eof()</td><td>eofbit</td><td>到达输入末尾或文件尾。</td></tr><tr><td>fail()</td><td>failbit</td><td>发生某些意外情况（例如，我们要读入一个数字，却读入了字符 ‘x’）。</td></tr><tr><td>bad()</td><td>badbit</td><td>发生严重的意外（如磁盘读故障）。</td></tr></tbody></table><p>不幸的是，fail() 和 bad() 之间的区别并未被准确定义，程序员对此的观点各种各样。但是，基本的思想很简单：</p><ul><li>如果输入操作遇到一个简单的格式错误，则使流进入 fail() 状态，也就是假定我们（输入操作的用户）可以从错误中恢复。</li><li>如果错误真的非常严重，例如发生了磁盘故障，输入操作会使得流进入 bad() 状态。也就是假定面对这种情况你所能做的很有限，只能退出输入。</li></ul><p>以上观点导致如下逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">cin</span>)&#123;  <span class="comment">//只有输入操作失败，才会跳转到这里</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cin</span>.bad())&#123;  <span class="comment">//流发生严重故障，只能退出函数</span></span><br><span class="line">        error(<span class="string">"cin is bad!"</span>);  <span class="comment">//error是自定义函数，它抛出异常，并给出提示信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cin</span>.eof())&#123;  <span class="comment">//检测是否读取结束</span></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cin</span>.fail())&#123;  <span class="comment">//流遇到了一些意外情况</span></span><br><span class="line">        <span class="built_in">cin</span>.<span class="built_in">clear</span>(); <span class="comment">//清除/恢复流状态</span></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>!cin 可以理解为“cin 不成功”或者“cin 发生了某些错误”或者“ cin 的状态不是 good()”， 这与“操作成功”正好相反，</p><p>注意在处理 fail() 时所使用的 cin.clear()。当流发生错误时，我们可以进行错误恢复。为了恢复错误，我们显式地将流从 fail() 状态转移到其他状态，从而可以继续从中读取字符。clear() 就起到这样的作用——执行 cin.clear() 后，cin 的状态就变为 good()。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面是一个如何使用流状态的例子。假定我们要读取一个整数序列并存入 vector 中，字符*或“文件尾”表示序列结束。Windows 平台按下 Ctrl+Z 组合键，再按下回车键表示到达文件末尾；类Unix系统按下 Ctrl+D 组合键表示到达文件末尾。</p><p>上述功能可通过如下函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 ist 中读入整数到 v 中，直到遇到 eof() 或终结符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_vector</span><span class="params">(istream&amp; ist, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">char</span> terminator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i; ist&gt;&gt;i; ) v.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常情况</span></span><br><span class="line">    <span class="keyword">if</span>(ist.eof()) <span class="keyword">return</span>;  <span class="comment">//发现到了文件尾，正确，返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生严重错误，只能退出函数</span></span><br><span class="line">    <span class="keyword">if</span> (ist.bad())&#123;</span><br><span class="line">        error(<span class="string">"cin is bad!"</span>);  <span class="comment">//error是自定义函数，它抛出异常，并给出提示信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生意外情况</span></span><br><span class="line">    <span class="keyword">if</span> (ist.fail()) &#123;  <span class="comment">//最好清除混乱，然后汇报问题</span></span><br><span class="line">        ist.<span class="built_in">clear</span>();  <span class="comment">//清除流状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//检测下一个字符是否是终结符</span></span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        ist&gt;&gt;c;  <span class="comment">//读入一个符号，希望是终结符</span></span><br><span class="line">        <span class="keyword">if</span>(c != terminator) &#123; <span class="comment">// 非终结符</span></span><br><span class="line">            ist.unget(); <span class="comment">//放回该符号</span></span><br><span class="line">            ist.<span class="built_in">clear</span>(ios_base::failbit);  <span class="comment">//将流状态设置为 fail()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果发生了 fail()，我们尝试检测下一个字符是否是结束符：如果是，那么就完整得读取了数据，使用 clear() 恢复状态就可以；如果不是，我们就没有办法处理了，所以将状态重新设置为 fail()，以期望 fill_vector() 的调用者（上层函数）有能力处理。</p><p>我们通过调用 ist.clear(ios_base::failbit) 来将流状态设置为 fail()。对照简单的cleal()，带参数的用法有些令人迷惑：当 clear() 带参数时，参数中所指出的 iostream 状态位会被置位（进入相应状态)，而未指出的状态位会被复位。通过将流状态设置为 fail()，我们表明遇到了一个格式错误，而不是一个更为严重的问题。</p><p>可以用 unget() 将字符放回 ist，以便 fill_vector() 的调用者可能使用该字符。unget() 函数是 putback() 的简化版本，它依赖于流对象记住最后一个字符是什么，所以在这里可以不用考虑它的用法。</p><p>如果 fill_vector() 的调用者想知道是什么原因终止了输入，那么可以检测流是处于 fail() 还是 eof() 状态。当然也可以捕获 error() 抛出的 runtime_error 异常，但当 istream 处于 bad() 状态时，继续获取数据是不可能的。大多数的调用者无须为此烦恼。因为这意味着，几乎在所有情况下，对于 bad() 状态，我们所能做的只是抛出一个异常。</p><p>简单起见，可以让 istream 帮我们抛出这个异常。</p><blockquote><p>//当 ist 出现问题时拋出异常<br>ist.exceptions(ist.exceptions() | ios_base:: badbit);</p></blockquote><p>这样的写法也许看起来有些奇怪，但结果却很简单，当此语句执行时，如果 ist 处于 bad() 状态，它会抛出一个标准库异常 ios_base::failure。在一个程序中，我们只需要调用 exceptions() 一次。这允许我们简化关联于 ist 的所有输入过程，同时忽略对 bad() 的处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从ist中读入整数到v中，直到遇到eof()或终结符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_vector</span><span class="params">(istream&amp; ist, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">char</span> terminator)</span></span>&#123;</span><br><span class="line">    ist.exceptions(ist.exceptions() | ios_base:: badbit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i; ist&gt;&gt;i; ) v.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ist.eof()) <span class="keyword">return</span>;  <span class="comment">//发现到了文件尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是good()，不是bad()，不是eof()，ist的状态一定是fail()</span></span><br><span class="line">    ist.<span class="built_in">clear</span>();  <span class="comment">//清除流状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    ist&gt;&gt;c;    <span class="comment">//读入一个符号，希望是终结符</span></span><br><span class="line">    <span class="keyword">if</span> (c != terminator) &#123; <span class="comment">//不是终结符号，一定是失败了</span></span><br><span class="line">        ist.unget();    <span class="comment">//也许程序调用者可以使用这个符号</span></span><br><span class="line">        ist.<span class="built_in">clear</span>(ios_base::failbit); <span class="comment">//将流状态设置为 fail()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 ios_base，它是 iostream 的一部分，包含了对常量如 badbit 的定义、异常如 failure 的定义，以及其他一些有用的定义。可以通过::操作符来使用它们，例如 ios_ base::badbit。</p><p>与 istream—样，ostream 也有四个状态：good()、fail()、eof() 和 bad()。不过，对于多数人来说，输出错误要比输入错误少得多，因此通常不对 ostream 进行状态检测。如果程序运行环境中输出设备不可用、队列满或者发生故障的概率很高，我们就可以像处理输入操作那样，在每次输出操作之后都检测其状态。</p><h2 id="C-管理输出缓冲区"><a href="#C-管理输出缓冲区" class="headerlink" title="C++管理输出缓冲区"></a>C++管理输出缓冲区</h2><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下而的代码：</p><blockquote><p>cout &lt;&lt; “abcdefg”;</p></blockquote><p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。</p><p>有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。</p><p>导致缓冲刷新（数据真正写到输出设备或文件）的原因有很多：</p><ul><li>程序正常结束，作为 main() 函数的 return 操作的一部分，缓冲刷新被执行。</li><li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li><li>我们可以使用操纵符如 endl 来显式刷新缓冲区。</li><li>在每个输出操作之后，我们可以用操作符 unitbuf 设置流的内部状态，来清空缓冲区。默认情况下，对 cerr 是设置 unitbuf 的，因此写到 cerr 的内容都是立即刷新的。</li><li>一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin 和 cerr 都关联到 cout。因此，读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新。<h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3>我们已经使用过操作符 endl，它完成换行并刷新缓冲区的工作。IO 库中还有两个类似的操纵符：</li><li>flush 和 ends。flush 刷新缓冲区，但不输出任何额外的字符；</li><li>ends向缓冲区插入一个空字符，然后刷新缓冲区。</li></ul><blockquote><p>值得一提得是，cout 所属 ostream 类中还提供有 flush() 成员方法，它和 flush 操纵符的功能完全一样，仅在使用方法上（ cout.flush() ）有区别。</p></blockquote><p>请看下面的例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出hi和一个换行，然后刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; <span class="built_in">flush</span>;  <span class="comment">//输出hi，然后刷新缓冲区，不附加任何额外字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; ends;  <span class="comment">//输出hi和一个空字符，然后刷新缓冲区</span></span><br></pre></td></tr></table></figure><h3 id="unitbuf-操作符"><a href="#unitbuf-操作符" class="headerlink" title="unitbuf 操作符"></a>unitbuf 操作符</h3><p>如果想在每次输出操作后都刷新缓冲区，我们可以使用 unitbuf 操作符，它告诉流在接下来的每次写操作之后都进行一次 flush 操作。而 nounitbuf 操作符则重置流， 使其恢复使用正常的系统管理的缓冲区刷新机制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;  <span class="comment">//所有输出操作后都会立即刷新缓冲区</span></span><br><span class="line"><span class="comment">//任何输出都立即刷新，无缓冲</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;  <span class="comment">//回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure><p><strong>警告：如果程序崩溃，输出缓冲区不会被刷新</strong><br>如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。</p><p>当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。</p><h3 id="关联输入和输出流"><a href="#关联输入和输出流" class="headerlink" title="关联输入和输出流"></a>关联输入和输出流</h3><p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将 cout 和 cin 关联在一起，因此下面语句：</p><blockquote><p>cin &gt;&gt; ival;</p></blockquote><p>导致 cout 的缓冲区被刷新。</p><p>交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。</p><p>tie() 函数可以用来绑定输出流，它有两个重载的版本：</p><blockquote><p>ostream* tie ( ) const;  //返回指向绑定的输出流的指针。<br>ostream* tie ( ostream* os );  //将 os 指向的输出流绑定的该对象上，并返回上一个绑定的输出流指针。</p></blockquote><p>第一个版本不带参数，返冋指向出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。</p><p>tie() 的第二个版本接受一个指向 ostream 的指针，将自己关联到此 ostream，即，x.tie(&amp;o) 将流 x 关联到输出流 o。</p><p>我们既可以将一个 istream 对象关联到另一个 ostream，也可以将一个 ostream 关联到另一个 ostream：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cout</span>);  <span class="comment">//仅仅是用来展示，标准库已经将 cin 和 cout 关联在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//old_tie 指向当前关联到 cin 的流（如果有的话）</span></span><br><span class="line">ostream *old_tie = <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);  <span class="comment">// cin 不再与其他流关联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 cin 与 cerr 关联，这不是一个好主意，因为 cin 应该关联到 cout</span></span><br><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cerr</span>);  <span class="comment">//读取 cin 会刷新 cerr 而不是 cout</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.tie(old_tie);  <span class="comment">//重建 cin 和 cout 间的正常关联</span></span><br></pre></td></tr></table></figure><p>在这段代码中，为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了 tie()。为了彻底解开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流， 但多个流可以同时关联到同一个ostream。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 输入输出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为啥重载运算符要返回自身引用</title>
      <link href="/2020/05/10/20200510/"/>
      <url>/2020/05/10/20200510/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么重载运算符一定要返回自身引用"><a href="#为什么重载运算符一定要返回自身引用" class="headerlink" title="为什么重载运算符一定要返回自身引用"></a>为什么重载运算符一定要返回自身引用</h3><p>结论:</p><ul><li>可以实现和cout一样连续调用</li><li>避免了一次拷贝构造和析构，提升程序性能</li></ul><h3 id="返回自身类型是为了实现连续赋值"><a href="#返回自身类型是为了实现连续赋值" class="headerlink" title="返回自身类型是为了实现连续赋值"></a>返回自身类型是为了实现连续赋值</h3><p>首先给出一个Number类为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;<span class="comment">//用于计算调用了几次构造函数，包括拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Number(<span class="keyword">int</span> n=<span class="number">0</span>):num(n)<span class="comment">//默认参数为零，可以同时当默认构造函数使用</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;<span class="comment">//每次调用一次加1</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Count of constructed class Number: "</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Number(<span class="keyword">const</span> Number&amp; other)<span class="comment">//自定义拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        num=other.num;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Count of constructed(Copy) class Number:"</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Number()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructor has been called"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"num的值:"</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Number::count=<span class="number">0</span>;<span class="comment">//count初始值设为0</span></span><br></pre></td></tr></table></figure><p>1) 首先现在类里添加一个重载 = 的方法，不过其返回类型为void:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Number&amp; other)<span class="comment">//只是改了函数名，将“equal”改为“operator=”</span></span><br><span class="line">&#123;</span><br><span class="line">num=other.num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Number <span class="title">n1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Number n2;</span><br><span class="line"> </span><br><span class="line">    n2=n1;</span><br><span class="line">    n2.printNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：       </p><blockquote><p>Count of constructed class Number: 1<br>Count of constructed class Number: 2<br>num的值:1<br>Destructor has been called<br>Destructor has been called   </p></blockquote><p>2) 赋值操作符调用成功,那么问题来了，既然void就可以，为什么开头的重载函数要返回Number类型呢？<br>如果我们回顾一下int类型的赋值我们可以发现它是可以连续赋值的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i1=<span class="number">2</span>,i2=<span class="number">2</span>,i3=<span class="number">3</span>;</span><br><span class="line">    i1=i2=i3;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>3</p></blockquote><p>此时可以发现（i1=i2）它是有一个返回类型的，返回的类型就是他本身的类型，所以可以实现连续赋值.而我们写的Numer类就不能实现该连续赋值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Number n1(1),n2(2),n3(3);</span><br><span class="line">    n1=n2=n3;<span class="comment">//如果我们这么写，编译器会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若改为返回自身类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Number <span class="keyword">operator</span>=(<span class="keyword">const</span> Number&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">num=other.num;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Number n1(1),n2(2),n3(3);</span><br><span class="line">    n1=n2=n3;</span><br><span class="line">    n1.printNumber();<span class="comment">// 运行结果值为3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现一旦改为返回自身类型就可以实现连续赋值了<br>所以返回自身类型，是为了该操作符能连续使用。</p><h3 id="返回引用，提升性能"><a href="#返回引用，提升性能" class="headerlink" title="返回引用，提升性能"></a>返回引用，提升性能</h3><p>若同时调用一下文章开头返回Number引用的重载运算符和上面写的不带引用的重载运算符，用同样的代码来测试一下有什么区别。测试代码均为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Number n1(1),n2(2);</span><br><span class="line">    n1=n2;</span><br><span class="line">    n1.printNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不带引用的运行结果：</p><blockquote><p>Count of constructed class Number: 1<br>Count of constructed class Number: 2<br>Count of constructed(Copy) class Number:3<br>Destructor has been called<br>num的值:2<br>Destructor has been called<br>Destructor has been called </p></blockquote><p>而带引用的运算结果为：</p><blockquote><p>Count of constructed class Number: 1<br>Count of constructed class Number: 2<br>num的值:2<br>Destructor has been called<br>Destructor has been called </p></blockquote><p>可以发现带引用的运行结果减少一次拷贝构造和析构。可为什么会减少呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number n1(1),n2(2);</span><br><span class="line">   n1=n2;</span><br><span class="line">   n1.printNumber();</span><br></pre></td></tr></table></figure><p>因为上面运行代码中，带引用的话，只新建了n1和n2两个对象，当n1=n2的时候，因为返回的n1的引用，所以返回还是n1这个对象。即（n1=n2）的值，还是n1，只不过n1里面的变量值变了。</p><p>而不带引用时，在赋值重载函数中，return *this 的时候，用n1拷贝构造了一个临时对象，然后因为没有左值接受这个临时变量，所以又被析构了。即（n1=n2）的值是一个临时变量，刚新建，就被析构了。所以多了一个拷贝构造函数和析构函数，因此返回引用类型会带来了一点性能的提升。</p><p>当返回值时，函数返回值时会产生一个临时变量作为函数返回值的副本，并调用复制构造函数将 *this 传给这个临时变量，并且赋值得到的是一个右值，右值是不能继续赋值的，而返回引用时，引用就是obj对象本身，赋值得到一个左值，是可以继续赋值的，其原因是这是为了支持连续的=号操作，如：A a,b,c  .调用(a=b)=c,这种情况下就要要求重载操作符=号必须返回一个 *this 的引用，这样a=b才能得到一个更新后的a,再用c对其赋值才能作用到更新的a身上，如果不返回 *this的引用，将无法完成第二次用c的那个赋值,因为返回的是对象（一个临时对象，a的一个拷贝），不是引用，所以此时 a 不在后面的‘()=c’的操作中，而是c对一个临时对象赋值，所以a的内容保持不变（等于a）。调用成员函数时*this指向该对象本身。</p><p>参考来源：<a href="https://blog.csdn.net/weixin_43515966/article/details/93746576?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">csdn</a></p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象进阶</title>
      <link href="/2020/05/10/oomaster/"/>
      <url>/2020/05/10/oomaster/</url>
      
        <content type="html"><![CDATA[<h2 id="C-拷贝构造函数（复制构造函数）"><a href="#C-拷贝构造函数（复制构造函数）" class="headerlink" title="C++拷贝构造函数（复制构造函数）"></a>C++拷贝构造函数（复制构造函数）</h2><p>拷贝和复制是一个意思，对应的英文单词都是copy。<strong>对于计算机来说，拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据</strong>。例如，将 Word 文档拷贝到U盘去复印店打印，将 D 盘的图片拷贝到桌面以方便浏览，将重要的文件上传到百度网盘以防止丢失等，都是「创建一份新数据」的意思。</p><p>在 C++ 中，拷贝并没有脱离它本来的含义，只是将这个含义进行了“特化”，是指用已经存在的对象创建出一个新的对象。从本质上讲，对象也是一份数据，因为它会占用内存。</p><p>严格来说，对象的创建包括两个阶段，首先要分配内存空间，然后再进行初始化：</p><ul><li>分配内存很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。这个时候的内存还比较“原始”，没有被“教化”，它所包含的数据一般是零值或者随机值，没有实际的意义。</li><li>初始化就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，初始化就是调用构造函数。</li></ul><p><strong>很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存</strong>。</p><p>那么，如何用拷贝的方式来初始化一个对象呢？其实这样的例子比比皆是，string 类就是一个典型的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s3 = s1;</span><br><span class="line">    <span class="built_in">string</span> s4 = s1 + <span class="string">" "</span> + s2;</span><br><span class="line">    func(s1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s3&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a><br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a><br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a><br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a><br><a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a> <a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a>    </p></blockquote><p>s1、s2、s3、s4 以及 func() 的形参 str，都是使用拷贝的方式来初始化的。<br>对于 s1，表面上看起来是将一个字符串直接赋值给了 s1，实际上在内部进行了类型转换，将 const char * 类型转换为 string 类型后才赋值的,s4 也是类似的道理。</p><p>对于 s1、s2、s3、s4，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。</p><p>对于 func() 的形参 str，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用 func() 时，才会将其它对象的数据拷贝给 str 以完成初始化。</p><p>当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是<strong>拷贝构造函数（Copy Constructor）。</strong></p><p>下面的例子演示了拷贝构造函数的定义和使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name = <span class="string">""</span>, <span class="keyword">int</span> age = <span class="number">0</span>, <span class="keyword">float</span> score = <span class="number">0.0f</span>);  <span class="comment">//普通构造函数</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student &amp;stu);  <span class="comment">//拷贝构造函数（声明）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">float</span> score): m_name(name), m_age(age), m_score(score)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数（定义）</span></span><br><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">"的年龄是"</span>&lt;&lt;m_age&lt;&lt;<span class="string">"，成绩是"</span>&lt;&lt;m_score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    Student stu2 = stu1;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    stu1.<span class="built_in">display</span>();</span><br><span class="line">    stu2.<span class="built_in">display</span>();</span><br><span class="line">    stu3.<span class="built_in">display</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Copy constructor was called.<br>Copy constructor was called.<br>小明的年龄是16，成绩是90.5<br>小明的年龄是16，成绩是90.5<br>小明的年龄是16，成绩是90.5   </p></blockquote><p>第 8 行是拷贝构造函数的声明，第 20 行是拷贝构造函数的定义。拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。</p><p><strong>1) 为什么必须是当前类的引用呢？</strong><br>如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p><p>只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。</p><p><strong>2) 为什么是 const 引用呢？</strong></p><p>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。</p><p>另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。</p><p>以上面的 Student 类为例，将 const 去掉后，拷贝构造函数的原型变为：</p><blockquote><p>Student::Student(Student &amp;stu);</p></blockquote><p>此时，下面的代码就会发生错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Student <span class="title">stu1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">Student stu2 = stu1;</span><br><span class="line"><span class="function">Student <span class="title">stu3</span><span class="params">(stu1)</span></span>;</span><br></pre></td></tr></table></figure><p>stu1 是 const 类型，在初始化 stu2、stu3 时，编译器希望调用<strong>Student::Student(const Student &amp;stu)</strong>，但是这个函数却不存在，又不能将 const Student 类型转换为 Student 类型去调用<strong>Student::Student(Student &amp;stu)</strong>，所以最终调用失败了。</p><p>当然，你也可以再添加一个参数为 const 引用的拷贝构造函数，这样就不会出错了。换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 const 引用，另一个函数的参数为非 const 引用。</p><h3 id="默认拷贝构造函数"><a href="#默认拷贝构造函数" class="headerlink" title="默认拷贝构造函数"></a>默认拷贝构造函数</h3><p>在前面的教程中，我们还没有讲解拷贝构造函数，但是却已经在使用拷贝的方式创建对象了，并且也没有引发什么错误。这是因为，如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面 Student 类的拷贝构造函数非常类似。</p><p>对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p><h2 id="C-深拷贝和浅拷贝（深复制和浅复制）"><a href="#C-深拷贝和浅拷贝（深复制和浅复制）" class="headerlink" title="C++深拷贝和浅拷贝（深复制和浅复制）"></a>C++深拷贝和浅拷贝（深复制和浅复制）</h2><p>对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(): m_a(<span class="number">0</span>), m_b(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">    Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = a;  <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    Base obj2 = obj1;  <span class="comment">//拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b 和 obj2 都是以拷贝的方式初始化的，具体来说，就是将 a 和 obj1 所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，<strong>这种默认的拷贝行为就是浅拷贝</strong>，<strong>这和调用 memcpy() 函数的效果非常类似</strong>。</p><p>对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p><p>下面我们通过一个具体的例子来说明显式定义拷贝构造函数的必要性。我们知道，有些较老的编译器不支持变长数组，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    <span class="comment">//因为返回类型是int型的引用，所以说是可写入处理的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    Array arr2 = arr1;</span><br><span class="line">    arr2[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">29</span>;</span><br><span class="line">   </span><br><span class="line">    printArray(arr1);</span><br><span class="line">    printArray(arr2);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">&gt;运行结果：   </span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>    </span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>  </span><br><span class="line"></span><br><span class="line">本例中我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了 arr2 的数据，就没有影响 arr1。</span><br><span class="line"></span><br><span class="line">**这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。**</span><br><span class="line"></span><br><span class="line">深拷贝的例子比比皆是，除了上面的变长数组类，标准模板库（STL）中的 <span class="built_in">string</span>、<span class="built_in">vector</span>、<span class="built_in">stack</span>、<span class="built_in">set</span>、<span class="built_in">map</span> 等也都必须使用深拷贝。</span><br><span class="line"></span><br><span class="line">果希望亲眼目睹不使用深拷贝的后果，可以将上例中的拷贝构造函数删除，那么运行结果将变为：</span><br><span class="line"></span><br><span class="line">&gt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>  </span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line">可以发现，更改 arr2 的数据也影响到了 arr1。这是因为，在创建 arr2 对象时，默认拷贝构造函数将 arr1.m_p 直接赋值给了 arr2.m_p，**导致 arr2.m_p 和 arr1.m_p 指向了同一块内存，所以会相互影响。**</span><br><span class="line"></span><br><span class="line">另外需要注意的是，printArray() 函数的形参为引用类型，这样做能够避免在传参时调用拷贝构造函数；又因为 printArray() 函数不会修改任何数组元素，所以我们添加了 <span class="keyword">const</span> 限制，以使得语义更加明确。</span><br><span class="line"></span><br><span class="line">### 到底是浅拷贝还是深拷贝</span><br><span class="line">如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。</span><br><span class="line"></span><br><span class="line">另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等，请看下面的例子：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  //在Linux和Mac下要换成 unistd.h 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>);</span><br><span class="line">    Base(<span class="keyword">const</span> Base &amp;obj);  <span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">time_t</span> <span class="title">getTime</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_time; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">    <span class="keyword">time_t</span> m_time;  <span class="comment">//对象创建时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_count;  <span class="comment">//创建过的对象的数目</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">int</span> a, <span class="keyword">int</span> b): m_a(a), m_b(b)&#123;</span><br><span class="line">    m_count++;</span><br><span class="line">    m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::Base(<span class="keyword">const</span> Base &amp;obj)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_a = obj.m_a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_b = obj.m_b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_count++;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_time = time((<span class="keyword">time_t</span>*)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj1: count = "</span>&lt;&lt;obj1.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj1.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    Sleep(<span class="number">3000</span>);  <span class="comment">//在Linux和Mac下要写作 sleep(3);</span></span><br><span class="line">   </span><br><span class="line">    Base obj2 = obj1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"obj2: count = "</span>&lt;&lt;obj2.getCount()&lt;&lt;<span class="string">", time = "</span>&lt;&lt;obj2.getTime()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>obj1: count = 1, time = 1488344372<br>obj2: count = 2, time = 1488344375    </p></blockquote><p>运行程序，先输出第一行结果，等待 3 秒后再输出第二行结果。Base 类中的 m_time 和 m_count 分别记录了对象的创建时间和创建数目，它们在不同的对象中有不同的值，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。</p><h2 id="C-重载-（赋值运算符）"><a href="#C-重载-（赋值运算符）" class="headerlink" title="C++重载=（赋值运算符）"></a>C++重载=（赋值运算符）</h2><p>初始化和赋值的区别：<br>在定义的同时进行赋值叫做<strong>初始化</strong>（Initialization），定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做<strong>赋值</strong>（Assignment）。<strong>初始化只能有一次，赋值可以有多次。</strong></p><p>当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符。</p><p><strong>即使我们没有显式的重载赋值运算符，编译器也会以默认地方式重载它。默认重载的赋值运算符功能很简单，就是将原有对象的所有成员变量一一赋值给新对象，这和默认拷贝构造函数的功能类似。</strong></p><p>对于简单的类，默认的赋值运算符一般就够用了，我们也没有必要再显式地重载它。但是当类持有其它资源时，例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就不能处理了，我们必须显式地重载它，这样才能将原有对象的所有数据都赋值给新对象。</p><p>仍然以 Array 类为例，该类拥有一个指针成员，指向动态分配的内存。为了让 Array 类的对象之间能够正确地赋值，我们必须重载赋值运算符。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> len);</span><br><span class="line">    Array(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    Array &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;arr);  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> len): m_len(len)&#123;</span><br><span class="line">    m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line">Array &amp;Array::<span class="keyword">operator</span>=(<span class="keyword">const</span> Array &amp;arr)&#123;  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span> != &amp;arr)&#123;  <span class="comment">//判断是否是给自己赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_p);  <span class="comment">//释放原来的内存</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_p = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">        <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">const</span> Array &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == len<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        arr1[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(arr1);</span><br><span class="line">   </span><br><span class="line">    <span class="function">Array <span class="title">arr2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        arr2[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    printArray(arr2);</span><br><span class="line">    arr2 = arr1;  <span class="comment">//调用operator=()</span></span><br><span class="line">    printArray(arr2);</span><br><span class="line">    arr2[<span class="number">3</span>] = <span class="number">234</span>;  <span class="comment">//修改arr1的数据不会影响arr2</span></span><br><span class="line">    arr2[<span class="number">7</span>] = <span class="number">920</span>;</span><br><span class="line">    printArray(arr1);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br>0, 1, 2, 3, 4<br>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br>0, 1, 2, 3, 4, 5, 6, 7, 8, 9   </p></blockquote><p>将 arr1 赋值给 arr2 后，修改 arr2 的数据不会影响 arr1。如果把 operator=() 注释掉，那么运行结果将变为：</p><blockquote><p>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br>0, 1, 2, 3, 4<br>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br>0, 1, 2, 234, 4, 5, 6, 920, 8, 9  </p></blockquote><blockquote><p>去掉operator=()后，由于 m_p 指向的堆内存会被 free() 两次，(析构函数)所以还会导致内存错误。</p></blockquote><p>1) operator=() 的返回值类型为Array &amp;，这样不但能够避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的。下面的语句就是连续赋值：</p><blockquote><p>arr4 = arr3 = arr2 = arr1;</p></blockquote><p>2) if( this != &amp;arr)语句的作用是「判断是否是给同一个对象赋值」：如果是，那就什么也不做；如果不是，那就将原有对象的所有成员变量一一赋值给新对象，并为新对象重新分配内存。下面的语句就是给同一个对象赋值：</p><blockquote><p>arr1 = arr1;<br>arr2 = arr2;</p></blockquote><p>3) return <em>this表示返回当前对象（新对象），而且是一个*</em>临时对象**。</p><p>4) operator=() 的形参类型为const Array &amp;，这样不但能够避免在传参时调用拷贝构造函数，还能够同时接收 const 类型和非 const 类型的实参。</p><p>5) 赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是其它参数必须给出默认值，例如：</p><blockquote><p>Array &amp; operator=(const Array &amp;arr, int a = 100); </p></blockquote><h2 id="C-转换构造函数：将其它类型转换为当前类的类型"><a href="#C-转换构造函数：将其它类型转换为当前类的类型" class="headerlink" title="C++转换构造函数：将其它类型转换为当前类的类型"></a>C++转换构造函数：将其它类型转换为当前类的类型</h2><p>在 C/C++ 中，不同的数据类型之间可以相互转换。无需用户指明如何转换的称为自动类型转换（隐式类型转换），需要用户显式地指明如何转换的称为强制类型转换。</p><p>自动类型转换示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">a = <span class="number">7.5</span> + a;</span><br></pre></td></tr></table></figure><p>编译器对 7.5 是作为 double 类型处理的，在求解表达式时，先将 a 转换为 double 类型，然后与 7.5 相加，得到和为 13.5。在向整型变量 a 赋值时，将 13.5 转换为整数 13，然后赋给 a。整个过程中，我们并没有告诉编译器如何去做，编译器使用内置的规则完成数据类型的转换。</p><p>强制类型转换示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;n;</span><br><span class="line"><span class="keyword">float</span> *p2 = (<span class="keyword">float</span>*)p1;</span><br></pre></td></tr></table></figure><p>p1 是int *类型，它指向的内存里面保存的是整数，p2 是float *类型，将 p1 赋值给 p2 后，p2 也指向了这块内存，并把这块内存中的数据作为小数处理。我们知道，整数和小数的存储格式大相径庭，将整数作为小数处理非常荒诞，可能会引发莫名其妙的错误，所以编译器默认不允许将 p1 赋值给 p2。但是，使用强制类型转换后，编译器就认为我们知道这种风险的存在，并进行了适当的权衡，所以最终还是允许了这种行为。</p><p>不管是自动类型转换还是强制类型转换，前提必须是编译器知道如何转换，例如，将小数转换为整数会抹掉小数点后面的数字，将int *转换为float *只是简单地复制指针的值，这些规则都是编译器内置的，我们并没有告诉编译器。</p><p>但如果编译器不知道转换规则就不能转换，使用强制类型也无用，如下例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    a = (Complex)<span class="number">25.5</span>;  <span class="comment">//错误，转换失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>25.5 是实数，a 是复数，将 25.5 赋值给 a 后，我们期望 a 的实部变为 25.5，而虚部为 0。但是，编译器并不知道这个转换规则，这超出了编译器的处理能力，所以转换失败，即使加上强制类型转换也无用。</p><p>不过 C++ 允许我们自定义类型转换规则，用户可以将其它类型转换为当前类类型，也可以将当前类类型转换为其它类型。这种自定义的类型转换规则只能以类的成员函数的形式出现，换句话说，这种转换规则只适用于类。</p><h3 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h3><p><strong>将其它类型转换为当前类类型需要借助转换构造函数</strong>（Conversion constructor）。转换构造函数也是一种构造函数，它遵循构造函数的一般规则。<strong>转换构造函数只有一个参数</strong>。</p><p>仍然以 Complex 类为例，我们为它添加转换构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real): m_real(real), m_imag(<span class="number">0.0</span>)&#123; &#125;  <span class="comment">//转换构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    a = <span class="number">25.5</span>;  <span class="comment">//调用转换构造函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>10 + 20i<br>25.5 + 0i</p></blockquote><p>Complex(double real); 就是转换构造函数，它的作用是将 double 类型的参数 real 转换成 Complex 类的对象，并将 real 作为复数的实部，将 0 作为复数的虚部。这样一来，a = 25.5; 整体上的效果相当于：</p><blockquote><p>a.Complex(25.5);</p></blockquote><p>将赋值的过程转换成了函数调用的过程。</p><p>在进行数学运算、赋值、拷贝等操作时，如果遇到类型不兼容、需要将 double 类型转换为 Complex 类型时，编译器会检索当前的类是否定义了转换构造函数，如果没有定义的话就转换失败，如果定义了的话就调用转换构造函数。</p><p>转换构造函数也是构造函数的一种，它除了可以用来将其它类型转换为当前类类型，还可以用来初始化对象，这是构造函数本来的意义。下面创建对象的方式是正确的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">26.4</span>)</span></span>;  <span class="comment">//创建具名对象</span></span><br><span class="line">Complex c2 = <span class="number">240.3</span>;  <span class="comment">//以拷贝的方式初始化对象</span></span><br><span class="line">Complex(<span class="number">15.9</span>);  <span class="comment">//创建匿名对象</span></span><br><span class="line">c1 = Complex(<span class="number">46.9</span>);  <span class="comment">//创建一个匿名对象并将它赋值给 c1</span></span><br></pre></td></tr></table></figure><p><strong>在以拷贝的方式初始化对象时，编译器先调用转换构造函数，将 240.3 转换为 Complex 类型（创建一个 Complex 类的匿名对象），然后再拷贝给 c2。</strong></p><p>如果已经对+运算符进行了重载，使之能进行两个 Complex 类对象的相加，那么下面的语句也是正确的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">15.6</span>, <span class="number">89.9</span>)</span></span>;</span><br><span class="line">Complex c2;</span><br><span class="line">c2 = c1 + <span class="number">29.6</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>在进行加法运算符时，编译器先将 29.6 转换为 Complex 类型（创建一个 Complex 类的匿名对象）再相加。</p><p>需要注意的是，<strong>为了获得目标类型，编译器会“不择手段”，会综合使用内置的转换规则和用户自定义的转换规则，并且会进行多级类型转换</strong>，例如：</p><ul><li>编译器会根据内置规则先将 int 转换为 double，再根据用户自定义规则将 double 转换为 Complex（int –&gt; double –&gt; Complex）；</li><li>编译器会根据内置规则先将 char 转换为 int，再将 int 转换为 double，最后根据用户自定义规则将 double 转换为 Complex（char –&gt; int –&gt; double –&gt; Complex）。</li></ul><p>从本例看，只要一个类型能转换为 double 类型，就能转换为 Complex 类型。请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Complex c1 = <span class="number">100</span>;  <span class="comment">//int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c1 = <span class="string">'A'</span>;  <span class="comment">//char --&gt; int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c1 = <span class="literal">true</span>;  <span class="comment">//bool --&gt; int --&gt; double --&gt; Complex</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">25.8</span>, <span class="number">0.7</span>)</span></span>;</span><br><span class="line">    <span class="comment">//假设已经重载了+运算符</span></span><br><span class="line">    c1 = c2 + <span class="string">'H'</span> + <span class="literal">true</span> + <span class="number">15</span>;  <span class="comment">//将char、bool、int都转换为Complex类型再运算</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>100 + 0i<br>65 + 0i<br>1 + 0i<br>113.8 + 0.7i</p></blockquote><h3 id="构造函数-综合"><a href="#构造函数-综合" class="headerlink" title="构造函数 综合"></a>构造函数 综合</h3><p>构造函数的本意是在创建对象的时候初始化对象，编译器会根据传递的实参来匹配不同的（重载的）构造函数。回顾一下以前的章节，到目前为止我们已经学习了以下几种构造函数。</p><p>1) 默认构造函数。就是编译器自动生成的构造函数。以 Complex 类为例，它的原型为：</p><blockquote><p>Complex();  //没有参数</p></blockquote><p>2) 普通构造函数。就是用户自定义的构造函数。以 Complex 类为例，它的原型为：</p><blockquote><p>Complex(double real, double imag);  //两个参数</p></blockquote><p>3) 拷贝构造函数。在以拷贝的方式初始化对象时调用。以 Complex 类为例，它的原型为：</p><blockquote><p>Complex(const Complex &amp;c);</p></blockquote><p>4) 转换构造函数。将其它类型转换为当前类类型时调用。以 Complex 为例，它的原型为：</p><blockquote><p>Complex(double real);</p></blockquote><p>不管哪一种构造函数，都能够用来初始化对象，这是构造函数的本意。假设 Complex 类定义了以上所有的构造函数，那么下面创建对象的方式都是正确的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">()</span></span>;  <span class="comment">//调用Complex()</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;  <span class="comment">//调用Complex(double real, double imag)</span></span><br><span class="line"><span class="function">Complex <span class="title">c3</span><span class="params">(c2)</span></span>;  <span class="comment">//调用Complex(const Complex &amp;c)</span></span><br><span class="line"><span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">25.7</span>)</span></span>;  <span class="comment">//调用Complex(double real)</span></span><br></pre></td></tr></table></figure><p>这些代码都体现了构造函数的本意——在创建对象时初始化对象。</p><p>除了在创建对象时初始化对象，其他情况下也会调用构造函数，例如，以拷贝的的方式初始化对象时会调用拷贝构造函数，将其它类型转换为当前类类型时会调用转换构造函数。这些在其他情况下调用的构造函数，就成了特殊的构造函数了。特殊的构造函数并不一定能体现出构造函数的本意。</p><h3 id="对-Complex-类的进一步精简"><a href="#对-Complex-类的进一步精简" class="headerlink" title="对 Complex 类的进一步精简"></a>对 Complex 类的进一步精简</h3><p>上面的 Complex 类中我们定义了三个构造函数，其中包括两个普通的构造函数和一个转换构造函数。其实，借助<strong>函数的默认参数</strong>，我们可以将这三个构造函数简化为一个，请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);  <span class="comment">//友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;  <span class="comment">//向构造函数传递 2 个实参，不使用默认参数</span></span><br><span class="line">    <span class="function">Complex <span class="title">b</span><span class="params">(<span class="number">89.5</span>)</span></span>;  <span class="comment">//向构造函数传递 1 个实参，使用 1 个默认参数</span></span><br><span class="line">    Complex c;  <span class="comment">//不向构造函数传递实参，使用全部默认参数</span></span><br><span class="line">    a = <span class="number">25.5</span>;  <span class="comment">//调用转换构造函数（向构造函数传递 1 个实参，使用 1 个默认参数）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精简后的构造函数包含了两个默认参数，在调用它时可以省略部分或者全部实参，也就是可以向它传递 0 个、1 个、2 个实参。转换构造函数就是包含了一个参数的构造函数，恰好能够和其他两个普通的构造函数“融合”在一起。</p><h2 id="C-类型转换函数：将当前类的类型转换为其它类型"><a href="#C-类型转换函数：将当前类的类型转换为其它类型" class="headerlink" title="C++类型转换函数：将当前类的类型转换为其它类型"></a>C++类型转换函数：将当前类的类型转换为其它类型</h2><p>C++ 提供了类型转换函数（Type conversion function）来将当前类类型转换为其它类型（例如将 Complex 类型转换为 double 类型）。类型转换函数的作用就是将当前类类型转换为其它类型，它只能以成员函数的形式出现，也就是只能出现在类中。</p><p>类型转换函数的语法格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>operator 是 C++ 关键字，type 是要转换的目标类型，data 是要返回的 type 类型的数据。</p><p>因为要转换的目标类型是 type，所以返回值 data 也必须是 type 类型。既然已经知道了要返回 type 类型的数据，所以没有必要再像普通函数一样明确地给出返回值类型。这样做导致的结果是：类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。</p><p>类型转换函数也没有参数，因为要将当前类的对象转换为其它类型，所以参数不言而喻。实际上编译器会把当前对象的地址赋值给 this 指针，这样在函数体内就可以操作当前对象了。</p><p>【示例】为 Complex 类添加类型转换函数，使得 Complex 类型能够转换为 double 类型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">"i"</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> f = c1;  <span class="comment">//相当于 double f = Complex::operator double(&amp;c1);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"f = "</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    f = <span class="number">12.5</span> + c1 + <span class="number">6</span>;  <span class="comment">//相当于 f = 12.5 + Complex::operator double(&amp;c1) + 6;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"f = "</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = Complex(<span class="number">43.2</span>, <span class="number">9.3</span>);  <span class="comment">//先转换为 double，再转换为 int</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"n = "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>f = 24.6<br>f = 43.1<br>n = 43</p></blockquote><h3 id="关于类型转换函数的说明"><a href="#关于类型转换函数的说明" class="headerlink" title="关于类型转换函数的说明"></a>关于类型转换函数的说明</h3><p>1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。</p><p>2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。</p><p>3) 类型转换函数可以被继承，可以是虚函数。</p><p>4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。以 Complex 类为例，假设它有两个类型转换函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//转换为double类型</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">int</span>)m_real; &#125;  <span class="comment">//转换为int类型</span></span><br></pre></td></tr></table></figure><p>那么下面的写法就会引发二义性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">12.5</span> + c1;</span><br></pre></td></tr></table></figure><p>编译器可以调用 operator double() 将 c1 转换为 double 类型，也可以调用 operator int() 将 c1 转换为 int 类型，这两种类型都可以跟 12.5 进行加法运算，并且从 Complex 转换为 double 与从 Complex 转化为 int 是平级的，没有谁的优先级更高，所以这个时候编译器就不知道该调用哪个函数了，干脆抛出一个二义性错误，让用户解决。</p><h2 id="拷贝控制操作（三-五法则）"><a href="#拷贝控制操作（三-五法则）" class="headerlink" title="拷贝控制操作（三/五法则）"></a>拷贝控制操作（三/五法则）</h2><p>当定义一个类时，我们显式地或隐式地指定了此类型的对象在<strong>拷贝</strong>、<strong>赋值</strong>和<strong>销毁</strong>时做什么；<br>一个类通过定义三种特殊的成员函数来控制这些操作，分别是<strong>拷贝构造函数</strong>、<strong>赋值运算符</strong>和<strong>析构函数</strong>；</p><ul><li>拷贝构造函数定义了当用同类型的另一个对象初始化新对象时做什么；</li><li>赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么；</li><li>析构函数定义了此类型的对象销毁时做什么；</li></ul><p>我们将这些操作称为<strong>拷贝控制操作</strong>；</p><p>由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“<strong>C++三法则</strong>”；<br>在较新的 C++11 标准中，为了支持移动语义，又增加了<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，这样共有五个特殊的成员函数，所以又称为“<strong>C++五法则</strong>”；</p><p>也就是说，“三法则”是针对较旧的 C++89 标准说的，“五法则”是针对较新的 C++11 标准说的；为了统一称呼，后来人们干把它叫做“<strong>C++ 三/五法则</strong>”；</p><p>如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义默认的操作，因此很多类会忽略这些拷贝控制操作；<br>但是，对于一些持有其他资源（例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等）的类来说，依赖这些默认的操作会导致灾难，我们必须显式的定义这些操作；</p><p>C++ 并不要求我们定义所有的这些操作，你可以只定义其中的一个或两个；<br>但是，这些操作通常应该被看做一个整体，只需要定义其中一个操作，而不需要定义其他操作的情况很少见；</p><p><strong>需要析构函数的类也需要拷贝和赋值操作</strong><br>当我们决定是否要为一个类显式地定义拷贝构造函数和赋值运算符时，一个基本原则是首先确定这个类是否需要一个析构函数；<br>通常，对析构函数的需求要比拷贝构造函数和赋值运算符的需求更加明显；</p><p>如果一个类需要定义析构函数，那么几乎可以肯定这个类也需要一个拷贝构造函数和一个赋值运算符；</p><p><strong>需要拷贝操作的类也需要赋值操作，反之亦然</strong><br>虽然很多类需要定义所有（或是不需要定义任何）拷贝控制成员，但某些类所要完成的工作，只需要拷贝或者赋值操作，不需要析构操作；</p><p>如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个赋值运算符；反之亦然；<br>然而，无论需要拷贝构造函数还是需要复制运算符，都不必然意味着也需要析构函数；</p><h2 id="转换构造函数和类型转换函数"><a href="#转换构造函数和类型转换函数" class="headerlink" title="转换构造函数和类型转换函数"></a>转换构造函数和类型转换函数</h2><p><strong>转换构造函数</strong>和<strong>类型转换函数</strong>的作用是相反的：转换构造函数会将其它类型转换为当前类类型，类型转换函数会将当前类类型转换为其它类型；</p><p>如果没有这两个函数，Complex 类和 int、double、bool 等基本类型的四则运算、逻辑运算都将变得非常复杂，要编写大量的运算符重载函数；</p><p>但是，如果一个类同时存在这两个函数，就有可能产生二义性:例如在处理 c1 + 2.5 时会出现二义性。一种理解是：调用转换构造函数，把 2.5 变成 Complex类对象，然后调用运算符 “+” 重载函数，与 c1 进行复数相加。而另外一种理解就是：调用类型转换函数，把 c1 转换成 double 型数，然后与 2.55 进行相加。导致系统无法判断，这二者是矛盾的。如果想要使用类型转换函数，就应当山区运算符  “+” 重载函数。</p><p>解决二义性问题的办法也很简单粗暴，<strong>要么只使用转换构造函数，要么只使用类型转换函数；</strong></p><p>实践证明，<strong>用户对转换构造函数的需求往往更加强烈，这样能增加编码的灵活性；</strong></p><p>例如，可以将一个字符串字面量或者一个字符数组直接赋值给 string 类的对象，可以将一个 int、double、bool 等基本类型的数据直接赋值给 Complex 类的对象；</p><p>那么，如果我们想把当前类类型转换为其它类型怎么办呢？<br>很简单，增加一个普通的成员函数即可，例如，string 类使用 c_str() 函数转换为 C 风格的字符串，complex 类使用 real() 和 imag() 函数来获取复数的实部和虚部；</p><h2 id="类型转换的本质"><a href="#类型转换的本质" class="headerlink" title="类型转换的本质"></a>类型转换的本质</h2><p>在 C/C++ 中，不同的数据类型之间可以相互转换：<br>无需用户指明如何转换的称为<strong>自动类型转换（隐式类型转换）</strong>，需要用户显式地指明如何转换的称为<strong>强制类型转换（显式类型转换）</strong>；</p><p>隐式类型转换利用的是<strong>编译器内置的转换规则</strong>，或者<strong>用户自定义的转换构造函数以及类型转换函数</strong>（这些都可以认为是已知的转换规则）；</p><p>type *是一个具体类型的指针，例如int *、double *、Student *等，它们都可以直接赋值给void *指针；<br>而反过来是不行的，必须使用强制类型转换才能将void *转换为type *；</p><p>例如，malloc() 分配内存后返回的就是一个void *指针，我们必须进行强制类型转换后才能赋值给指针变量；</p><p>当隐式转换不能完成类型转换工作时，我们就必须使用<strong>强制类型转换</strong>了；</p><p>强制类型转换的语法也很简单，只需要在表达式的前面增加新类型的名称，格式为：<strong>(new_type)expression</strong></p><h3 id="类型转换的本质-1"><a href="#类型转换的本质-1" class="headerlink" title="类型转换的本质"></a>类型转换的本质</h3><p>我们知道，数据是放在内存中的，变量（以及指针、引用）是给这块内存起的名字，有了变量就可以找到并使用这份数据；</p><p>但问题是，该如何使用呢？</p><p>诸如数字、文字、符号、图形、音频、视频等数据都是以二进制形式存储在内存中的，它们并没有本质上的区别，那么，00010000 该理解为数字 16 呢，还是图像中某个像素的颜色呢，还是要发出某个声音呢？如果没有特别指明，我们并不知道；</p><p>也就是说，内存中的数据有多种解释方式，使用之前必须要确定；<br>这种「确定数据的解释方式」的工作就是由 <strong>数据类型（Data Type）</strong> 来完成的；<br>例如 <strong>int a;</strong> 表明，a 这份数据是整数，不能理解为像素、声音、视频等；</p><p>顾名思义，数据类型用来说明数据的类型，确定了数据的解释方式，让计算机和程序员不会产生歧义；<br>C/C++ 支持多种数据类型，包括内置类型（例如 int、double、bool 等）和自定义类型（结构体类型和类类型）；</p><p>所谓数据类型转换，就是对数据所占用的二进制位做出重新解释；如果有必要，在重新解释的同时还会修改数据，改变它的二进制位；</p><p>对于<strong>隐式类型转换</strong>，编译器可以根据<strong>已知的转换规则</strong>来决定是否需要修改数据的二进制位；而对于<strong>强制类型转换</strong>，由于没有对应的转换规则，所以能做的事情仅仅是<strong>重新解释数据的二进制位</strong>，但无法对数据的二进制位做出修正；这就是隐式类型转换和强制类型转换最根本的区别；</p><p>这里说的修改数据并不是修改原有的数据，而是修改它的副本（先将原有数据拷贝到另外一个地方再修改）；</p><p>修改数据的二进制位非常重要，它能把转换后的数据调整到正确的值，所以这种修改时常会发生，例如：</p><p>1) 整数和浮点数在内存中的存储形式大相径庭，将浮点数 f 赋值给整数 i 时，不能原样拷贝 f 的二进制位，也不能截取部分二进制位，必须先将 f 的二进制位读取出来，以浮点数的形式呈现，然后直接截掉小数部分，把剩下的整数部分再转换成二进制形式，拷贝到 i 所在的内存中；</p><p>2) short 一般占用两个字节，int 一般占用四个字节，将 short 类型的 s 赋值给 int 类型的 i 时，如果仅仅是将 s 的二进制位拷贝给 i，那么 i 最后的两个字节会原样保留，这样会导致赋值结束后 i 的值并不等于 s 的值，所以这样做是错误的；<br>正确的做法是，先给 s 添加 16 个二进制位（两个字节）并全部置为 0，然后再拷贝给 i 所在的内存；</p><p>3) 当存在多重继承时，如果把派生类指针 pd 赋值给基类指针 pb，就必须考虑基类子对象在派生类对象中的偏移，偏移不为 0 时就要调整 pd 的值，让它加上或减去偏移量，这样赋值后才能让 pb 恰好指向基类子对象；</p><p>4) Complex 类型占用 16 个字节，double 类型占用 8 个字节，将 double 类型的数据赋值给 Complex 类型的变量（对象）时，必须调用转换构造函数，否则剩下的 8 个字节就不知道如何填充了；</p><p>以上这些都是隐式类型转换，它对数据的调整都是有益的，能够让程序更加安全稳健地运行；</p><p>隐式类型转换必须使用已知的转换规则，虽然灵活性受到了限制，但是由于能够对数据进行恰当地调整，所以更加安全（几乎没有风险）；<br>强制类型转换能够在更大范围的数据类型之间进行转换，例如不同类型指针（引用）之间的转换、从 const 到非 const 的转换、从 int 到指针的转换等；这虽然增加了灵活性，但是由于不能恰当地调整数据，所以也充满了风险，程序员要小心使用；</p><h3 id="为什么会有隐式类型转换和强制类型转换之分？"><a href="#为什么会有隐式类型转换和强制类型转换之分？" class="headerlink" title="为什么会有隐式类型转换和强制类型转换之分？"></a>为什么会有隐式类型转换和强制类型转换之分？</h3><p>隐式类型转换和显式类型转换最根本的区别是：隐式类型转换除了会重新解释数据的二进制位，还会利用已知的转换规则对数据进行恰当地调整；而显式类型转换只能简单粗暴地重新解释二进制位，不能对数据进行任何调整；</p><p>其实，能不能对数据进行调整是显而易见地事情，有转换规则就可以调整，没有转换规则就不能调整，当进行数据类型转换时，编译器明摆着是知道有没有转换规则的；<br>站在这个角度考虑，强制类型转换的语法就是多此一举，编译器完全可以自行判断是否需要调整数据；<br>例如从int *转换到float *，加不加强制类型转换的语法都不能对数据进行调整；</p><p>C/C++ 之所以增加强制类型转换的语法，是为了提醒程序员这样做存在风险，一定要谨慎小心；说得通俗一点，你现在的类型转换存在风险，你自己一定要知道；</p><h3 id="强制类型转换也不是万能的"><a href="#强制类型转换也不是万能的" class="headerlink" title="强制类型转换也不是万能的"></a>强制类型转换也不是万能的</h3><p>类型转换只能发生在相关类型或者相近类型之间，两个毫不相干的类型不能相互转换，即使使用强制类型转换也不行；<br>例如，两个没有继承关系的类不能相互转换，基类不能向派生类转换（向下转型），类类型不能向基本类型转换，指针和类类型之间不能相互转换；</p><h2 id="四种类型转换运算符"><a href="#四种类型转换运算符" class="headerlink" title="四种类型转换运算符"></a>四种类型转换运算符</h2><p>隐式类型转换是安全的，显式类型转换是有风险的，C语言之所以增加强制类型转换的语法，就是为了强调风险，让程序员意识到自己在做什么；</p><p>但是，这种强调风险的方式还是比较粗放，粒度比较大，它并没有表明存在什么风险，风险程度如何；</p><p>为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：</p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>static_cast</td><td>用于良性转换，一般不会导致意外发生，风险很低；</td></tr><tr><td>const_cast</td><td>用于 const 与非 const、volatile 与非 volatile 之间的转换；</td></tr><tr><td>reinterpret_cast</td><td>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换；</td></tr><tr><td>dynamic_cast</td><td>借助 RTTI，用于类型安全的向下转型（Downcasting）；</td></tr></tbody></table><p>这四个关键字的语法格式都是一样的，具体为：xxx_cast&lt;newType&gt;(data)<br>newType是要转换成的新类型，data是被转换的数据；</p><p>比如：score为 double 类型的数据，将其转换为 int：int n = static_cast&lt;int&gt;(score);</p><p><strong>static_cast 关键字</strong><br>static_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外；</p><p>例如原有的自动类型转换，short 转 int、int 转 double、const 转非 const、向上转型等；<br>void 指针和具体类型指针之间的转换，例如void *转int *、char *转void *等；<br>有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）；</p><p>需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：<br>两个具体类型指针之间的转换，例如int *转double *、Student *转int *等；<br>int 和指针之间的转换，将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件；</p><p>static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰；换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型；</p><p>static_cast 是“静态转换”的意思，也就是在<strong>编译期间转换</strong>，转换失败的话会抛出一个编译错误；</p><p><strong>const_cast 关键字</strong><br>const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰；<br>换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型；</p><p><strong>reinterpret_cast 关键字</strong><br>reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高；</p><p>reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换；</p><p><strong>dynamic_cast 关键字</strong><br>dynamic_cast 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）；</p><p>向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功；</p><p>dynamic_cast 与 static_cast 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思；<br>dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就<strong>要求基类必须包含虚函数；</strong><br>static_cast 在编译期间完成类型转换，能够更加及时地发现错误；</p><p>dynamic_cast 的语法格式为：dynamic_cast&lt;newType&gt;(expression)<br>newType和expression必须同时是<strong>指针类型</strong>或者<strong>引用类型</strong>；<br>换句话说，dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行；</p><p>对于指针，如果转换失败将返回 NULL；对于引用，如果转换失败将抛出std::bad_cast异常；</p><p>1) <strong>向上转型（Upcasting）</strong><br>向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数（这些信息在编译期间就能确定），就一定能转换成功；<br>因为向上转型始终是安全的，所以 dynamic_cast 不会进行任何运行期间的检查，这个时候的 dynamic_cast 和 static_cast 就没有什么区别了；</p><p>2) <strong>向下转型（Downcasting）</strong><br>向下转型是有风险的，dynamic_cast 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败；<br>那么，哪些向下转型是安全的呢，哪些又是不安全的呢？下面我们通过一个例子来演示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"class A\n"</span>); &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"class B\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"class C\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"class D\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *pa = <span class="literal">nullptr</span>;</span><br><span class="line">    B *pb = <span class="literal">nullptr</span>;</span><br><span class="line">    C *pc = <span class="literal">nullptr</span>;</span><br><span class="line">    D *pd = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    pa = <span class="keyword">new</span> A;</span><br><span class="line">    pb = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pa); <span class="comment">// 向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span> (pb == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting failed: A * to B *\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting successfully: A * to B *\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span>&lt;D *&gt;(pa); <span class="comment">// 向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting failed: A * to D *\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting successfully: A * to D *\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"----------------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    pa = <span class="keyword">new</span> C;</span><br><span class="line">    pb = <span class="keyword">dynamic_cast</span>&lt;B *&gt;(pa); <span class="comment">// 向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span> (pb == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting failed: A * to B *\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting successfully: A * to B *\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span>&lt;D *&gt;(pa); <span class="comment">// 向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting failed: A * to D *\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Downcasting successfully: A * to D *\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ./a.out</span><br><span class="line">Downcasting failed: A * to B *</span><br><span class="line">Downcasting failed: A * to D *</span><br><span class="line">----------------------------------</span><br><span class="line">Downcasting successfully: A * to B *</span><br><span class="line">Downcasting failed: A * to D *</span><br></pre></td></tr></table></figure><p>当使用 dynamic_cast 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到当前类（指针指向的对象所属的类）的类型信息；<br>并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功；<br>如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换；</p><p>表面上看起来 dynamic_cast 确实能够向下转型，本例也很好地证明了这一点；<br>但是从本质上讲，dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链；</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常（二）</title>
      <link href="/2020/05/09/try0509/"/>
      <url>/2020/05/09/try0509/</url>
      
        <content type="html"><![CDATA[<h2 id="C-异常类型以及多级catch匹配"><a href="#C-异常类型以及多级catch匹配" class="headerlink" title="C++异常类型以及多级catch匹配"></a>C++异常类型以及多级catch匹配</h2><p>上面讲到的 try-catch 的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(exceptionType variable)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exceptionType 是异常类型，它指明了当前的 catch 可以处理什么类型的异常；variable是一个变量，用来接收异常信息。当程序抛出异常时，会创建一份数据，这份数据包含了错误信息，程序员可以根据这些信息来判断到底出了什么问题，接下来怎么处理。</p><p>异常既然是一份数据，那么就应该有数据类型。C++ 规定，异常类型可以是 int、char、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。C++ 语言本身以及标准库中的函数抛出的异常，都是 exception 类或其子类的异常。也就是说，抛出异常时，会创建一个 exception 类或其子类的对象。</p><p>exceptionType variable 和函数的形参非常类似，当异常发生后，会将异常数据传递给 variable 这个变量，这和函数传参的过程类似。当然，只有跟 exceptionType 类型匹配的异常数据才会被传递给 variable，否则 catch 不会接收这份异常数据，也不会执行 catch 块中的语句。换句话说，catch 不会处理当前的异常。</p><p><strong>我们可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参（异常数据）</strong>。</p><p>但是 catch 和真正的函数调用又有区别：</p><ul><li>真正的函数调用，形参和实参的类型必须要匹配，或者可以自动转换，否则在编译阶段就报错了。</li><li>而对于 catch，异常是在运行阶段产生的，它可以是任何类型，没法提前预测，所以不能在编译阶段判断类型是否正确，只能等到程序运行后，真的抛出异常了，再将异常类型和 catch 能处理的类型进行匹配，匹配成功的话就“调用”当前的 catch，否则就忽略当前的 catch。</li></ul><p><strong>总起来说，catch 和真正的函数调用相比，多了一个「在运行阶段将实参和形参匹配」的过程。</strong></p><p>另外需要注意的是，如果不希望 catch 处理异常数据，也可以将 variable 省略掉，也即写作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(exceptionType)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只会将异常类型和 catch 所能处理的类型进行匹配，不会传递异常数据了。</p><h3 id="多级catch"><a href="#多级catch" class="headerlink" title="多级catch"></a>多级catch</h3><p>一个 try 后面可以跟多个 catch：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (exception_type_1 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (exception_type_2 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他的catch</span></span><br><span class="line"><span class="keyword">catch</span> (exception_type_n e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当异常发生时，程序会按照从上到下的顺序，将异常类型和 catch 所能接收的类型逐个匹配。一旦找到类型匹配的 catch 就停止检索，并将异常交给当前的 catch 处理（其他的 catch 不会被执行）。如果最终也没有找到匹配的 catch，就只能交给系统处理，终止程序的运行。</p><p>多级 catch 的使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> Derived();  <span class="comment">//抛出自己的异常类型，实际上是创建一个Derived类型的匿名对象</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">int</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: int"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">char</span> *)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: cahr *"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Base)&#123;  <span class="comment">//匹配成功（向上转型）</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: Base"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Derived)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: Derived"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Exception type: Base</p></blockquote><p>在 catch 中，我们只给出了异常类型，没有给出接收异常信息的变量。<br>本例中，我们定义了一个基类 Base，又从 Base 派生类出了 Derived。抛出异常时，我们创建了一个 Derived 类的匿名对象，也就是说，异常的类型是 Derived。</p><p>我们期望的是，异常被catch(Derived)捕获，但是从输出结果可以看出，异常提前被catch(Base)捕获了，这说明 <strong>catch 在匹配异常类型时发生了向上转型（Upcasting）。</strong></p><h3 id="catch-在匹配过程中的类型转换"><a href="#catch-在匹配过程中的类型转换" class="headerlink" title="catch 在匹配过程中的类型转换"></a>catch 在匹配过程中的类型转换</h3><p>C/C++ 中存在多种多样的类型转换，以普通函数（非模板函数）为例，发生函数调用时，如果实参和形参的类型不是严格匹配，那么会将实参的类型进行适当的转换，以适应形参的类型，这些转换包括：</p><ul><li>算数转换：例如 int 转换为 float，char 转换为 int，double 转换为 int 等。</li><li>向上转型：也就是派生类向基类的转换。</li><li>const 转换：也即将非 const 类型转换为 const 类型，例如将 char * 转换为 const char *。</li><li>数组或函数指针转换：如果函数形参不是引用类型，那么数组名会转换为数组指针，函数名也会转换为函数指针。<br>用户自定的类型转换。</li></ul><p>catch 在匹配异常类型的过程中，也会进行类型转换，但是这种转换受到了更多的限制，仅能进行「向上转型」、「const 转换」和「数组或函数指针转换」，其他的都不能应用于 catch。</p><p>向上转型在上面的例子中已经发生了，下面的例子演示了 const 转换以及数组和指针的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> nums;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">int</span> *)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Exception type: const int *"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Exception type: const int *</p></blockquote><p>nums 本来的类型是int [3]，但是 catch 中没有严格匹配的类型，所以先转换为int *，再转换为const int *。</p><p><strong>数组也是一种类型，数组并不等价于指针</strong>。</p><h2 id="C-throw（抛出异常）"><a href="#C-throw（抛出异常）" class="headerlink" title="C++ throw（抛出异常）"></a>C++ throw（抛出异常）</h2><p>C++ 异常处理的流程，具体为：</p><blockquote><p>抛出（Throw）–&gt; 检测（Try） –&gt; 捕获（Catch）</p></blockquote><p>异常必须显式地抛出，才能被检测和捕获到；如果没有显式的抛出，即使有异常也检测不到。</p><p>在 C++ 中，我们使用 throw 关键字来显式地抛出异常，它的用法为：</p><blockquote><p>throw exceptionData;</p></blockquote><p>exceptionData 是“异常数据”的意思，它可以包含任意的信息，完全有程序员决定。exceptionData 可以是 int、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型。</p><h2 id="throw-用作异常规范（了解）"><a href="#throw-用作异常规范（了解）" class="headerlink" title="throw 用作异常规范（了解）"></a>throw 用作异常规范（了解）</h2><p>throw 关键字除了可以用在函数体中抛出异常，还可以用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为异常规范（Exception specification），有些教程也称为异常指示符或异常列表。请看下面的例子：</p><blockquote><p>double func (char param) throw (int);</p></blockquote><p>这条语句声明了一个名为 func 的函数，它的返回值类型为 double，有一个 char 类型的参数，并且只能抛出 int 类型的异常。如果抛出其他类型的异常，try 将无法捕获，只能终止程序。</p><p>如果函数会抛出多种类型的异常，那么可以用逗号隔开：</p><blockquote><p>double func (char param) throw (int, char, exception);</p></blockquote><p>如果函数不会抛出任何异常，那么( )中什么也不写：</p><blockquote><p>double func (char param) throw ();</p></blockquote><p>如此，func() 函数就不能抛出任何类型的异常了，即使抛出了，try 也检测不到。</p><p>C++ 规定，派生类虚函数的异常规范必须与基类虚函数的异常规范一样严格，或者更严格。同时要求异常规范在函数声明和函数定义中必须同时指明，并且要严格<strong>保持一致</strong>，不能更加严格或者更加宽松。</p><p>不过<strong>异常规范是 C++98 新增的一项功能，但是后来的 C++11 已经将它抛弃了</strong>，不再建议使用。另外，各个编译器对异常规范的支持也不一样。</p><h2 id="C-exception类：C-标准异常的基类"><a href="#C-exception类：C-标准异常的基类" class="headerlink" title="C++ exception类：C++标准异常的基类"></a>C++ exception类：C++标准异常的基类</h2><p>C++语言本身或者标准库抛出的异常都是 exception 的子类，称为标准异常（Standard Exception）。可以通过下面的语句来捕获所有的标准异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(exception &amp;e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以使用引用，是为了提高效率。如果不使用引用，就要经历一次对象拷贝（要调用拷贝构造函数）的过程。</p><p>exception 类位于 &lt;exception&gt; 头文件中，它被声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">exception</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    exception () <span class="keyword">throw</span>();  <span class="comment">//构造函数</span></span><br><span class="line">    exception (<span class="keyword">const</span> exception&amp;) <span class="keyword">throw</span>();  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    exception&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> exception&amp;) <span class="keyword">throw</span>();  <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="keyword">virtual</span> ~exception() <span class="keyword">throw</span>();  <span class="comment">//虚析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明的是 what() 函数。what() 函数返回一个能识别异常的字符串，正如它的名字“what”一样，可以粗略告诉你这是什么异常。不过C++标准并没有规定这个字符串的格式，各个编译器的实现也不同，所以 what() 的返回值仅供参考。</p><p>下图展示了 exception 类的继承层次：<br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200509214741.png" alt="exception 类的继承层次以及它们所对应的头文件"></p><p>exception 类的直接派生类：</p><table><thead><tr><th align="left">异常名称</th><th>说  明</th></tr></thead><tbody><tr><td align="left">logic_error</td><td>逻辑错误。</td></tr><tr><td align="left">runtime_error</td><td>运行时错误。</td></tr><tr><td align="left">bad_alloc</td><td>使用 new 或 new[ ] 分配内存失败时抛出的异常。</td></tr><tr><td align="left">bad_typeid</td><td>使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常。</td></tr><tr><td align="left">bad_cast</td><td>使用 dynamic_cast 转换失败时抛出的异常。</td></tr><tr><td align="left">ios_base::failure</td><td>io 过程中出现的异常。</td></tr><tr><td align="left">bad_exception</td><td>这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型。</td></tr></tbody></table><p>logic_error 的派生类： </p><table><thead><tr><th align="left">异常名称</th><th>说  明</th></tr></thead><tbody><tr><td align="left">length_error</td><td>试图生成一个超出该类型最大长度的对象时抛出该异常，例如 vector 的 resize 操作。</td></tr><tr><td align="left">domain_error</td><td>参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数。</td></tr><tr><td align="left">out_of_range</td><td>超出有效范围。</td></tr><tr><td align="left">invalid_argument</td><td>参数不合适。在标准库中，当利用string对象构造 bitset 时，而 string 中的字符不是 0 或1 的时候，抛出该异常。</td></tr></tbody></table><p>runtime_error 的派生类： </p><table><thead><tr><th align="left">异常名称</th><th>说  明</th></tr></thead><tbody><tr><td align="left">range_error</td><td>计算结果超出了有意义的值域范围。</td></tr><tr><td align="left">overflow_error</td><td>算术计算上溢。</td></tr><tr><td align="left">underflow_error</td><td>算术计算下溢。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常（一）</title>
      <link href="/2020/05/07/try0507/"/>
      <url>/2020/05/07/try0507/</url>
      
        <content type="html"><![CDATA[<h2 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++ 异常处理"></a>C++ 异常处理</h2><p>程序的错误大致可以分为三种，分别是语法错误、逻辑错误和运行时错误：</p><p>1) 语法错误在编译和链接阶段就能发现，只有 100% 符合语法规则的代码才能生成可执行程序。语法错误是最容易发现、最容易定位、最容易排除的错误，程序员最不需要担心的就是这种错误。</p><p>2) 逻辑错误是说我们编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决。</p><p>3) 运行时错误是指程序在运行期间发生的错误，例如除数为 0、内存分配失败、数组越界、文件不存在等。C++ 异常（Exception）机制就是为解决运行时错误而引入的。</p><p>运行时错误如果放任不管，系统就会执行默认的操作，终止程序运行，也就是我们常说的程序崩溃（Crash）。<strong>C++ 提供了异常（Exception）机制，让我们能够捕获运行时错误，给程序一次“起死回生”的机会，或者至少告诉用户发生了什么再终止程序。</strong></p><p>例如下面一个发生错误的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">    <span class="keyword">char</span> ch1 = str[<span class="number">100</span>];  <span class="comment">//下标越界，ch1为垃圾值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ch1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> ch2 = str.at(<span class="number">100</span>);  <span class="comment">//下标越界，抛出异常</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ch2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，在控制台输出 ch1 的值后程序崩溃。下面我们来分析一下原因。</p><p>at() 是 string 类的一个成员函数，它会根据下标来返回字符串的一个字符。与[ ]不同，at() 会检查下标是否越界，如果越界就抛出一个异常；而[ ]不做检查，不管下标是多少都会照常访问。</p><blockquote><p>所谓抛出异常，就是报告一个运行时错误，程序员可以根据错误信息来进一步处理。</p></blockquote><p>上面的代码中，下标 100 显然超出了字符串 str 的长度。由于第 6 行代码不会检查下标越界，虽然有逻辑错误，但是程序能够正常运行。而第 8 行代码则不同，at() 函数检测到下标越界会抛出一个异常，这个异常可以由程序员处理，但是我们在代码中并没有处理，所以系统只能执行默认的操作，也即终止程序执行。</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>我们可以借助 C++ 异常机制来捕获上面的异常，避免程序崩溃。捕获异常的语法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(exceptionType variable)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try和catch都是 C++ 中的关键字，后跟语句块，不能省略{ }。try 中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的 catch 捕获。从 try 的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。catch 是“抓住”的意思，用来捕获并处理 try 检测到的异常；如果 try 语句块没有检测到异常（没有异常抛出），那么就不会执行 catch 中的语句。</p><p><strong>这就好比，catch 告诉 try：你去检测一下程序有没有错误，有错误的话就告诉我，我来处理，没有的话就不要理我！</strong></p><p>catch 关键字后面的 exceptionType variable 指明了当前 catch 可以处理的异常类型，以及具体的出错信息.</p><p>示例二：修改上面的代码，加入捕获异常的语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"http://c.biancheng.net"</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch1 = str[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ch1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(exception e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[1]out of bound!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch2 = str.at(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ch2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(exception &amp;e)&#123;  <span class="comment">//exception类位于&lt;exception&gt;头文件中</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[2]out of bound!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>(<br>[2]out of bound!</p></blockquote><p>可以看出，第一个 try 没有捕获到异常，输出了一个没有意义的字符（垃圾值）。<strong>因为[ ]不会检查下标越界，不会抛出异常</strong>，所以即使有错误，try 也检测不到。<strong>换句话说，发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到</strong>。所谓抛出异常，就是明确地告诉程序发生了什么错误。</p><p>第二个 try 检测到了异常，并交给 catch 处理，执行 catch 中的语句。需要说明的是，异常一旦抛出，会立刻被 try 检测到，并且不会再执行异常点（异常发生位置）后面的语句。本例中抛出异常的位置是第 17 行的 at() 函数，它后面的 cout 语句就不会再被执行，所以看不到它的输出。</p><p>说得直接一点，<strong>检测到异常后程序的执行流会发生跳转，从异常点跳转到 catch 所在的位置，位于异常点之后的、并且在当前 try 块内的语句就都不会再执行了</strong>；即使 catch 语句成功地处理了错误，程序的执行流也不会再回退到异常点，所以这些语句永远都没有执行的机会了。本例中，第 18 行代码就是被跳过的代码。</p><p>执行完 catch 块所包含的代码后，程序会继续执行 catch 块后面的代码，就恢复了正常的执行流。</p><p>为了演示「不明确地抛出异常就检测不到异常」，大家不妨将第 10 行代码改为char ch1 = str[100000000];，访问第 100 个字符可能不会发生异常，但是访问第 1 亿个字符肯定会发生异常了，这个异常就是内存访问错误。运行更改后的程序，会发现第 10 行代码产生了异常，导致程序崩溃了，这说明 try-catch 并没有捕获到这个异常。</p><h3 id="发生异常的位置"><a href="#发生异常的位置" class="headerlink" title="发生异常的位置"></a>发生异常的位置</h3><p>异常可以发生在当前的 try 块中，也可以发生在 try 块所调用的某个函数中，或者是所调用的函数又调用了另外的一个函数，这个另外的函数中发生了异常。这些异常，都可以被 try 检测到。</p><p>1) 下面的例子演示了 try 块中直接发生的异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Unknown Exception"</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Unknown Exception</p></blockquote><p>throw关键字用来抛出一个异常，这个异常会被 try 检测到，进而被 catch 捕获。关于 throw 的用法，我们将在下节深入讲解，这里大家只需要知道，在 try 块中直接抛出的异常会被 try 检测到。</p><p>2) 下面的例子演示了 try 块中调用的某个函数中发生了异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Unknown Exception"</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"[1]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        func();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[2]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Unknown Exception</p></blockquote><p>func() 在 try 块中被调用，它抛出的异常会被 try 检测到，进而被 catch 捕获。从运行结果可以看出，func() 中的 cout 和 try 中的 cout 都没有被执行。</p><p>3) try 块中调用了某个函数，该函数又调用了另外的一个函数，这个另外的函数抛出了异常：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Unknown Exception"</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"[1]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func_inner();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"[2]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        func_outer();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"[3]This statement will not be executed."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Unknown Exception</p></blockquote><p>发生异常后，程序的执行流会沿着函数的调用链往前回退，直到遇见 try 才停止。在这个回退过程中，调用链中剩下的代码（所有函数中未被执行的代码）都会被跳过，没有执行的机会了。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板（二）</title>
      <link href="/2020/05/07/template2/"/>
      <url>/2020/05/07/template2/</url>
      
        <content type="html"><![CDATA[<h2 id="三、模板的形参"><a href="#三、模板的形参" class="headerlink" title="三、模板的形参"></a>三、模板的形参</h2><p>有三种类型的模板形参：类型形参，非类型形参和模板形参。</p><p><strong>1、类型形参</strong></p><p>1.1 、类型模板形参：<strong>类型形参由关见字class或typename后接说明符构成</strong>，如<strong>template<class T> void h(T a){}</strong>;其中<strong>T</strong>就是一个类型形参，类型形参的名字由用户自已确定。<strong>模板形参表示的是一个未知的类型</strong>。模板类型形参可作为类型说明符用在模板中的任何地方，与内置类型说明符或类类型说明符的使用方式完全相同，即可以用于指定返回类型，变量声明等。</p><p>1.2、不能为同一个模板类型形参指定两种不同的类型，比如<strong>template<class T>void h(T a, T b){}</strong>，语句调用h(2, 3.2)将出错，因为该语句给同一模板形参T指定了两种类型，第一个实参2把模板形参T指定为int，而第二个实参3.2把模板形参指定为double，两种类型的形参不一致，会出错。<strong>（针对函数模板）</strong></p><p>1.2针对函数模板是正确的，但是忽略了类模板。下面将对类模板的情况进行补充。</p><p>1.2补充版（<strong>针对于类模板</strong>）、当我们声明类对象为：<strong>A<int> a</strong>，比如<strong>template<class T>T g(T a, T b){}</strong>，语句调用a.g(2, 3.2)在编译时不会出错，但会有警告，因为在声明类对象的时候已经将T转换为int类型，而第二个实参3.2把模板形参指定为double，在运行时，会对3.2进行强制类型转换为3。当我们声明类的对象为：A<double> a,此时就不会有上述的警告，因为从int到double是自动类型转换。</p><p><strong>2、非类型形参</strong></p><p>　　　　2.1 、非类型模板形参：<strong>模板的非类型形参也就是内置类型形参</strong>，如</p><blockquote><p>  template&lt;class T, int a&gt; class B{};</p></blockquote><p>其中int a就是非类型的模板形参。</p><p>　　　　2.2、 非类型形参在模板定义的内部是常量值，也就是说非类型形参在模板的内部是常量。</p><p>　　　　2.3、 <strong>非类型模板的形参只能是整型，指针和引用</strong>，像double，String, String **这样的类型是不允许的。但是double &amp;，double *，对象的引用或指针是正确的。</p><p>　　　　2.4、 <strong>调用非类型模板形参的实参必须是一个常量表达式</strong>，即他必须能在编译时计算出结果。</p><p>　　　　2.5 、注意：<strong>任何局部对象，局部变量，局部对象的地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参</strong>。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模板形参的实参。</p><p>　　　　2.6、<strong>全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参。</strong></p><p>　　　　2.7 、<strong>sizeof</strong>表达式的结果是一个常量表达式，也能用作非类型模板形参的实参。</p><p>　　　　2.8 、当模板的形参是整型时调用该模板时的实参必须是整型的，且在编译期间是常量，比如</p><blockquote><p>  template &lt;class T, int a&gt; class A{};</p></blockquote><p>如果有int b，这时A&lt;int, b&gt; m;将出错，因为b不是常量，如果const int b，这时A&lt;int, b&gt; m;就是正确的，因为这时b是常量。</p><p>　　　　2.9 、<strong>非类型形参一般不应用于函数模板中</strong>，比如有函数模板</p><blockquote><p>  template&lt;class T, int a&gt; void h(T b){}，</p></blockquote><p>若使用h(2)调用会出现无法为非类型形参a推演出参数的错误，对这种模板函数可以用显示模板实参来解决，如用h&lt;int, 3&gt;(2)这样就把非类型形参a设置为整数3。显示模板实参在后面介绍。</p><p>　　　　2.10、 非类型模板形参的形参和实参间所允许的转换</p><p>　　　　　　1、允许从数组到指针，从函数到指针的转换。如：</p><blockquote><p>  template &lt;int *a&gt; class A{}; int b[1]; A&lt;b&gt; m;</p></blockquote><p>即数组到指针的转换</p><p>　　　　　　2、const修饰符的转换。如：template&lt;const int *a&gt; class A{}; int b; A&lt;&amp;b&gt; m; 即从int *到const int *的转换。</p><p>　　　　　　3、提升转换。如：template<int a> class A{}; const short b=2; A&lt;b&gt; m; 即从short到int 的提升转换</p><p>　　　　　　4、整值转换。如：template<unsigned int a> class A{};   A&lt;3&gt; m; 即从int 到unsigned int的转换。</p><p>　　　　　　5、常规转换。</p><h2 id="四、类模板的默认模板类型形参"><a href="#四、类模板的默认模板类型形参" class="headerlink" title="四、类模板的默认模板类型形参"></a>四、类模板的默认模板类型形参</h2><p>1、可以为类模板的类型形参提供默认值，但不能为函数模板的类型形参提供默认值。函数模板和类模板都可以为模板的非类型形参提供默认值。</p><p>2、类模板的类型形参默认值形式为：</p><blockquote><p>template&lt;class T1, class T2=int&gt; class A{};</p></blockquote><p>为第二个模板类型形参T2提供int型的默认值。</p><p>3、类模板类型形参默认值和函数的默认参数一样，如果有多个类型形参则从第一个形参设定了默认值之后的所有模板形参都要设定默认值，类模板如果有多个类型形参，如果使用类型形参默认值则尽量放在参数列表的末尾，而且默认的参数类型必须相同。在下面示例中：</p><blockquote><p>template&lt;class T1=int, class T2&gt;class A{};</p></blockquote><p>就是错误的，因为T1给出了默认值，而T2没有设定。</p><p>4、在类模板的外部定义类中的成员时template 后的形参表应省略默认的形参类型。比如</p><blockquote><p>template&lt;class  T1, class T2=int&gt; class A{public: void h();}; </p></blockquote><p>定义方法为</p><blockquote><p>template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</span></span><br><span class="line"><span class="comment">//类模板的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">A</span>&#123;</span><span class="keyword">public</span>:<span class="function">T <span class="title">g</span><span class="params">(T a, T b)</span></span>; A();&#125;;  <span class="comment">//定义带有一个类模板类型形参T的类A</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;<span class="title">class</span> <span class="title">B</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义带有两个类模板类型形参T1，T2的类B</span></span><br><span class="line"><span class="comment">//定义类模板的默认类型形参，默认类型形参不适合于函数模板。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>=<span class="title">int</span>&gt; <span class="title">class</span> <span class="title">D</span>&#123;</span><span class="keyword">public</span>: voidg();&#125;; <span class="comment">//定义带默认类型形参的类模板。这里把T2默认设置为int型。</span></span><br><span class="line"><span class="comment">//template&lt;class T1=int, class T2&gt;class E&#123;&#125;; //错误，为T1设了默认类型形参则T1后面的所有形参都必须设置认默值。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//以下为非类型形参的定义</span></span><br><span class="line"><span class="comment">//非类型形参只能是整型，指针和引用，像double，String, String **这样的类型是不允许的。但是double &amp;，double *对象的引用或指</span></span><br><span class="line">针是正确的。</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> <span class="title">a</span>&gt; <span class="title">class</span> <span class="title">Ci</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义模板的非类型形参，形参为整型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> &amp;<span class="title">a</span>&gt;<span class="title">class</span> <span class="title">Cip</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">A</span>&lt;int&gt;* <span class="title">m</span>&gt; <span class="title">class</span> <span class="title">Cc</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义模板的模板类型形参，形参为int型的类A的对象的指针。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">double</span>*<span class="title">a</span>&gt;<span class="title">class</span> <span class="title">Cd</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;;  <span class="comment">//定义模板的非类型形参，形参为double类型的引用。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>&#123;</span>&#125;; <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">E</span> &amp;<span class="title">m</span>&gt; <span class="title">class</span> <span class="title">Ce</span>&#123;</span>&#125;; <span class="comment">//非类型模板形参为对象的引用。</span></span><br><span class="line"><span class="comment">//以下非类型形参的声明是错误的。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,A m&gt;class Cc&#123;&#125;; //错误，对象不能做为非类型形参，非类型模板形参的类型只能是对象的引用或指针。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,double a&gt;class Cc&#123;&#125;; //错误，非类型模板的形参不能是double类型，可以是double的引用。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,A&lt;int&gt; m&gt;class Cc&#123;&#125;; //错误，非类型模板的形参不能是对象，必须是对象的引用或指针。这条规则对于模板型参</span></span><br><span class="line">也不例外。</span><br><span class="line"><span class="comment">//在类模板外部定义各种类成员的方法，</span></span><br><span class="line"><span class="comment">//typeid(变量名).name()的作用是提取变量名的类型，如int a，则cout&lt;&lt;typeid(a).name()将输出int</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;   <span class="title">A</span>&lt;T&gt;:</span>:A()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class A goucao"</span>&lt;&lt;<span class="keyword">typeid</span>(T).name()&lt;&lt;<span class="built_in">endl</span>;&#125; <span class="comment">//在类模板外部定义类的构造函数的方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">A</span>&lt;T&gt;:</span>:g(T a,T b)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class A g(T a,T b)"</span>&lt;&lt;<span class="built_in">endl</span>;&#125; <span class="comment">//在类模板外部定义类模板的成员</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;  <span class="title">voidB</span>&lt;T1,T2&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class g f()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="keyword">typeid</span>(T2).name()&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="comment">//在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> <span class="title">a</span>&gt;     <span class="title">voidCi</span>&lt;T1,a&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Ci g()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> &amp;<span class="title">a</span>&gt;    <span class="title">voidCip</span>&lt;T1,a&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Cip g()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="built_in">endl</span>;&#125; </span><br><span class="line"><span class="comment">//在类外部定义类的成员时，template后的模板形参应与要定义的类的模板形参一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">A</span>&lt;int&gt; *<span class="title">m</span>&gt; <span class="title">voidCc</span>&lt;T1,m&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Cc g()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">double</span>* <span class="title">a</span>&gt; <span class="title">voidCd</span>&lt;T1,a&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class Cd g()"</span>&lt;&lt;<span class="keyword">typeid</span>(T1).name()&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//带有默认类型形参的模板类，在类的外部定义成员的方法。</span></span><br><span class="line"><span class="comment">//在类外部定义类的成员时，template的形参表中默认值应省略</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;  <span class="title">voidD</span>&lt;T1,T2&gt;:</span>:g()&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"class D g()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="comment">//template&lt;class T1,class T2=int&gt; void D&lt;T1,T2&gt;::g()&#123;cout&lt;&lt;"class D k()"&lt;&lt;endl;&#125; //错误，在类模板外部定义带有默认类型的形</span></span><br><span class="line">参时，在<span class="keyword">template</span>的形参表中默认值应省略。</span><br><span class="line"><span class="comment">//定义一些全局变量。</span></span><br><span class="line"><span class="keyword">int</span> e=<span class="number">2</span>;  doubleed=<span class="number">2.2</span>; <span class="keyword">double</span>*pe=&amp;ed;</span><br><span class="line">A&lt;<span class="keyword">int</span>&gt; mw; A&lt;<span class="keyword">int</span>&gt; *pec=&amp;mw; E me;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// template&lt;class T&gt;void h()&#123;&#125; //错误，模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行。</span></span><br><span class="line"><span class="comment">//A&lt;2&gt; m; //错误，对类模板不存在实参推演问题，类模板必须在尖括号中明确指出其类型。</span></span><br><span class="line"><span class="comment">//类模板调用实例</span></span><br><span class="line">A&lt;<span class="keyword">int</span>&gt; ma; <span class="comment">//输出"class A goucao int"创建int型的类模板A的对象ma。</span></span><br><span class="line">B&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mb; mb.g(); <span class="comment">//输出"class B g() int int"创建类模板B的对象mb，并把类型形参T1和T2设计为int</span></span><br><span class="line"><span class="comment">//非类型形参的调用</span></span><br><span class="line"><span class="comment">//调用非类型模板形参的实参必须是一个常量表达式，即他必须能在编译时计算出结果。任何局部对象，局部变量，局部对象的地址，局部</span></span><br><span class="line">变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能</span><br><span class="line">用作非类型模板形参的实参。</span><br><span class="line"><span class="comment">//全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参。</span></span><br><span class="line"><span class="comment">//调用整型int型非类型形参的方法为名为Ci，声明形式为template&lt;class T1,int a&gt; class Ci</span></span><br><span class="line">Ci&lt;<span class="keyword">int</span>,<span class="number">3</span>&gt;<span class="comment">//正确，数值R是一个int型常量，输出"class Ci g() int"</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a2=<span class="number">3</span>; Ci&lt;<span class="keyword">int</span>,a2&gt; mci1; mci1.g(); <span class="comment">//正确，因为a2在这里是const型的常量。输出"class Ci g() int"</span></span><br><span class="line"><span class="comment">//Ci&lt;int,a&gt; mci; //错误，int型变量a是局部变量，不是一个常量表达式。</span></span><br><span class="line"><span class="comment">//Ci&lt;int,e&gt; mci; //错误，全局int型变量e也不是一个常量表达式。</span></span><br><span class="line"><span class="comment">//调用int&amp;型非类型形参的方法类名为Cip，声明形式为template&lt;class T1,int &amp;a&gt;class Cip</span></span><br><span class="line">Cip&lt;<span class="keyword">int</span>,e&gt; mcip;  <span class="comment">//正确，对全局变量的引用或地址是常量表达式。</span></span><br><span class="line"><span class="comment">//Cip&lt;int,a&gt; mcip1; //错误，局部变量的引用或地址不是常量表达式。</span></span><br><span class="line"><span class="comment">//调用double*类型的非类形形参类名为Cd，声明形式为template&lt;class T1,double *a&gt;class Cd</span></span><br><span class="line">Cd&lt;<span class="keyword">int</span>,&amp;ed&gt; mcd; <span class="comment">//正确，全局变量的引用或地址是常量表达式。</span></span><br><span class="line"><span class="comment">//Cd&lt;int,pe&gt; mcd1; //错误，全局变量指针不是常量表达式。</span></span><br><span class="line"><span class="comment">//double dd=3.3; //错误，局部变量的地址不是常量表达式，不能用作非类型形参的实参</span></span><br><span class="line"><span class="comment">//Cd&lt;int,&amp;e&gt; mcd;  //错误，非类型形参虽允许一些转换，但这个转换不能实现。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//调用模板类型形参对象A&lt;int&gt; *的方法类名为Cc，声名形式为template&lt;class T1,A&lt;int&gt;* m&gt; class Cc</span></span><br><span class="line">Cc&lt;<span class="keyword">int</span>,&amp;mw&gt; mcc; mcc.g(); <span class="comment">//正确，全局对象的地址或者引用是常量表达式</span></span><br><span class="line"><span class="comment">//Cc&lt;int,&amp;ma&gt; mcc;  //错误，局部变量的地址或引用不是常量表达式。</span></span><br><span class="line"><span class="comment">//Cc&lt;int,pec&gt; mcc2;  //错误，全局对象的指针不是常量表达式。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//调用非类型形参E&amp;对象的引用的方法类名为Ce。声明形式为template&lt;class T1,E &amp;m&gt; class Ce</span></span><br><span class="line">E me1; <span class="comment">//Ce&lt;int,me1&gt; mce1; //错误，局部对象不是常量表达式</span></span><br><span class="line">Ce&lt;<span class="keyword">int</span>,me&gt; mce;  <span class="comment">//正确，全局对象的指针或引用是常量表达式。</span></span><br><span class="line"><span class="comment">//非类型形参的转换示例，类名为Ci</span></span><br><span class="line"><span class="comment">//非类型形参允许从数组到指针，从函数到指针的转换，const修饰符的转换，提升转换，整值转换，常规转换。</span></span><br><span class="line"><span class="keyword">const</span> short s=<span class="number">3</span>; Ci&lt;<span class="keyword">int</span>,s&gt; mci4<span class="comment">//正确，虽然short型和int不完全匹配，但这里可以将short型转换为int型</span></span><br></pre></td></tr></table></figure><p>整理参考：<a href="https://www.runoob.com/w3cnote/c-templates-detail.html" target="_blank" rel="noopener">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板（一）</title>
      <link href="/2020/05/06/template1/"/>
      <url>/2020/05/06/template1/</url>
      
        <content type="html"><![CDATA[<p>模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。</p><p>模板是一种对类型进行参数化的工具；</p><p>通常有两种形式：<strong>函数模板</strong>和<strong>类模板</strong>；</p><p>函数模板针对仅参数类型不同的函数；</p><p>类模板针对仅数据成员和成员函数类型不同的类。</p><p>使用模板的目的就是能够让程序员编写与类型无关的代码。比如编写了一个交换两个整型int 类型的swap函数，这个函数就只能实现int 型，对double，字符这些类型无法实现，要实现这些类型的交换就要重新编写另一个swap函数。使用模板的目的就是要让这程序的实现与类型无关，比如一个swap模板函数，即可以实现int 型，又可以实现double型的交换。模板可以应用于函数和类。下面分别介绍。</p><p><strong>注意</strong>：<strong><em>模板的声明或定义只能在全局</em></strong>，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</p><h2 id="一、函数模板通式"><a href="#一、函数模板通式" class="headerlink" title="一、函数模板通式"></a>一、函数模板通式</h2><p>1、函数模板的格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 形参名，<span class="title">class</span> 形参名，......&gt; 返回类型 函数名(参数列表)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中template和class是关见字，class可以用typename 关见字代替，在这里typename 和class没区别，&lt;&gt;括号中的参数叫模板形参，模板形参和函数形参很相像，模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。模板形参需要调用该模板函数时提供的模板实参来初始化模板形参，一旦编译器确定了实际的模板实参类型就称他实例化了函数模板的一个实例。比如swap的模板函数形式为:</p><blockquote><p>template <class T> void swap(T&amp; a, T&amp; b){}，</p></blockquote><p>当调用这样的模板函数时类型T就会被被调用时的类型所代替，比如<strong>swap(a,b)</strong>其中<strong>a</strong>和<strong>b</strong>是<strong>int</strong> 型，这时模板函数swap中的形参<strong>T</strong>就会被<strong>int</strong> 所代替，模板函数就变为<strong>swap(int &amp;a, int &amp;b)</strong>。而当<strong>swap(c,d)</strong>其中<strong>c</strong>和<strong>d</strong>是<strong>double</strong>类型时，模板函数会被替换为<strong>swap(double &amp;a, double &amp;b)</strong>，这样就实现了函数的实现与类型无关的代码。</p><p>2、注意：对于函数模板而言不存在 h(int,int) 这样的调用，<strong>不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行</strong>，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b)。</p><p>函数模板的示例演示在下文涉及.</p><h2 id="二、类模板通式"><a href="#二、类模板通式" class="headerlink" title="二、类模板通式"></a>二、类模板通式</h2><p>1、类模板的格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>  形参名，<span class="title">class</span> 形参名，…&gt;   <span class="title">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure><p>类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如</p><blockquote><p>template<class T> class A{public: T a; T b; T hy(T c, T &amp;d);};</p></blockquote><p>在类A中声明了两个类型为T的成员变量a和b，还声明了一个返回类型为T带两个参数类型为T的函数hy。</p><p>　　2、类模板对象的创建：比如一个模板类A，则使用类模板创建对象的方法为A&lt;int&gt; m;在类A后面跟上一个&lt;&gt;尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A&lt;int, double&gt; m;类型之间用逗号隔开。</p><p>　　3、对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A&lt;2&gt; m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: ‘a’ uses undefined class ‘A<int>‘），<strong>类模板形参不存在实参推演的问题</strong> 。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A&lt;int&gt; m。</p><p>4、在类模板外部定义成员函数的方法为：</p><blockquote><p>template&lt;模板形参列表&gt; 函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}</p></blockquote><p>比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为：</p><blockquote><p>template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。</p></blockquote><p>注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。</p><p>5、再次提醒注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++的运算符重载</title>
      <link href="/2020/05/06/c-operator/"/>
      <url>/2020/05/06/c-operator/</url>
      
        <content type="html"><![CDATA[<h1 id="C-运算符重载基础教程"><a href="#C-运算符重载基础教程" class="headerlink" title="C++运算符重载基础教程"></a>C++运算符重载基础教程</h1><p>函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作。<strong>运算符重载（Operator Overloading）</strong> 也是一个道理，同一个运算符可以有不同的功能。</p><p>实际上，我们已经在不知不觉中使用了运算符重载。例如，<kbd>+</kbd>号可以对不同类型（int、float 等）的数据进行加法操作；<kbd><</kbd>既是位移运算符，又可以配合 cout 向控制台输出数据。C++ 本身已经对这些运算符进行了重载。</p><p>C++ 也允许程序员自己重载运算符.</p><p>下面的代码定义了一个复数类，通过运算符重载，可以用+号实现复数的加法运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现运算符重载</span></span><br><span class="line"><span class="built_in">complex</span> <span class="built_in">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">complex</span> B;</span><br><span class="line">    B.m_real = <span class="keyword">this</span>-&gt;m_real + A.m_real;</span><br><span class="line">    B.m_imag = <span class="keyword">this</span>-&gt;m_imag + A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="built_in">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：6.7 + 9.5i</code></pre><p>本例中义了一个复数类 complex，m_real 表示实部，m_imag 表示虚部.</p><p>运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数。<strong>也就是说，运算符重载是通过函数实现的，它本质上是函数重载。</strong></p><p>运算符重载的格式为：</p><blockquote><p>返回值类型  operator 运算符名称 (形参表列){<br>    //TODO:<br>}</p></blockquote><p><kbd>operator</kbd>是关键字，专门用于定义重载运算符的函数。我们可以将<kbd>operator</kbd> 运算符名称这一部分看做函数名，对于上面的代码，函数名就是<kbd>operator+</kbd>。</p><p><strong>运算符重载函数除了函数名有特定的格式，其它地方和普通函数并没有区别。</strong></p><p>上面的例子中，我们在 complex 类中重载了运算符<kbd>+</kbd>，该重载只对 complex 对象有效。当执行<kbd>c3 = c1 + c2;</kbd>语句时，编译器检测到<kbd>+</kbd>号左边（<kbd>+</kbd>号具有左结合性，所以先检测左边）是一个 complex 对象，就会调用成员函数<kbd>operator+()</kbd>，也就是转换为下面的形式：</p><blockquote><p>c3 = c1.operator+(c2);</p></blockquote><p>c1 是要调用函数的对象，c2 是函数的实参。</p><p>上面的运算符重载还可以有更加简练的定义形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> <span class="built_in">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="keyword">this</span>-&gt;m_real + A.m_real, <span class="keyword">this</span>-&gt;m_imag + A.m_imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return 语句中的<kbd>complex(this->m_real + A.m_real, this->m_imag + A.m_imag)</kbd>会创建一个临时对象，这个对象没有名称，是一个<strong>匿名对象</strong>。在创建临时对象过程中调用构造函数，return 语句将该临时对象作为函数返回值。</p><h2 id="在全局范围内重载运算符"><a href="#在全局范围内重载运算符" class="headerlink" title="在全局范围内重载运算符"></a>在全局范围内重载运算符</h2><p><strong>运算符重载函数不仅可以作为类的成员函数，还可以作为全局函数</strong>。更改上面的代码，在全局范围内重载<kbd>+</kbd>，实现复数的加法运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//声明为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;</span><br><span class="line">    <span class="keyword">double</span> m_imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B);</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在全局范围内重载+</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real + B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag + B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="built_in">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符重载函数不是 complex 类的成员函数，但是却用到了 complex 类的 private 成员变量，所以必须在 complex 类中将该函数声明为友元函数.</p><p>执行<kbd>c3 = c1 + c2;</kbd>语句时，编译器检测到+号两边都是 complex 对象，就会转换为类似下面的函数调用：</p><blockquote><p>c3 = operator+(c1, c2);</p></blockquote><h1 id="C-运算符重载时要遵循的规则"><a href="#C-运算符重载时要遵循的规则" class="headerlink" title="C++运算符重载时要遵循的规则"></a>C++运算符重载时要遵循的规则</h1><p>运算符重载是通过函数重载实现的，概念上大家都很容易理解，这节主要来说一下运算符重载的注意事项。</p><p>1) 并不是所有的运算符都可以重载。能够重载的运算符包括：<br>+  -  *  /  %  ^  &amp;  |  ~  !  =  &lt;  &gt;  +=  -=  *=  /=  %=  ^=  &amp;=  |=  &lt;&lt;  &gt;&gt;  &lt;&lt;=  &gt;&gt;=  ==  !=  &lt;=  &gt;=  &amp;&amp;  ||  ++  –  ,  -&gt;*  -&gt;  ()  []  new  new[]  delete  delete[]</p><p>上述运算符中，<kbd>[]</kbd>是下标运算符，<kbd>()</kbd>是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符<kbd>sizeof</kbd>、条件运算符<kbd>: ?</kbd>、成员选择符<kbd>.</kbd>和域解析运算符<kbd>::</kbd>不能被重载。</p><p>2) 重载不能改变运算符的优先级和结合性。假设上一节的 complex 类中重载了<kbd>+</kbd>号和<kbd>*</kbd>号，并且 c1、c2、c3、c4 都是 complex 类的对象，那么下面的语句：</p><blockquote><p>c4 = c1 + c2 * c3;</p></blockquote><p>等价于：</p><blockquote><p>c4 = c1 + ( c2 * c3 );</p></blockquote><p>乘法的优先级仍然高于加法，并且它们仍然是二元运算符。</p><p>3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。例如<kbd>~</kbd>号右边只有一个操作数，<kbd>+</kbd>号总是出现在两个操作数之间，重载后也必须如此。</p><p>4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。</p><p>5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。</p><p><strong>将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。</strong></p><p>例如，上节的 complex 类中重载了加法运算符：</p><blockquote><p>complex operator+(const complex &amp; A) const;</p></blockquote><p>当执行：</p><blockquote><p>c3 = c1 + c2;</p></blockquote><p>会被转换为：</p><blockquote><p>c3 = c1.operator+(c2);</p></blockquote><p>通过 this 指针隐式的访问 c1 的成员变量。</p><p><strong>将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。</strong></p><p>例如，下面这样是不对的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> + (<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> (a-b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><kbd>+</kbd>号原来是对两个数相加，现在企图通过重载使它的作用改为两个数相减， 如果允许这样重载的话，那么表达式<kbd>4+3</kbd>的结果是 7 还是 1 呢？显然，这是绝对禁止的。</p><p>如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是C ++内置类型的数据，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">int</span> a, <span class="built_in">complex</span> &amp;c)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a+c.real, c.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是使一个整数和一个复数相加。</p><p>另外，将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数。原因很简单，该函数大部分情况下都需要使用类的 private 成员。</p><p>上节的最后一个例子中，我们在全局范围内重载了<kbd>+</kbd>号，并在 complex 类中将运算符重载函数声明为友元函数，因为该函数使用到了 complex 类的 m_real 和 m_imag 两个成员变量，它们都是 private 属性的，默认不能在类的外部访问。</p><p>6) 箭头运算符<kbd>-></kbd>、下标运算符<kbd>[ ]</kbd>、函数调用运算符<kbd>( )</kbd>、赋值运算符<kbd>=</kbd>只能以成员函数的形式重载。</p><h1 id="C-重载数学运算符（实例演示）"><a href="#C-重载数学运算符（实例演示）" class="headerlink" title="C++重载数学运算符（实例演示）"></a>C++重载数学运算符（实例演示）</h1><p>四则运算符（+、-、*、/、+=、-=、*=、/=）和关系运算符（&gt;、&lt;、&lt;=、&gt;=、==、!=）都是数学运算符，它们在实际开发中非常常见，被重载的几率也很高，并且有着相似的重载格式。本节以复数类 Complex 为例对它们进行重载，重在演示运算符重载的语法以及规范。</p><p>复数能够进行完整的四则运算，但不能进行完整的关系运算：我们只能判断两个复数是否相等，但不能比较它们的大小，所以不能对 &gt;、&lt;、&lt;=、&gt;= 进行重载。下面是具体的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//构造函数</span></span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="comment">//以全局函数的形式重载</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="comment">//以成员函数的形式重载</span></span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_imag; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real - c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag - c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符  (a+bi) * (c+di) = (ac-bd) + (bc+ad)i</span></span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real * c2.m_real - c1.m_imag * c2.m_imag;</span><br><span class="line">    c.m_imag = c1.m_imag * c2.m_real + c1.m_real * c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载/运算符  (a+bi) / (c+di) = [(ac+bd) / (c²+d²)] + [(bc-ad) / (c²+d²)]i</span></span><br><span class="line">Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) / (<span class="built_in">pow</span>(c2.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c2.m_imag, <span class="number">2</span>));</span><br><span class="line">    c.m_imag = (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) / (<span class="built_in">pow</span>(c2.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c2.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载!=运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real += c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag += c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real -= c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag -= c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real = <span class="keyword">this</span>-&gt;m_real * c.m_real - <span class="keyword">this</span>-&gt;m_imag * c.m_imag;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag = <span class="keyword">this</span>-&gt;m_imag * c.m_real + <span class="keyword">this</span>-&gt;m_real * c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载/=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real = (<span class="keyword">this</span>-&gt;m_real*c.m_real + <span class="keyword">this</span>-&gt;m_imag*c.m_imag) / (<span class="built_in">pow</span>(c.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag = (<span class="keyword">this</span>-&gt;m_imag*c.m_real - <span class="keyword">this</span>-&gt;m_real*c.m_imag) / (<span class="built_in">pow</span>(c.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">25</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">4</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c5</span><span class="params">(<span class="number">34</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c6</span><span class="params">(<span class="number">80</span>, <span class="number">90</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    Complex c7 = c1 + c2;</span><br><span class="line">    Complex c8 = c1 - c2;</span><br><span class="line">    Complex c9 = c1 * c2;</span><br><span class="line">    Complex c10 = c1 / c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c7 = "</span>&lt;&lt;c7.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c7.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c8 = "</span>&lt;&lt;c8.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c8.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c9 = "</span>&lt;&lt;c9.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c9.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c10 = "</span>&lt;&lt;c10.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c10.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    c3 += c1;</span><br><span class="line">    c4 -= c2;</span><br><span class="line">    c5 *= c2;</span><br><span class="line">    c6 /= c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c3 = "</span>&lt;&lt;c3.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c3.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 = "</span>&lt;&lt;c4.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c4.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c5 = "</span>&lt;&lt;c5.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c5.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c6 = "</span>&lt;&lt;c6.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c6.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(c1 == c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 == c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c1 != c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 != c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>c7 = 35 + 55i<br>c8 = 15 + 15i<br>c9 = -450 + 850i<br>c10 = 1.9 + -0.3i<br>c3 = 26 + 37i<br>c4 = -6 + -11i<br>c5 = 220 + 4460i<br>c6 = 5.2 + 1.592i<br>c1 != c2   </p></blockquote><p>需要注意的是，我们以全局函数的形式重载了 +、-、*、/、==、!=，以成员函数的形式重载了 +=、-=、*=、/=，而且应该坚持这样做，不能一股脑都写作成员函数或者全局函数</p><h2 id="C-重载-gt-gt-和-lt-lt-（输入和输出运算符）详解"><a href="#C-重载-gt-gt-和-lt-lt-（输入和输出运算符）详解" class="headerlink" title="C++重载&gt;&gt;和&lt;&lt;（输入和输出运算符）详解"></a>C++重载&gt;&gt;和&lt;&lt;（输入和输出运算符）详解</h2><ul><li>重载输入运算符&gt;&gt;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, <span class="built_in">complex</span> &amp;A)&#123;</span><br><span class="line">    in &gt;&gt; A.m_real &gt;&gt; A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们以全局函数的形式重载&gt;&gt;，使它能够读入两个 double 类型的数据，并分别赋值给复数的实部和虚部：</p><p>istream 表示输入流，cin 是 istream 类的对象，只不过这个对象是在标准库中定义的。<strong>之所以返回 istream 类对象的引用，是为了能够连续读取复数</strong>，让代码书写更加漂亮，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> c1, c2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c1&gt;&gt;c2;</span><br></pre></td></tr></table></figure><p>如果不返回引用，那就只能一个一个地读取了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> c1, c2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c1;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c2;</span><br></pre></td></tr></table></figure><p>当输入 1.45 2.34↙ 后，这两个小数就分别成为对象 c 的实部和虚部了。</p><blockquote><p>cin&gt;&gt; c;</p></blockquote><p>这一语句其实可以理解为：</p><blockquote><p>operator&lt;&lt;(cin , c);</p></blockquote><ul><li>重载输出运算符&lt;&lt;</li></ul><p>同样地，我们也可以模仿上面的形式对输出运算符&gt;&gt;进行重载，让它能够输出复数，请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="built_in">complex</span> &amp;A)&#123;</span><br><span class="line">    out &lt;&lt; A.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; A.m_imag &lt;&lt;<span class="string">" i "</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ostream 表示输出流，cout 是 ostream 类的对象。由于采用了引用的方式进行参数传递，并且也返回了对象的引用，所以重载后的运算符可以实现连续输出。</p><p>为了能够直接访问 complex 类的 private 成员变量，同样需要将该函数声明为 complex 类的友元函数：</p><blockquote><p>friend ostream &amp; operator&lt;&lt;(ostream &amp;out, complex &amp;A);</p></blockquote><p>综合演示:</p><p>结合输入输出运算符的重载，重新实现 complex 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in, <span class="built_in">complex</span> &amp; A);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; out, <span class="built_in">complex</span> &amp; A);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载加法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real + B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag + B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载减法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real - B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag - B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载乘法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real * B.m_real - A.m_imag * B.m_imag;</span><br><span class="line">    C.m_imag = A.m_imag * B.m_real + A.m_real * B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载除法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    <span class="keyword">double</span> square = A.m_real * A.m_real + A.m_imag * A.m_imag;</span><br><span class="line">    C.m_real = (A.m_real * B.m_real + A.m_imag * B.m_imag)/square;</span><br><span class="line">    C.m_imag = (A.m_imag * B.m_real - A.m_real * B.m_imag)/square;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输入运算符</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in, <span class="built_in">complex</span> &amp; A)&#123;</span><br><span class="line">    in &gt;&gt; A.m_real &gt;&gt; A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输出运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; out, <span class="built_in">complex</span> &amp; A)&#123;</span><br><span class="line">    out &lt;&lt; A.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; A.m_imag &lt;&lt;<span class="string">" i "</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">complex</span> c1, c2, c3;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c1&gt;&gt;c2;</span><br><span class="line"> </span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 + c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c3 = c1 - c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 - c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c3 = c1 * c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 * c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c3 = c1 / c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 / c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>2.4 3.6↙<br>4.8 1.7↙<br>c1 + c2 = 7.2 + 5.3 i<br>c1 - c2 = -2.4 + 1.9 i<br>c1 * c2 = 5.4 + 21.36 i<br>c1 / c2 = 0.942308 + 0.705128 i   </p></blockquote><h2 id="C-重载-（下标运算符"><a href="#C-重载-（下标运算符" class="headerlink" title="C++重载[]（下标运算符)"></a>C++重载[]（下标运算符)</h2><p>C++ 规定，下标运算符[ ]必须以成员函数的形式进行重载。该重载函数在类中的声明格式如下：</p><blockquote><p>返回值类型 &amp; operator[ ] (参数);</p></blockquote><p>或者：</p><blockquote><p>const 返回值类型 &amp; operator[ ] (参数) const;</p></blockquote><p>使用第一种声明方式，[ ]不仅可以访问元素，还可以修改元素。使用第二种声明方式，[ ]只能访问而不能修改元素。在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为通过 const 对象只能调用 const 成员函数，如果不提供第二种形式，那么将无法访问 const 对象的任何元素。</p><p>下面我们通过自定义的 Array 类来实现变长数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> length = <span class="number">0</span>);</span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;  <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> *m_p;  <span class="comment">//指向数组内存的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> length): m_length(length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">        m_p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m_p = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Array::display</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == m_length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;m_p[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;m_p[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="function">Array <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = A.length(); i &lt; len; i++)&#123;</span><br><span class="line">        A[i] = i * <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A.<span class="built_in">display</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">const</span> Array <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;B[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问最后一个元素</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>5↙<br>0, 5, 10, 15, 20<br>33685536   </p></blockquote><p>重载[ ]运算符以后，表达式arr[i]会被转换为：</p><blockquote><p>arr.operator<a href="i"> </a>;</p></blockquote><p>需要说明的是，B 是 const 对象，如果 Array 类没有提供 const 版本的operator[ ]，那么第 60 行代码将报错。虽然第 60 行代码只是读取对象的数据，并没有试图修改对象，但是它调用了非 const 版本的operator[ ]，编译器不管实际上有没有修改对象，只要是调用了非 const 的成员函数，编译器就认为会修改对象（至少有这种风险）。</p><h2 id="C-重载-和–（自增和自减运算符）"><a href="#C-重载-和–（自增和自减运算符）" class="headerlink" title="C++重载++和–（自增和自减运算符）"></a>C++重载++和–（自增和自减运算符）</h2><p>自增++和自减–都是一元运算符，它的前置形式和后置形式都可以被重载。如下例所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//秒表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stopwatch</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stopwatch(): m_min(<span class="number">0</span>), m_sec(<span class="number">0</span>)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setzero</span><span class="params">()</span></span>&#123; m_min = <span class="number">0</span>; m_sec = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">stopwatch <span class="title">run</span><span class="params">()</span></span>;  <span class="comment">// 运行</span></span><br><span class="line">    stopwatch <span class="keyword">operator</span>++();  <span class="comment">//++i，前置形式</span></span><br><span class="line">    stopwatch <span class="keyword">operator</span>++(<span class="keyword">int</span>);  <span class="comment">//i++，后置形式</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;( ostream &amp;, <span class="keyword">const</span> stopwatch &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_min;  <span class="comment">//分钟</span></span><br><span class="line">    <span class="keyword">int</span> m_sec;  <span class="comment">//秒钟</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">stopwatch <span class="title">stopwatch::run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ++m_sec;</span><br><span class="line">    <span class="keyword">if</span>(m_sec == <span class="number">60</span>)&#123;</span><br><span class="line">        m_min++;</span><br><span class="line">        m_sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopwatch stopwatch::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopwatch stopwatch::<span class="keyword">operator</span>++(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    stopwatch s = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;( ostream &amp; out, <span class="keyword">const</span> stopwatch &amp; s)&#123;</span><br><span class="line">    out&lt;&lt;setfill(<span class="string">'0'</span>)&lt;&lt;setw(<span class="number">2</span>)&lt;&lt;s.m_min&lt;&lt;<span class="string">":"</span>&lt;&lt;setw(<span class="number">2</span>)&lt;&lt;s.m_sec;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stopwatch s1, s2;</span><br><span class="line"></span><br><span class="line">    s1 = s2++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s1: "</span>&lt;&lt; s1 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s2: "</span>&lt;&lt; s2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    s1.setzero();</span><br><span class="line">    s2.setzero();</span><br><span class="line"></span><br><span class="line">    s1 = ++s2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s1: "</span>&lt;&lt; s1 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s2: "</span>&lt;&lt; s2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>s1: 00:00<br>s2: 00:01<br>s1: 00:01<br>s2: 00:01   </p></blockquote><p>上面的代码定义了一个简单的秒表类，m_min 表示分钟，m_sec 表示秒钟，setzero() 函数用于秒表清零，run() 函数是用来描述秒针前进一秒的动作，接下来是三个运算符重载函数。</p><p>先来看一下 run() 函数的实现，run() 函数一开始让秒针自增，如果此时自增结果等于60了，则应该进位，分钟加1，秒针置零。</p><p>operator++() 函数实现自增的前置形式，直接返回 run() 函数运行结果即可。</p><p>operator++ (int n) 函数实现自增的后置形式，返回值是对象本身，但是之后再次使用该对象时，对象自增了，所以在该函数的函数体中，先将对象保存，然后调用一次 run() 函数，之后再将先前保存的对象返回。在这个函数中参数n是没有任何意义的，它的存在只是为了区分是前置形式还是后置形式。</p><p>自减运算符的重载与上面类似</p><h2 id="C-重载"><a href="#C-重载" class="headerlink" title="C++重载()"></a>C++重载()</h2><p>在 C++ 中，类型的名字（包括类的名字）本身也是一种运算符，即类型强制转换运算符。</p><p>类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。经过适当重载后，(类型名)对象这个对对象进行强制类型转换的表达式就等价于 <kbd>对象.operator 类型名()</kbd> ，即变成对运算符函数的调用。</p><p>下面的程序对 double 类型强制转换运算符进行了重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) :real(r), imag(i) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> real; &#125;  <span class="comment">//重载强制类型转换运算符 double</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1.2</span>, <span class="number">3.4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">double</span>)c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1.2</span></span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">2</span> + c;  <span class="comment">//等价于 double n = 2 + c. operator double()</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;  <span class="comment">//输出 3.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序的输出结果是：<br>1.2<br>3.2   </p></blockquote><p>第 8 行对 double 运算符进行了重载。重载强制类型转换运算符时，不需要指定返回值类型，因为返回值类型是确定的，就是运算符本身代表的类型，在这里就是 double。</p><p>重载后的效果是，第 13 行的 (double)c 等价于 c.operator double()。</p><p>有了对 double 运算符的重载，在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用。</p><p>例如第 14 行，编译器认为本行中c这个位置如果出现的是 double 类型的数据，就能够解释得通，而 Complex 类正好重载了 double 运算符，因而本行就等价于：</p><blockquote><p>double n = 2 + c.operator double();</p></blockquote><h2 id="C-运算符重载注意事项以及汇总"><a href="#C-运算符重载注意事项以及汇总" class="headerlink" title="C++运算符重载注意事项以及汇总"></a>C++运算符重载注意事项以及汇总</h2><p>在 C++ 中进行运算符重载时，有以下问题需要注意：</p><ul><li>重载后运算符的含义应该符合原有用法习惯。例如重载+运算符，完成的功能就应该类似于做加法，在重载的+运算符中做减法是不合适的。此外，重载应尽量保留运算符原有的特性。</li><li>C++ 规定，运算符重载不改变运算符的优先级。</li><li>以下运算符不能被重载：<kbd>.</kbd>、<kbd>.*</kbd>、<kbd>::</kbd>、<kbd>? :</kbd>、<kbd>sizeof</kbd>。</li><li>重载运算符<kbd>()</kbd>、<kbd>[]</kbd>、<kbd>-></kbd>、或者赋值运算符<kbd>=</kbd>时，只能将它们重载为成员函数，不能重载为全局函数。</li></ul><p>运算符重载的实质是将运算符重载为一个函数，使用运算符的表达式就被解释为对重载函数的调用。</p><p>运算符可以重载为全局函数。此时函数的参数个数就是运算符的操作数个数，运算符的操作数就成为函数的实参。</p><p>运算符也可以重载为成员函数。此时函数的参数个数就是运算符的操作数个数减一，运算符的操作数有一个成为函数作用的对象，其余的成为函数的实参。</p><p>必要时需要重载赋值运算符=，以避免两个对象内部的指针指向同一片存储空间。</p><p>运算符可以重载为全局函数，然后声明为类的友元。</p><p>&lt;&lt; 和 &gt;&gt;是在 iostream 中被重载，才成为所谓的“流插入运算符”和“流提取运算符”的。</p><p>类型的名字可以作为强制类型转换运算符，也可以被重载为类的成员函数。它能使得对象被自动转换为某种类型。</p><p>自增、自减运算符各有两种重载方式，用于区别前置用法和后置用法。</p><p>运算符重载不改变运算符的优先级。重载运算符时，应该尽量保留运算符原本的特性。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 运算符重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串操作</title>
      <link href="/2020/05/06/c-string/"/>
      <url>/2020/05/06/c-string/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h2><p>有了 string 类，我们可以使用 <strong>+</strong> 或 <strong>+=</strong> 运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的 strcat()、strcpy()、malloc() 等函数来拼接字符串了，再也不用担心空间不够会溢出了。</p><p>用+来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个字符数组，或者是一个 string 字符串和一个单独的字符。请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first "</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"second "</span>;</span><br><span class="line">    <span class="keyword">char</span> *s3 = <span class="string">"third "</span>;</span><br><span class="line">    <span class="keyword">char</span> s4[] = <span class="string">"fourth "</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'@'</span>;</span><br><span class="line">    <span class="built_in">string</span> s5 = s1 + s2;</span><br><span class="line">    <span class="built_in">string</span> s6 = s1 + s3;</span><br><span class="line">    <span class="built_in">string</span> s7 = s1 + s4;</span><br><span class="line">    <span class="built_in">string</span> s8 = s1 + ch;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s5&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s6&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s7&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s8&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果:<br> first second<br> first third<br> first fourth<br> first @</p></blockquote><h2 id="string-字符串的增删改查"><a href="#string-字符串的增删改查" class="headerlink" title="string 字符串的增删改查"></a>string 字符串的增删改查</h2><p>C++ 提供的 string 类包含了若干实用的成员函数，大大方便了字符串的增加、删除、更改、查询等操作。</p><h3 id="一-插入字符串"><a href="#一-插入字符串" class="headerlink" title="一. 插入字符串"></a>一. 插入字符串</h3><p>insert() 函数可以在 string 字符串中指定的位置插入另一个字符串，它的一种原型为：</p><figure class="highlight plain"><figcaption><span>insert (size_t pos, const string& str);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;pos 表示要插入的位置，也就是下标；str 表示要插入的字符串，它可以是 string 字符串，也可以是C风格的字符串。</span><br><span class="line"></span><br><span class="line">请看下面的代码：</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 &#x3D; s2 &#x3D; &quot;1234567890&quot;;</span><br><span class="line">    s3 &#x3D; &quot;aaa&quot;;</span><br><span class="line">    s1.insert(5, s3);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    s2.insert(5, &quot;bbb&quot;);</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>12345aaa67890<br>12345bbb67890</p></blockquote><p>insert() 函数的第一个参数有越界的可能，如果越界，则会产生运行时异常。</p><h3 id="二-删除字符串"><a href="#二-删除字符串" class="headerlink" title="二. 删除字符串"></a>二. 删除字符串</h3><p>erase() 函数可以删除 string 中的一个子字符串。它的一种原型为：</p><figure class="highlight plain"><figcaption><span>erase (size_t pos </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;pos 表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len &#x3D; str.length - pos）。</span><br><span class="line"></span><br><span class="line">请看下面的代码：</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 &#x3D; s2 &#x3D; s3 &#x3D; &quot;1234567890&quot;;</span><br><span class="line">    s2.erase(5);</span><br><span class="line">    s3.erase(5, 3);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s3 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>1234567890<br>12345<br>1234590</p></blockquote><p>可能会有这样的担心，在 pos 参数没有越界的情况下， len 参数也可能会导致要删除的子字符串越界。但实际上这种情况不会发生，erase() 函数会从以下两个值中取出最小的一个作为待删除子字符串的长度：</p><blockquote><p>len 的值<br>字符串长度减去 pos 的值。</p></blockquote><p>说得简单一些，待删除字符串最多只能删除到字符串结尾。</p><h3 id="三-提取子字符串"><a href="#三-提取子字符串" class="headerlink" title="三. 提取子字符串"></a>三. 提取子字符串</h3><p>substr() 函数用于从 string 字符串中提取子字符串，它的原型为：</p><figure class="highlight plain"><figcaption><span>substr (size_t pos </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。</span><br><span class="line"></span><br><span class="line">请看下面的代码：</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1 &#x3D; &quot;first second third&quot;;</span><br><span class="line">    string s2;</span><br><span class="line">    s2 &#x3D; s1.substr(6, 6);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br> first second third<br> second</p></blockquote><p>系统对 substr() 参数的处理和 erase() 类似：</p><ul><li>如果 pos 越界，会抛出异常；</li><li>如果 len 越界，会提取从 pos 到字符串结尾处的所有字符。</li></ul><h3 id="四-字符串查找"><a href="#四-字符串查找" class="headerlink" title="四. 字符串查找"></a>四. 字符串查找</h3><p>string 类提供了几个与字符串查找有关的函数，如下所示。<br><strong>1)  find() 函数</strong><br>find() 函数用于在 string 字符串中查找子字符串出现的位置，它其中的两种原型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t find (const string&amp; str, size_t pos &#x3D; 0) const;  </span><br><span class="line">size_t find (const char* s, size_t pos &#x3D; 0) const;</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。</p></blockquote><p>请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first second third"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"second"</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.<span class="built_in">find</span>(s2,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.length())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Found at index : "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Found at index : 6</p></blockquote><p>find() 函数最终返回的是子字符串第一次出现在字符串中的起始下标。本例最终是在下标6处找到了 s2 字符串。如果没有查找到子字符串，那么会返回一个无穷大值 4294967295。</p><p><strong>2) rfind() 函数</strong>   </p><p>rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。</p><p>请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first second third"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"second"</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.rfind(s2,<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.length())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Found at index : "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Found at index : 6   </p></blockquote><p><strong>3) find_first_of() 函数</strong>  </p><p><strong>find_first_of()</strong> 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first second second third"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"asecond"</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.find_first_of(s2);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.length())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Found at index : "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Found at index : 3</p></blockquote><p>本例中 s1 和 s2 共同具有的字符是 ’s’，该字符在 s1 中首次出现的下标是3，故查找结果返回3。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表总结</title>
      <link href="/2020/05/04/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/04/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><strong>链表的定义（来自维基百科）</strong>：</p><p>在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（“links”）。</p><p><strong>链表与顺序表的区别（来自维基百科）</strong>：</p><p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p><p><strong>顺序表与数组的区别</strong>：</p><p>顺序表是在计算机内存中以数组的形式保存的线性表。</p><p>顺序表是指用一组地址连续的存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表，顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。线性表采用指针链接的方式存储就称之为链表。</p><p>线性表是从逻辑结构的角度来说的，除了头和尾之外，它的每一个元素都只有一个前驱元素和一个后驱元素。各种队列（单向、双向、循环队列），栈等都是线性表的不同例子。</p><p>而数组是从物理存贮的角度来说的，线性表可以用数组存贮也可以用链表来存贮。同样的队列和栈也可以用数组和链表存贮，各有利弊。具体使用时，根据具体情况选择。 </p><p>所以说，数组是一个更大的概念。使用数组，不但可以存储线性表，也可存储非线性结构的数据结构。比如堆、完全二叉树、乃至于其它类型的树、图等。</p><p>顺序表与数组都是数据结构，只是描述角度不同。顺序表是从逻辑结构的角度来说的，它的每一个元素都只有一个前驱元素和一个后驱元素除了头和尾，逻辑结构还有队列，堆栈，树，图等。而数组是从物理存贮的角度来说的，顺序表用数组存贮也可以用链表来存贮。同样的队列也可以用数组和链表存贮，各有利弊。具体使用时，根据具体情况选择。</p><ol><li><p>数组就是相同数据类型的元素按一定顺序排列的集合。</p><p>一句话：就是物理上存储在一组联系的地址上。也称为数据结构中的物理结构。</p></li><li><p>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。</p><p>一句话：线性表是数据结构中的逻辑结构。可以存储在数组上，也可以存储在链表上。</p></li><li><p>线性表的结点按逻辑次序依次存放在一组地址连续的存储单元里的方法。用顺序存储方法存储的线性表简称为顺序表。</p><p>一句话：用数组来存储的线性表就是顺序表。</p></li></ol><p><strong>链表的优缺点（来自维基百科）</strong>：</p><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。<br>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p><p><strong>链表的类型（来自维基百科）</strong>：</p><p>单向链表，双向链表以及循环链表。</p><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p><strong>单向链表的定义：</strong></p><p>单向链表是链表类型中最为简单的一种，每个节点包含两个域，一个数据域(data)，一个指针域(next)。单向链表的next节点指向下一节点，而尾节点的next节点为空。</p><p><strong>单向链表节点的定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504153648.png" alt="20200504153648"></p><p><strong>单链表的模板：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListForward</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode* head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyListForward():head(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获得链表中第index个节点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p)<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果为第index节点值为空值则返回-1；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、在链表头部插一个值为val的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode *p=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        p-&gt;next=head;</span><br><span class="line">        head=p;<span class="comment">//更换头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、在链表尾部添加一个值为val的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode *p=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="comment">//链表为空，直接将新节点作为头节点</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head=p;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *q=head;</span><br><span class="line">        <span class="comment">//遍历直到q的next节点为空</span></span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next)&#123;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、在索引为index的节点之前添加值为val的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="comment">//1、index小于等于0，直接在头部插入节点</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">//若index小于等于0，我们仅需要在头节点前面插入新节点就行了</span></span><br><span class="line">        <span class="comment">//注意这里不能使用指针p，因为p=node时，p所指向的地址发生了变化，head指向的地址没有变化，所以我们这里要使用指针head</span></span><br><span class="line">            node-&gt;next=head;</span><br><span class="line">            head=node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="comment">//在索引为index的节点之前插入新节点，我们需要找到它的前驱节点，然后插入在它的前驱节点后面</span></span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、p为索引节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next=p-&gt;next;</span><br><span class="line">            p-&gt;next=node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、删除索引为index的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、index为0，我们直接删除head节点</span></span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>&amp;&amp;head!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *del=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="comment">//删除索引为index的节点，我们需要找到它的前驱节点p，p-&gt;next为需要删除节点</span></span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、index超过链表范围，删除失败</span></span><br><span class="line">        <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//3、index的位置合法，我们找到需要删除的p-&gt;next节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *del=p-&gt;next;</span><br><span class="line">            p-&gt;next=del-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、清空链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ListNode *del=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            del=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyListForward mlf;</span><br><span class="line">    mlf.addAtIndex(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    mlf.addAtIndex(<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">    mlf.addAtIndex(<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mlf.length();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mlf.<span class="built_in">get</span>(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    mlf.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;mlf.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><strong>双向链表的定义：</strong></p><p>双向链表是一种更为复杂的链表，每个节点包含三个域，一个数据域(data)和两个指针域(prev、next)，其中数据域存放节点的数值，prev指向该节点的前一个节点，next指向该节点的后一个节点。</p><p><strong>双向链表节点的定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next,*prev;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>),prev(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504155110.png" alt="20200504155110"></p><p><strong>双向链表的模板：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *next,*prev;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>),prev(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//头节点尾节点都为空，表示为空链表</span></span><br><span class="line">    ListNode *head,*tail;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyList():<span class="built_in">size</span>(<span class="number">0</span>),head(<span class="literal">nullptr</span>),tail(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获得索引为index的节点值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p)<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、在头部插入值为val的新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            node-&gt;next=head;</span><br><span class="line">            head-&gt;prev=node;</span><br><span class="line">            head=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            tail=head;</span><br><span class="line">        &#125;</span><br><span class="line">        ++<span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、在尾部插入值为val的新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            node-&gt;prev=tail;</span><br><span class="line">            tail-&gt;next=node;</span><br><span class="line">            tail=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//尾节点为空，那么头节点也为空，然后首尾节点都为新节点</span></span><br><span class="line">            tail=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            head=tail;</span><br><span class="line">        &#125;</span><br><span class="line">        ++<span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、在index之前添加值为val的新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先排除三种特殊情况的index，然后剩下来的index肯定在链表内</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="built_in">size</span>)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;<span class="built_in">size</span>)<span class="keyword">return</span>;</span><br><span class="line">        ListNode *p=<span class="literal">nullptr</span>,*cur=head;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur&amp;&amp;i&lt;index)&#123;</span><br><span class="line">            p=cur;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="comment">//由于前面已经将特殊情况的index排除了，现在的p和cur都有效，都在链表内</span></span><br><span class="line">        p-&gt;next=node;</span><br><span class="line">        node-&gt;prev=p;</span><br><span class="line">        node-&gt;next=cur;</span><br><span class="line">        cur-&gt;prev=node;</span><br><span class="line">        <span class="built_in">size</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、删除索引为index的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//链表为空时，不能删除</span></span><br><span class="line">        <span class="keyword">if</span>(!head)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *del=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(head)&#123;<span class="comment">//链表有2个以上节点</span></span><br><span class="line">                head-&gt;prev=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//链表只有一个节点，将尾部制空</span></span><br><span class="line">                tail=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">            <span class="built_in">size</span>--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//index为最后为尾节点，我们需要删除尾节点</span></span><br><span class="line">        <span class="keyword">if</span>(index==<span class="built_in">size</span><span class="number">-1</span>)&#123;</span><br><span class="line">            ListNode *del=tail;</span><br><span class="line">            tail=tail-&gt;prev;</span><br><span class="line">            <span class="comment">//注意这里不用处理tail为空，因为tail为空的话，那么链表只有单个节点</span></span><br><span class="line">            <span class="comment">//然而单个节点只能删除0号节点，只有index为0时才能删除，前面已经处理过了index为0的情况了，所以这里不在处理</span></span><br><span class="line">            <span class="keyword">if</span>(tail)&#123;</span><br><span class="line">                tail-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">            <span class="built_in">size</span>--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=<span class="literal">nullptr</span>,*cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==index)&#123;</span><br><span class="line">                ListNode *del=cur;</span><br><span class="line">                p-&gt;next=cur-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next)&#123;</span><br><span class="line">                    cur-&gt;next-&gt;prev=p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> del;</span><br><span class="line">                <span class="built_in">size</span>--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=cur;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、获得链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、清空链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">size</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            deleteAtIndex(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyList ml;</span><br><span class="line">    ml.addAtHead(<span class="number">1</span>);</span><br><span class="line">    ml.addAtTail(<span class="number">3</span>);</span><br><span class="line">    ml.addAtHead(<span class="number">4</span>);</span><br><span class="line">    ml.addAtHead(<span class="number">5</span>);</span><br><span class="line">    ml.addAtIndex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ml.length();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ml.<span class="built_in">get</span>(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ml.deleteAtIndex(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ml.length();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ml.<span class="built_in">get</span>(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ml.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ml.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p><strong>环形链表的定义：</strong></p><p>循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存， 假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。<br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504155514.png" alt="20200504155514"></p><h1 id="习题解析"><a href="#习题解析" class="headerlink" title="习题解析"></a>习题解析</h1><h2 id="链表中的双指针技巧"><a href="#链表中的双指针技巧" class="headerlink" title="链表中的双指针技巧"></a>链表中的双指针技巧</h2><p><a href="https://xiaoneng.blog.csdn.net/article/details/97423144" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a>：<strong>快慢指针法</strong>，起始快指针走n步后，若此时快指针已为空，表示我们删除第一个节点，直接返回head-&gt;next即可；否则此时快慢指针一起走，也就是慢指针走size-n步到达倒数第N个节点的前驱节点，快指针会到达链表的尾节点，此时我们删除slow-&gt;next节点即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103322178" target="_blank" rel="noopener">86. 分隔链表</a>：<strong>双指针法</strong>，before_head链表存放比x小的节点，after_head链表存放比x大于或等于的节点，我们分别用before和after来前面两个链表添加节点，用head来遍历原始链表。当原始链表遍历完成时，我们需要将before_head链表连接上after_head链表，即before-&gt;next=after_head-&gt;next;after-&gt;next=nullptr;。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/103648554" target="_blank" rel="noopener">92. 反转链表 II</a>：<strong>双指针法</strong>，指针pre指针指向m的前驱节点，用来将cur的next节点插入到pre后面，指针cur指向位置m起始节点，该节点保持不变，每次需要将cur连接上nxt后边的部分。换句话说，我们要将[m+1,n]的节点每次都要插到位置m之前，这样就完成了反转。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97416410" target="_blank" rel="noopener">141. 环形链表</a>：<strong>快慢指针法</strong>，若存在环最终快慢指针会相遇；若不存在环，那么快指针一定会先走到链表尾部。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97420675" target="_blank" rel="noopener">142. 环形链表 II</a>：<strong>快慢指针法</strong>，首先利用141的代码判断是否存在环，然后相遇之后将fast指针指向头节点，然后fast和slow现在开始每次走一步，相遇点就是环的入口。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103588663" target="_blank" rel="noopener">143. 重排链表</a>：<strong>首尾指针法</strong>，首先将原始链表的每一个节点存放在一个数组中，然后我们取首尾指针向中间遍历，每次循环我们需要将左指针的节点连上右指针的节点，在节点连上之后，我们需要将右指针连上未排序的首节点。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97421357" target="_blank" rel="noopener">160. 相交链表</a>：本题也属于<strong>快慢指针法</strong>，具体思路更抽象的说就是将链表AB分别变成了A-&gt;B和B-&gt;A（这里假设A更短一点），这里我们用ha遍历A-&gt;B，hb遍历B-&gt;A，然后ha指针先走到A-B的B部分，hb指针还在走在B-A的B部分，当hb走到B-A的A部分时，最终二者会相遇，而相遇部分就是公共部分。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103445269" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a>：<strong>快慢指针法</strong>，用两个指针，一块一慢，快的每次走两步，慢的每次走一步，这样当快指针遍历结束时，慢指针指向的也就是链表的中间位置。这时候把中间位置的节点的值作为二叉搜索树根节点的值。因为二叉搜索树对应的就是一个有序数组，根节点对应的元素值为为有序数组最中间的位置。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/100934558" target="_blank" rel="noopener">206. 反转链表</a>：<strong>双指针法</strong>，指针pre用来表示前驱节点，指针cur用来遍历链表，每次循环改变将pre-&gt;cur的方向改变为pre&lt;-cur，直到遍历结束。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/104034708" target="_blank" rel="noopener">234. 回文链表</a>：<strong>快慢指针法</strong>，快指针走两步，慢指针走一步，找到链表的中点。然后，翻转后半部分。最后从前半部分链表和后半部分链表是否相同。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103995590" target="_blank" rel="noopener">876. 链表的中间结点</a>：<strong>快慢指针法</strong>，快指针走两步，慢指针走一步，等快指针走到链表尾节点时，慢指针的位置就是中位数的位置。</p><h2 id="链表排序问题"><a href="#链表排序问题" class="headerlink" title="链表排序问题"></a>链表排序问题</h2><p><a href="https://blog.csdn.net/qq_43152052/article/details/103662802" target="_blank" rel="noopener">147. 对链表进行插入排序</a>：<strong>插入排序</strong>，我们每次用head-&gt;next来进行插入排序，每次插入排序，我们需要从链表的头部开始寻找插入点，所以我们使用一个指针pre来寻找插入点，若pre-&gt;next的节点值大于等于head-&gt;next的节点时，我们的插入位置就是pre-&gt;next，这里处理起来可能麻烦点，大家仔细看代码即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103661851" target="_blank" rel="noopener">148. 排序链表</a>：<strong>归并排序</strong>，先2个2个的 merge，完成一趟后，再 4个4个的 merge，直到结束。</p><h2 id="链表经典题目"><a href="#链表经典题目" class="headerlink" title="链表经典题目"></a>链表经典题目</h2><p><a href="https://blog.csdn.net/qq_43152052/article/details/89285335" target="_blank" rel="noopener">2. 两数相加</a>：<strong>模拟题</strong>，由于链表是逆序存放数字的，所以链表数字从左至右低位对低位，高位对高位，因此我们从左至右遍历两个链表模拟加法运算即可，注意向高位进位。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97426128" target="_blank" rel="noopener">21. 合并两个有序链表</a>：<strong>模拟题</strong>，每次循环比较l1-&gt;val和l2-&gt;val，若l1-&gt;val<l2->val，则在cur后面添加l1；否则在cur后面添加l2。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103183470" target="_blank" rel="noopener">23. 合并K个排序链表</a>：<strong>方法1：分治法</strong>，将k个链表利用二分分为k个独立子链表，然后两两进行合并，最后形成一个排序链表。<strong>方法2：优雅的暴力法</strong>，利用队列queue来实现两两链表的组合，首先将队列前两个链表合并成一个，然后添加到队列的尾部，直到队列中只有一个链表时，表示k个链表已经合成了。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/100888248" target="_blank" rel="noopener">24. 两两交换链表中的节点</a>：<strong>简单递归</strong>，每次递归交换head与nxt即可，也就是完成了两两交换链表中的节点。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103324877" target="_blank" rel="noopener">25. K 个一组翻转链表</a>：<strong>分治法</strong>，将链表按长度k进行分组，然后每次翻转长度k的链表，注意翻转了长度k的链表后新链表的尾部还要连接未翻转部分。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/89366849" target="_blank" rel="noopener">61. 旋转链表</a>：<strong>模拟题</strong>，先求出链表长度size，若k取余size为空，那么不用旋转了，直接返回head；否则将链表首尾相连形成环形链表，由于k表示尾节点移动k%size位，那么头节点移动size-k%size位。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103544889" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a>：<strong>模拟题</strong>，遍历链表，若head的节点值与head的next节点值不相等，则pre指向head，也就是不重复节点；若相等，我们需要找到重复值子链表的最后一个节点，然后令pre指向head-&gt;next，同时head移动到下一个节点。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103533398" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a>：<strong>模拟题</strong>，直接遍历链表，遇到重复值的节点删除即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/89323912" target="_blank" rel="noopener">138. 复制带随机指针的链表</a>：<strong>模拟题</strong>，分三步，第一步在原链表的每个节点后面拷贝出一个新的节点，第二步拷贝random，第三步断开链表。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/104033912" target="_blank" rel="noopener">203. 移除链表元素</a>：<strong>模拟题</strong>，直接遍历链表确定是否删除节点即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103996408" target="_blank" rel="noopener">445. 两数相加 II</a>：<strong>双栈法</strong>，将两个链表节点值全部压入栈中，然后每次去栈顶元素进行相加，因为这样保证了低位和低位相加，不会出现错位现象。最后直到两个栈为空且进位为0为止，就表示相加完成了。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103995776" target="_blank" rel="noopener">725. 分隔链表</a>：<strong>模拟题</strong>，首先求出链表的长度，然后根据k来求得每段链表的平均长度，顺便求出余数。由于题目要求每部分长度相差不能超过1，而且排在前面的部分长度要大于后面部分的长度，所以我们根据余数的个数，给排在前面的部分长度+1。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/89304371" target="_blank" rel="noopener">430. 扁平化多级双向链表</a>：<strong>模拟题</strong>，迭代法，遍历链表，若发现该链表存在child节点那么就将[child,tail]这段子链表插入到当前节点的后面去，然后继续遍历链表。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103997681" target="_blank" rel="noopener">817. 链表组件</a>：<strong>模拟题</strong>，如果当前的节点在列表G中，并且下一个节点不在列表G中，我们就找到了一个组件的尾节点，将res加1。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103997711" target="_blank" rel="noopener">1171. 从链表中删去总和值为零的连续节点</a>：<strong>模拟题</strong>，直接遍历链表进行删除和为0的连续子链表。</p><blockquote><p>文章转载：<a href="https://xiaoneng.blog.csdn.net/article/details/104007259" target="_blank" rel="noopener">algsup</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0502leetcode</title>
      <link href="/2020/05/02/0502leetcode/"/>
      <url>/2020/05/02/0502leetcode/</url>
      
        <content type="html"><![CDATA[<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><center><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502162145.png" alt="20200502162145"></p></center><p><strong>解题思路：</strong></p><center><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502162430.png" alt="20200502162430"></p></center><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">           fast =fast-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">               fast = fast-&gt;next; </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//else break;</span></span><br><span class="line">           slow =slow-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">               <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(fast == head)</span><br><span class="line">                   <span class="keyword">return</span> fast;</span><br><span class="line">                   fast = fast-&gt;next;</span><br><span class="line">                   head = head-&gt;next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h3><center><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502164548.png" alt="20200502164548"></p></center><p><strong>解题思路：</strong></p><ol><li><p>为链表设置虚拟头结点<strong>dummyhead</strong>，链表设置虚拟头结点dummyhead，这样对链表来说，第一个元素就是dummyhead的next所对应的节点元素，而不是dummyhead所对应的节点元素。dummyhead位置所对应的元素是根本不存在的，这只是未来我们编写逻辑方便而出现的一个虚拟头结点。dummyhead就是索引为0的这个位置的元素的前一个节点。当我们有了dummyhead后，为链表添加一个元素，就不需要对头结点进行特殊处理了，只需要找到等待添加位置的前一个位置的节点，<strong>此时对于链表来说，所有位置都有前一个节点。</strong></p></li><li><p>代码主要分为两部分，一部分负责切割链接，另一部分负责将切割下来的链表反转并将链表头指针返回。</p></li><li><p>Tail的使用</p></li></ol><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502171941.png" alt="20200502171941"></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span> || head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* Tail = dummy;<span class="comment">//Tail是当前已经确定的尾部</span></span><br><span class="line">        <span class="comment">//ListNode* Head = head;//还没有确定的首部</span></span><br><span class="line">        ListNode* p=head;<span class="comment">//游标</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (count &lt; k)) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; k) &#123;<span class="comment">//如果小于k个，则用上一个模块的Tail直接连接首部就可以</span></span><br><span class="line">                Tail-&gt;next = head;</span><br><span class="line">                <span class="keyword">return</span> dummy-&gt;next;<span class="comment">//输出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果不小于k个，</span></span><br><span class="line">                Tail-&gt;next = reversegroup(head, k);<span class="comment">//更新已经确定的尾部</span></span><br><span class="line">                <span class="keyword">while</span> (Tail-&gt;next != <span class="literal">NULL</span>)Tail = Tail-&gt;next;<span class="comment">//更新Tail，把Tail更新到指向为空</span></span><br><span class="line">                head = p;<span class="comment">//更新没有确定的首部</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reversegroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;<span class="comment">//从abcd变成bcda</span></span><br><span class="line">        ListNode* cur;</span><br><span class="line">        ListNode* tail;<span class="comment">//当前已经完成翻转的链表的第一个节点</span></span><br><span class="line">        ListNode* ahead;<span class="comment">//存储旧链表中cur指向的节点</span></span><br><span class="line">        tail = <span class="literal">nullptr</span>;</span><br><span class="line">        cur = <span class="literal">nullptr</span>;</span><br><span class="line">        ahead = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; k) &#123;</span><br><span class="line">            cur = ahead;</span><br><span class="line">            ahead = cur-&gt;next;<span class="comment">//存储旧链表中cur指向的节点</span></span><br><span class="line">            cur-&gt;next = tail;<span class="comment">//指向已经完成翻转的链表的第一个节点</span></span><br><span class="line">            tail = cur;<span class="comment">//更新tail</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        ahead-&gt;next = tail;</span><br><span class="line">        <span class="keyword">return</span> ahead;<span class="comment">//返回小模块的第一个节点，用以作为连接外层循环Tail指向的对象</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/05/01/test/"/>
      <url>/2020/05/01/test/</url>
      
        <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1111111</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/%E5%88%86%E7%B1%BB-%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B.png" alt="分类-守望先锋"></p><table><thead><tr><th>流操纵算子</th><th>作  用</th><th style="text-align:right"></th></tr></thead><tbody><tr><td>*dec</td><td>以十进制形式输出整数</td><td style="text-align:right" rowspan="13">常用</td></tr><tr><td>hex</td><td>以十六进制形式输出整数</td></tr><tr><td>oct</td><td>以八进制形式输出整数</td></tr><tr><td>fixed</td><td>以普通小数形式输出浮点数</td></tr><tr><td>scientific</td><td>以科学计数法形式输出浮点数</td></tr><tr><td>left</td><td>左对齐，即在宽度不足时将填充字符添加到右边</td></tr><tr><td>*right</td><td>右对齐，即在宽度不足时将填充字符添加到左边</td></tr><tr><td>setbase(b)</td><td>设置输出整数时的进制，b=8、10 或 16</td></tr><tr><td>setw(w)</td><td>指定输出宽度为 w 个字符，或输人字符串时读入 w 个字符</td></tr><tr><td>setfill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td></tr><tr><td>setprecision(n)</td><td>设置输出浮点数的精度为 n。在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</td></tr><tr><td>setiosflags(flag)</td><td>将某个输出格式标志置为 1</td></tr><tr><td>resetiosflags(flag)</td><td>将某个输出格式标志置为 0</td></tr><tr><td>boolapha</td><td>把 true 和 false 输出为字符串</td><td style="text-align:right" rowspan="13">不常用</td></tr><tr><td>*noboolalpha</td><td>把 true 和 false 输出为 0、1</td></tr><tr><td>showbase</td><td>输出表示数值的进制的前缀</td></tr><tr><td>*noshowbase</td><td>不输出表示数值的进制.的前缀</td></tr><tr><td>showpoint</td><td>总是输出小数点</td></tr><tr><td>*noshowpoint</td><td>只有当小数部分存在时才显示小数点</td></tr><tr><td>showpos</td><td>在非负数值中显示 +</td></tr><tr><td>*noshowpos</td><td>在非负数值中不显示 +</td></tr><tr><td>*skipws</td><td>输入时跳过空白字符</td></tr><tr><td>noskipws</td><td>输入时不跳过空白字符</td></tr><tr><td>uppercase</td><td>十六进制数中使用 A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td></tr><tr><td>*nouppercase</td><td>十六进制数中使用 a~e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。</td></tr><tr><td>internal</td><td>数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/01/hello-world/"/>
      <url>/2020/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
