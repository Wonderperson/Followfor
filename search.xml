<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c++的运算符重载</title>
      <link href="/2020/05/06/c-operator/"/>
      <url>/2020/05/06/c-operator/</url>
      
        <content type="html"><![CDATA[<h1 id="C-运算符重载基础教程"><a href="#C-运算符重载基础教程" class="headerlink" title="C++运算符重载基础教程"></a>C++运算符重载基础教程</h1><p>函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作。<strong>运算符重载（Operator Overloading）</strong> 也是一个道理，同一个运算符可以有不同的功能。</p><p>实际上，我们已经在不知不觉中使用了运算符重载。例如，<kbd>+</kbd>号可以对不同类型（int、float 等）的数据进行加法操作；<kbd><</kbd>既是位移运算符，又可以配合 cout 向控制台输出数据。C++ 本身已经对这些运算符进行了重载。</p><p>C++ 也允许程序员自己重载运算符.</p><p>下面的代码定义了一个复数类，通过运算符重载，可以用+号实现复数的加法运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//声明运算符重载</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A) <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现运算符重载</span></span><br><span class="line"><span class="built_in">complex</span> <span class="built_in">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="built_in">complex</span> B;</span><br><span class="line">    B.m_real = <span class="keyword">this</span>-&gt;m_real + A.m_real;</span><br><span class="line">    B.m_imag = <span class="keyword">this</span>-&gt;m_imag + A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="built_in">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>运行结果：6.7 + 9.5i</code></pre><p>本例中义了一个复数类 complex，m_real 表示实部，m_imag 表示虚部.</p><p>运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数。<strong>也就是说，运算符重载是通过函数实现的，它本质上是函数重载。</strong></p><p>运算符重载的格式为：</p><blockquote><p>返回值类型  operator 运算符名称 (形参表列){<br>    //TODO:<br>}</p></blockquote><p><kbd>operator</kbd>是关键字，专门用于定义重载运算符的函数。我们可以将<kbd>operator</kbd> 运算符名称这一部分看做函数名，对于上面的代码，函数名就是<kbd>operator+</kbd>。</p><p><strong>运算符重载函数除了函数名有特定的格式，其它地方和普通函数并没有区别。</strong></p><p>上面的例子中，我们在 complex 类中重载了运算符<kbd>+</kbd>，该重载只对 complex 对象有效。当执行<kbd>c3 = c1 + c2;</kbd>语句时，编译器检测到<kbd>+</kbd>号左边（<kbd>+</kbd>号具有左结合性，所以先检测左边）是一个 complex 对象，就会调用成员函数<kbd>operator+()</kbd>，也就是转换为下面的形式：</p><blockquote><p>c3 = c1.operator+(c2);</p></blockquote><p>c1 是要调用函数的对象，c2 是函数的实参。</p><p>上面的运算符重载还可以有更加简练的定义形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> <span class="built_in">complex</span>::<span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A)<span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="keyword">this</span>-&gt;m_real + A.m_real, <span class="keyword">this</span>-&gt;m_imag + A.m_imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return 语句中的<kbd>complex(this->m_real + A.m_real, this->m_imag + A.m_imag)</kbd>会创建一个临时对象，这个对象没有名称，是一个<strong>匿名对象</strong>。在创建临时对象过程中调用构造函数，return 语句将该临时对象作为函数返回值。</p><h2 id="在全局范围内重载运算符"><a href="#在全局范围内重载运算符" class="headerlink" title="在全局范围内重载运算符"></a>在全局范围内重载运算符</h2><p><strong>运算符重载函数不仅可以作为类的成员函数，还可以作为全局函数</strong>。更改上面的代码，在全局范围内重载<kbd>+</kbd>，实现复数的加法运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//声明为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;</span><br><span class="line">    <span class="keyword">double</span> m_imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B);</span><br><span class="line"></span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line"><span class="built_in">complex</span>::<span class="built_in">complex</span>(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complex::display</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m_real&lt;&lt;<span class="string">" + "</span>&lt;&lt;m_imag&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在全局范围内重载+</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp;A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real + B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag + B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">4.3</span>, <span class="number">5.8</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">complex</span> <span class="title">c2</span><span class="params">(<span class="number">2.4</span>, <span class="number">3.7</span>)</span></span>;</span><br><span class="line">    <span class="built_in">complex</span> c3;</span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符重载函数不是 complex 类的成员函数，但是却用到了 complex 类的 private 成员变量，所以必须在 complex 类中将该函数声明为友元函数.</p><p>执行<kbd>c3 = c1 + c2;</kbd>语句时，编译器检测到+号两边都是 complex 对象，就会转换为类似下面的函数调用：</p><blockquote><p>c3 = operator+(c1, c2);</p></blockquote><h1 id="C-运算符重载时要遵循的规则"><a href="#C-运算符重载时要遵循的规则" class="headerlink" title="C++运算符重载时要遵循的规则"></a>C++运算符重载时要遵循的规则</h1><p>运算符重载是通过函数重载实现的，概念上大家都很容易理解，这节主要来说一下运算符重载的注意事项。</p><p>1) 并不是所有的运算符都可以重载。能够重载的运算符包括：<br>+  -  *  /  %  ^  &amp;  |  ~  !  =  &lt;  &gt;  +=  -=  *=  /=  %=  ^=  &amp;=  |=  &lt;&lt;  &gt;&gt;  &lt;&lt;=  &gt;&gt;=  ==  !=  &lt;=  &gt;=  &amp;&amp;  ||  ++  –  ,  -&gt;*  -&gt;  ()  []  new  new[]  delete  delete[]</p><p>上述运算符中，<kbd>[]</kbd>是下标运算符，<kbd>()</kbd>是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符<kbd>sizeof</kbd>、条件运算符<kbd>: ?</kbd>、成员选择符<kbd>.</kbd>和域解析运算符<kbd>::</kbd>不能被重载。</p><p>2) 重载不能改变运算符的优先级和结合性。假设上一节的 complex 类中重载了<kbd>+</kbd>号和<kbd>*</kbd>号，并且 c1、c2、c3、c4 都是 complex 类的对象，那么下面的语句：</p><blockquote><p>c4 = c1 + c2 * c3;</p></blockquote><p>等价于：</p><blockquote><p>c4 = c1 + ( c2 * c3 );</p></blockquote><p>乘法的优先级仍然高于加法，并且它们仍然是二元运算符。</p><p>3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。例如<kbd>~</kbd>号右边只有一个操作数，<kbd>+</kbd>号总是出现在两个操作数之间，重载后也必须如此。</p><p>4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。</p><p>5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。</p><p><strong>将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。</strong></p><p>例如，上节的 complex 类中重载了加法运算符：</p><blockquote><p>complex operator+(const complex &amp; A) const;</p></blockquote><p>当执行：</p><blockquote><p>c3 = c1 + c2;</p></blockquote><p>会被转换为：</p><blockquote><p>c3 = c1.operator+(c2);</p></blockquote><p>通过 this 指针隐式的访问 c1 的成员变量。</p><p><strong>将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。</strong></p><p>例如，下面这样是不对的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> + (<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> (a-b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><kbd>+</kbd>号原来是对两个数相加，现在企图通过重载使它的作用改为两个数相减， 如果允许这样重载的话，那么表达式<kbd>4+3</kbd>的结果是 7 还是 1 呢？显然，这是绝对禁止的。</p><p>如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是C ++内置类型的数据，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">int</span> a, <span class="built_in">complex</span> &amp;c)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a+c.real, c.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是使一个整数和一个复数相加。</p><p>另外，将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数。原因很简单，该函数大部分情况下都需要使用类的 private 成员。</p><p>上节的最后一个例子中，我们在全局范围内重载了<kbd>+</kbd>号，并在 complex 类中将运算符重载函数声明为友元函数，因为该函数使用到了 complex 类的 m_real 和 m_imag 两个成员变量，它们都是 private 属性的，默认不能在类的外部访问。</p><p>6) 箭头运算符<kbd>-></kbd>、下标运算符<kbd>[ ]</kbd>、函数调用运算符<kbd>( )</kbd>、赋值运算符<kbd>=</kbd>只能以成员函数的形式重载。</p><h1 id="C-重载数学运算符（实例演示）"><a href="#C-重载数学运算符（实例演示）" class="headerlink" title="C++重载数学运算符（实例演示）"></a>C++重载数学运算符（实例演示）</h1><p>四则运算符（+、-、*、/、+=、-=、*=、/=）和关系运算符（&gt;、&lt;、&lt;=、&gt;=、==、!=）都是数学运算符，它们在实际开发中非常常见，被重载的几率也很高，并且有着相似的重载格式。本节以复数类 Complex 为例对它们进行重载，重在演示运算符重载的语法以及规范。</p><p>复数能够进行完整的四则运算，但不能进行完整的关系运算：我们只能判断两个复数是否相等，但不能比较它们的大小，所以不能对 &gt;、&lt;、&lt;=、&gt;= 进行重载。下面是具体的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//构造函数</span></span><br><span class="line">    Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="comment">//以全局函数的形式重载</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="comment">//以成员函数的形式重载</span></span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line">    Complex &amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_real; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> m_imag; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-运算符</span></span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real - c2.m_real;</span><br><span class="line">    c.m_imag = c1.m_imag - c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*运算符  (a+bi) * (c+di) = (ac-bd) + (bc+ad)i</span></span><br><span class="line">Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = c1.m_real * c2.m_real - c1.m_imag * c2.m_imag;</span><br><span class="line">    c.m_imag = c1.m_imag * c2.m_real + c1.m_real * c2.m_imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载/运算符  (a+bi) / (c+di) = [(ac+bd) / (c²+d²)] + [(bc-ad) / (c²+d²)]i</span></span><br><span class="line">Complex <span class="keyword">operator</span>/(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.m_real = (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) / (<span class="built_in">pow</span>(c2.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c2.m_imag, <span class="number">2</span>));</span><br><span class="line">    c.m_imag = (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) / (<span class="built_in">pow</span>(c2.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c2.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real == c2.m_real &amp;&amp; c1.m_imag == c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载!=运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">if</span>( c1.m_real != c2.m_real || c1.m_imag != c2.m_imag )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real += c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag += c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>-=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real -= c.m_real;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag -= c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载*=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>*=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real = <span class="keyword">this</span>-&gt;m_real * c.m_real - <span class="keyword">this</span>-&gt;m_imag * c.m_imag;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag = <span class="keyword">this</span>-&gt;m_imag * c.m_real + <span class="keyword">this</span>-&gt;m_real * c.m_imag;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载/=运算符</span></span><br><span class="line">Complex &amp; Complex::<span class="keyword">operator</span>/=(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_real = (<span class="keyword">this</span>-&gt;m_real*c.m_real + <span class="keyword">this</span>-&gt;m_imag*c.m_imag) / (<span class="built_in">pow</span>(c.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_imag = (<span class="keyword">this</span>-&gt;m_imag*c.m_real - <span class="keyword">this</span>-&gt;m_real*c.m_imag) / (<span class="built_in">pow</span>(c.m_real, <span class="number">2</span>) + <span class="built_in">pow</span>(c.m_imag, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">25</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c4</span><span class="params">(<span class="number">4</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c5</span><span class="params">(<span class="number">34</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c6</span><span class="params">(<span class="number">80</span>, <span class="number">90</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    Complex c7 = c1 + c2;</span><br><span class="line">    Complex c8 = c1 - c2;</span><br><span class="line">    Complex c9 = c1 * c2;</span><br><span class="line">    Complex c10 = c1 / c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c7 = "</span>&lt;&lt;c7.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c7.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c8 = "</span>&lt;&lt;c8.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c8.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c9 = "</span>&lt;&lt;c9.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c9.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c10 = "</span>&lt;&lt;c10.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c10.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    c3 += c1;</span><br><span class="line">    c4 -= c2;</span><br><span class="line">    c5 *= c2;</span><br><span class="line">    c6 /= c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c3 = "</span>&lt;&lt;c3.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c3.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c4 = "</span>&lt;&lt;c4.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c4.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c5 = "</span>&lt;&lt;c5.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c5.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c6 = "</span>&lt;&lt;c6.real()&lt;&lt;<span class="string">" + "</span>&lt;&lt;c6.imag()&lt;&lt;<span class="string">"i"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(c1 == c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 == c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c1 != c2)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 != c2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>c7 = 35 + 55i<br>c8 = 15 + 15i<br>c9 = -450 + 850i<br>c10 = 1.9 + -0.3i<br>c3 = 26 + 37i<br>c4 = -6 + -11i<br>c5 = 220 + 4460i<br>c6 = 5.2 + 1.592i<br>c1 != c2   </p></blockquote><p>需要注意的是，我们以全局函数的形式重载了 +、-、*、/、==、!=，以成员函数的形式重载了 +=、-=、*=、/=，而且应该坚持这样做，不能一股脑都写作成员函数或者全局函数</p><h2 id="C-重载-gt-gt-和-lt-lt-（输入和输出运算符）详解"><a href="#C-重载-gt-gt-和-lt-lt-（输入和输出运算符）详解" class="headerlink" title="C++重载&gt;&gt;和&lt;&lt;（输入和输出运算符）详解"></a>C++重载&gt;&gt;和&lt;&lt;（输入和输出运算符）详解</h2><ul><li>重载输入运算符&gt;&gt;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, <span class="built_in">complex</span> &amp;A)&#123;</span><br><span class="line">    in &gt;&gt; A.m_real &gt;&gt; A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们以全局函数的形式重载&gt;&gt;，使它能够读入两个 double 类型的数据，并分别赋值给复数的实部和虚部：</p><p>istream 表示输入流，cin 是 istream 类的对象，只不过这个对象是在标准库中定义的。<strong>之所以返回 istream 类对象的引用，是为了能够连续读取复数</strong>，让代码书写更加漂亮，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> c1, c2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c1&gt;&gt;c2;</span><br></pre></td></tr></table></figure><p>如果不返回引用，那就只能一个一个地读取了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> c1, c2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c1;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c2;</span><br></pre></td></tr></table></figure><p>当输入 1.45 2.34↙ 后，这两个小数就分别成为对象 c 的实部和虚部了。</p><blockquote><p>cin&gt;&gt; c;</p></blockquote><p>这一语句其实可以理解为：</p><blockquote><p>operator&lt;&lt;(cin , c);</p></blockquote><ul><li>重载输出运算符&lt;&lt;</li></ul><p>同样地，我们也可以模仿上面的形式对输出运算符&gt;&gt;进行重载，让它能够输出复数，请看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="built_in">complex</span> &amp;A)&#123;</span><br><span class="line">    out &lt;&lt; A.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; A.m_imag &lt;&lt;<span class="string">" i "</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ostream 表示输出流，cout 是 ostream 类的对象。由于采用了引用的方式进行参数传递，并且也返回了对象的引用，所以重载后的运算符可以实现连续输出。</p><p>为了能够直接访问 complex 类的 private 成员变量，同样需要将该函数声明为 complex 类的友元函数：</p><blockquote><p>friend ostream &amp; operator&lt;&lt;(ostream &amp;out, complex &amp;A);</p></blockquote><p>综合演示:</p><p>结合输入输出运算符的重载，重新实现 complex 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span> <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in, <span class="built_in">complex</span> &amp; A);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; out, <span class="built_in">complex</span> &amp; A);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载加法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real + B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag + B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载减法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real - B.m_real;</span><br><span class="line">    C.m_imag = A.m_imag - B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载乘法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp;B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    C.m_real = A.m_real * B.m_real - A.m_imag * B.m_imag;</span><br><span class="line">    C.m_imag = A.m_imag * B.m_real + A.m_real * B.m_imag;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载除法运算符</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="built_in">complex</span> &amp; A, <span class="keyword">const</span> <span class="built_in">complex</span> &amp; B)&#123;</span><br><span class="line">    <span class="built_in">complex</span> C;</span><br><span class="line">    <span class="keyword">double</span> square = A.m_real * A.m_real + A.m_imag * A.m_imag;</span><br><span class="line">    C.m_real = (A.m_real * B.m_real + A.m_imag * B.m_imag)/square;</span><br><span class="line">    C.m_imag = (A.m_imag * B.m_real - A.m_real * B.m_imag)/square;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输入运算符</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in, <span class="built_in">complex</span> &amp; A)&#123;</span><br><span class="line">    in &gt;&gt; A.m_real &gt;&gt; A.m_imag;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输出运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; out, <span class="built_in">complex</span> &amp; A)&#123;</span><br><span class="line">    out &lt;&lt; A.m_real &lt;&lt;<span class="string">" + "</span>&lt;&lt; A.m_imag &lt;&lt;<span class="string">" i "</span>;;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">complex</span> c1, c2, c3;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c1&gt;&gt;c2;</span><br><span class="line"> </span><br><span class="line">    c3 = c1 + c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 + c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c3 = c1 - c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 - c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c3 = c1 * c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 * c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    c3 = c1 / c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1 / c2 = "</span>&lt;&lt;c3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>2.4 3.6↙<br>4.8 1.7↙<br>c1 + c2 = 7.2 + 5.3 i<br>c1 - c2 = -2.4 + 1.9 i<br>c1 * c2 = 5.4 + 21.36 i<br>c1 / c2 = 0.942308 + 0.705128 i   </p></blockquote><h2 id="C-重载-（下标运算符"><a href="#C-重载-（下标运算符" class="headerlink" title="C++重载[]（下标运算符)"></a>C++重载[]（下标运算符)</h2><p>C++ 规定，下标运算符[ ]必须以成员函数的形式进行重载。该重载函数在类中的声明格式如下：</p><blockquote><p>返回值类型 &amp; operator[ ] (参数);</p></blockquote><p>或者：</p><blockquote><p>const 返回值类型 &amp; operator[ ] (参数) const;</p></blockquote><p>使用第一种声明方式，[ ]不仅可以访问元素，还可以修改元素。使用第二种声明方式，[ ]只能访问而不能修改元素。在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为通过 const 对象只能调用 const 成员函数，如果不提供第二种形式，那么将无法访问 const 对象的任何元素。</p><p>下面我们通过自定义的 Array 类来实现变长数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> length = <span class="number">0</span>);</span><br><span class="line">    ~Array();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_length;  <span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">int</span> *m_p;  <span class="comment">//指向数组内存的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> length): m_length(length)&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">        m_p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m_p = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Array::display</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == m_length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;m_p[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;m_p[i]&lt;&lt;<span class="string">", "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="function">Array <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = A.length(); i &lt; len; i++)&#123;</span><br><span class="line">        A[i] = i * <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A.<span class="built_in">display</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">const</span> Array <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;B[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问最后一个元素</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>5↙<br>0, 5, 10, 15, 20<br>33685536   </p></blockquote><p>重载[ ]运算符以后，表达式arr[i]会被转换为：</p><blockquote><p>arr.operator<a href="i"> </a>;</p></blockquote><p>需要说明的是，B 是 const 对象，如果 Array 类没有提供 const 版本的operator[ ]，那么第 60 行代码将报错。虽然第 60 行代码只是读取对象的数据，并没有试图修改对象，但是它调用了非 const 版本的operator[ ]，编译器不管实际上有没有修改对象，只要是调用了非 const 的成员函数，编译器就认为会修改对象（至少有这种风险）。</p><h2 id="C-重载-和–（自增和自减运算符）"><a href="#C-重载-和–（自增和自减运算符）" class="headerlink" title="C++重载++和–（自增和自减运算符）"></a>C++重载++和–（自增和自减运算符）</h2><p>自增++和自减–都是一元运算符，它的前置形式和后置形式都可以被重载。如下例所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//秒表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stopwatch</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stopwatch(): m_min(<span class="number">0</span>), m_sec(<span class="number">0</span>)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setzero</span><span class="params">()</span></span>&#123; m_min = <span class="number">0</span>; m_sec = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">stopwatch <span class="title">run</span><span class="params">()</span></span>;  <span class="comment">// 运行</span></span><br><span class="line">    stopwatch <span class="keyword">operator</span>++();  <span class="comment">//++i，前置形式</span></span><br><span class="line">    stopwatch <span class="keyword">operator</span>++(<span class="keyword">int</span>);  <span class="comment">//i++，后置形式</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;( ostream &amp;, <span class="keyword">const</span> stopwatch &amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_min;  <span class="comment">//分钟</span></span><br><span class="line">    <span class="keyword">int</span> m_sec;  <span class="comment">//秒钟</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">stopwatch <span class="title">stopwatch::run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ++m_sec;</span><br><span class="line">    <span class="keyword">if</span>(m_sec == <span class="number">60</span>)&#123;</span><br><span class="line">        m_min++;</span><br><span class="line">        m_sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopwatch stopwatch::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopwatch stopwatch::<span class="keyword">operator</span>++(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    stopwatch s = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;( ostream &amp; out, <span class="keyword">const</span> stopwatch &amp; s)&#123;</span><br><span class="line">    out&lt;&lt;setfill(<span class="string">'0'</span>)&lt;&lt;setw(<span class="number">2</span>)&lt;&lt;s.m_min&lt;&lt;<span class="string">":"</span>&lt;&lt;setw(<span class="number">2</span>)&lt;&lt;s.m_sec;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stopwatch s1, s2;</span><br><span class="line"></span><br><span class="line">    s1 = s2++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s1: "</span>&lt;&lt; s1 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s2: "</span>&lt;&lt; s2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    s1.setzero();</span><br><span class="line">    s2.setzero();</span><br><span class="line"></span><br><span class="line">    s1 = ++s2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s1: "</span>&lt;&lt; s1 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s2: "</span>&lt;&lt; s2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>s1: 00:00<br>s2: 00:01<br>s1: 00:01<br>s2: 00:01   </p></blockquote><p>上面的代码定义了一个简单的秒表类，m_min 表示分钟，m_sec 表示秒钟，setzero() 函数用于秒表清零，run() 函数是用来描述秒针前进一秒的动作，接下来是三个运算符重载函数。</p><p>先来看一下 run() 函数的实现，run() 函数一开始让秒针自增，如果此时自增结果等于60了，则应该进位，分钟加1，秒针置零。</p><p>operator++() 函数实现自增的前置形式，直接返回 run() 函数运行结果即可。</p><p>operator++ (int n) 函数实现自增的后置形式，返回值是对象本身，但是之后再次使用该对象时，对象自增了，所以在该函数的函数体中，先将对象保存，然后调用一次 run() 函数，之后再将先前保存的对象返回。在这个函数中参数n是没有任何意义的，它的存在只是为了区分是前置形式还是后置形式。</p><p>自减运算符的重载与上面类似</p><h2 id="C-重载"><a href="#C-重载" class="headerlink" title="C++重载()"></a>C++重载()</h2><p>在 C++ 中，类型的名字（包括类的名字）本身也是一种运算符，即类型强制转换运算符。</p><p>类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。经过适当重载后，(类型名)对象这个对对象进行强制类型转换的表达式就等价于 <kbd>对象.operator 类型名()</kbd> ，即变成对运算符函数的调用。</p><p>下面的程序对 double 类型强制转换运算符进行了重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) :real(r), imag(i) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> real; &#125;  <span class="comment">//重载强制类型转换运算符 double</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1.2</span>, <span class="number">3.4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">double</span>)c &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1.2</span></span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">2</span> + c;  <span class="comment">//等价于 double n = 2 + c. operator double()</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n;  <span class="comment">//输出 3.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>程序的输出结果是：<br>1.2<br>3.2   </p></blockquote><p>第 8 行对 double 运算符进行了重载。重载强制类型转换运算符时，不需要指定返回值类型，因为返回值类型是确定的，就是运算符本身代表的类型，在这里就是 double。</p><p>重载后的效果是，第 13 行的 (double)c 等价于 c.operator double()。</p><p>有了对 double 运算符的重载，在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用。</p><p>例如第 14 行，编译器认为本行中c这个位置如果出现的是 double 类型的数据，就能够解释得通，而 Complex 类正好重载了 double 运算符，因而本行就等价于：</p><blockquote><p>double n = 2 + c.operator double();</p></blockquote><h2 id="C-运算符重载注意事项以及汇总"><a href="#C-运算符重载注意事项以及汇总" class="headerlink" title="C++运算符重载注意事项以及汇总"></a>C++运算符重载注意事项以及汇总</h2><p>在 C++ 中进行运算符重载时，有以下问题需要注意：</p><ul><li>重载后运算符的含义应该符合原有用法习惯。例如重载+运算符，完成的功能就应该类似于做加法，在重载的+运算符中做减法是不合适的。此外，重载应尽量保留运算符原有的特性。</li><li>C++ 规定，运算符重载不改变运算符的优先级。</li><li>以下运算符不能被重载：<kbd>.</kbd>、<kbd>.*</kbd>、<kbd>::</kbd>、<kbd>? :</kbd>、<kbd>sizeof</kbd>。</li><li>重载运算符<kbd>()</kbd>、<kbd>[]</kbd>、<kbd>-></kbd>、或者赋值运算符<kbd>=</kbd>时，只能将它们重载为成员函数，不能重载为全局函数。</li></ul><p>运算符重载的实质是将运算符重载为一个函数，使用运算符的表达式就被解释为对重载函数的调用。</p><p>运算符可以重载为全局函数。此时函数的参数个数就是运算符的操作数个数，运算符的操作数就成为函数的实参。</p><p>运算符也可以重载为成员函数。此时函数的参数个数就是运算符的操作数个数减一，运算符的操作数有一个成为函数作用的对象，其余的成为函数的实参。</p><p>必要时需要重载赋值运算符=，以避免两个对象内部的指针指向同一片存储空间。</p><p>运算符可以重载为全局函数，然后声明为类的友元。</p><p>&lt;&lt; 和 &gt;&gt;是在 iostream 中被重载，才成为所谓的“流插入运算符”和“流提取运算符”的。</p><p>类型的名字可以作为强制类型转换运算符，也可以被重载为类的成员函数。它能使得对象被自动转换为某种类型。</p><p>自增、自减运算符各有两种重载方式，用于区别前置用法和后置用法。</p><p>运算符重载不改变运算符的优先级。重载运算符时，应该尽量保留运算符原本的特性。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 运算符重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串操作</title>
      <link href="/2020/05/06/c-string/"/>
      <url>/2020/05/06/c-string/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h2><p>有了 string 类，我们可以使用 <strong>+</strong> 或 <strong>+=</strong> 运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的 strcat()、strcpy()、malloc() 等函数来拼接字符串了，再也不用担心空间不够会溢出了。</p><p>用+来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个字符数组，或者是一个 string 字符串和一个单独的字符。请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first "</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"second "</span>;</span><br><span class="line">    <span class="keyword">char</span> *s3 = <span class="string">"third "</span>;</span><br><span class="line">    <span class="keyword">char</span> s4[] = <span class="string">"fourth "</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'@'</span>;</span><br><span class="line">    <span class="built_in">string</span> s5 = s1 + s2;</span><br><span class="line">    <span class="built_in">string</span> s6 = s1 + s3;</span><br><span class="line">    <span class="built_in">string</span> s7 = s1 + s4;</span><br><span class="line">    <span class="built_in">string</span> s8 = s1 + ch;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s5&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s6&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s7&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s8&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果:<br> first second<br> first third<br> first fourth<br> first @</p></blockquote><h2 id="string-字符串的增删改查"><a href="#string-字符串的增删改查" class="headerlink" title="string 字符串的增删改查"></a>string 字符串的增删改查</h2><p>C++ 提供的 string 类包含了若干实用的成员函数，大大方便了字符串的增加、删除、更改、查询等操作。</p><h3 id="一-插入字符串"><a href="#一-插入字符串" class="headerlink" title="一. 插入字符串"></a>一. 插入字符串</h3><p>insert() 函数可以在 string 字符串中指定的位置插入另一个字符串，它的一种原型为：</p><figure class="highlight plain"><figcaption><span>insert (size_t pos, const string& str);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;pos 表示要插入的位置，也就是下标；str 表示要插入的字符串，它可以是 string 字符串，也可以是C风格的字符串。</span><br><span class="line"></span><br><span class="line">请看下面的代码：</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 &#x3D; s2 &#x3D; &quot;1234567890&quot;;</span><br><span class="line">    s3 &#x3D; &quot;aaa&quot;;</span><br><span class="line">    s1.insert(5, s3);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    s2.insert(5, &quot;bbb&quot;);</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>12345aaa67890<br>12345bbb67890</p></blockquote><p>insert() 函数的第一个参数有越界的可能，如果越界，则会产生运行时异常。</p><h3 id="二-删除字符串"><a href="#二-删除字符串" class="headerlink" title="二. 删除字符串"></a>二. 删除字符串</h3><p>erase() 函数可以删除 string 中的一个子字符串。它的一种原型为：</p><figure class="highlight plain"><figcaption><span>erase (size_t pos </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;pos 表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len &#x3D; str.length - pos）。</span><br><span class="line"></span><br><span class="line">请看下面的代码：</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 &#x3D; s2 &#x3D; s3 &#x3D; &quot;1234567890&quot;;</span><br><span class="line">    s2.erase(5);</span><br><span class="line">    s3.erase(5, 3);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s3 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>1234567890<br>12345<br>1234590</p></blockquote><p>可能会有这样的担心，在 pos 参数没有越界的情况下， len 参数也可能会导致要删除的子字符串越界。但实际上这种情况不会发生，erase() 函数会从以下两个值中取出最小的一个作为待删除子字符串的长度：</p><blockquote><p>len 的值<br>字符串长度减去 pos 的值。</p></blockquote><p>说得简单一些，待删除字符串最多只能删除到字符串结尾。</p><h3 id="三-提取子字符串"><a href="#三-提取子字符串" class="headerlink" title="三. 提取子字符串"></a>三. 提取子字符串</h3><p>substr() 函数用于从 string 字符串中提取子字符串，它的原型为：</p><figure class="highlight plain"><figcaption><span>substr (size_t pos </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。</span><br><span class="line"></span><br><span class="line">请看下面的代码：</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1 &#x3D; &quot;first second third&quot;;</span><br><span class="line">    string s2;</span><br><span class="line">    s2 &#x3D; s1.substr(6, 6);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br> first second third<br> second</p></blockquote><p>系统对 substr() 参数的处理和 erase() 类似：</p><ul><li>如果 pos 越界，会抛出异常；</li><li>如果 len 越界，会提取从 pos 到字符串结尾处的所有字符。</li></ul><h3 id="四-字符串查找"><a href="#四-字符串查找" class="headerlink" title="四. 字符串查找"></a>四. 字符串查找</h3><p>string 类提供了几个与字符串查找有关的函数，如下所示。<br><strong>1)  find() 函数</strong><br>find() 函数用于在 string 字符串中查找子字符串出现的位置，它其中的两种原型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t find (const string&amp; str, size_t pos &#x3D; 0) const;  </span><br><span class="line">size_t find (const char* s, size_t pos &#x3D; 0) const;</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。</p></blockquote><p>请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first second third"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"second"</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.<span class="built_in">find</span>(s2,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.length())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Found at index : "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Found at index : 6</p></blockquote><p>find() 函数最终返回的是子字符串第一次出现在字符串中的起始下标。本例最终是在下标6处找到了 s2 字符串。如果没有查找到子字符串，那么会返回一个无穷大值 4294967295。</p><p><strong>2) rfind() 函数</strong>   </p><p>rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。</p><p>请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first second third"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"second"</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.rfind(s2,<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.length())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Found at index : "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Found at index : 6   </p></blockquote><p><strong>3) find_first_of() 函数</strong>  </p><p><strong>find_first_of()</strong> 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"first second second third"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"asecond"</span>;</span><br><span class="line">    <span class="keyword">int</span> index = s1.find_first_of(s2);</span><br><span class="line">    <span class="keyword">if</span>(index &lt; s1.length())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Found at index : "</span>&lt;&lt; index &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not found"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>Found at index : 3</p></blockquote><p>本例中 s1 和 s2 共同具有的字符是 ’s’，该字符在 s1 中首次出现的下标是3，故查找结果返回3。</p>]]></content>
      
      
      <categories>
          
          <category> c++笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表总结</title>
      <link href="/2020/05/04/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/04/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><strong>链表的定义（来自维基百科）</strong>：</p><p>在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（“links”）。</p><p><strong>链表与顺序表的区别（来自维基百科）</strong>：</p><p>链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p><p><strong>顺序表与数组的区别</strong>：</p><p>顺序表是在计算机内存中以数组的形式保存的线性表。</p><p>顺序表是指用一组地址连续的存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表，顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。线性表采用指针链接的方式存储就称之为链表。</p><p>线性表是从逻辑结构的角度来说的，除了头和尾之外，它的每一个元素都只有一个前驱元素和一个后驱元素。各种队列（单向、双向、循环队列），栈等都是线性表的不同例子。</p><p>而数组是从物理存贮的角度来说的，线性表可以用数组存贮也可以用链表来存贮。同样的队列和栈也可以用数组和链表存贮，各有利弊。具体使用时，根据具体情况选择。 </p><p>所以说，数组是一个更大的概念。使用数组，不但可以存储线性表，也可存储非线性结构的数据结构。比如堆、完全二叉树、乃至于其它类型的树、图等。</p><p>顺序表与数组都是数据结构，只是描述角度不同。顺序表是从逻辑结构的角度来说的，它的每一个元素都只有一个前驱元素和一个后驱元素除了头和尾，逻辑结构还有队列，堆栈，树，图等。而数组是从物理存贮的角度来说的，顺序表用数组存贮也可以用链表来存贮。同样的队列也可以用数组和链表存贮，各有利弊。具体使用时，根据具体情况选择。</p><blockquote><ol><li>数组就是相同数据类型的元素按一定顺序排列的集合。</li></ol><p>一句话：就是物理上存储在一组联系的地址上。也称为数据结构中的物理结构。</p><ol start="2"><li>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。</li></ol><p>一句话：线性表是数据结构中的逻辑结构。可以存储在数组上，也可以存储在链表上。</p><ol start="3"><li>线性表的结点按逻辑次序依次存放在一组地址连续的存储单元里的方法。用顺序存储方法存储的线性表简称为顺序表。</li></ol><p>一句话：用数组来存储的线性表就是顺序表。</p></blockquote><p><strong>链表的优缺点（来自维基百科）</strong>：</p><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。<br>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p><p><strong>链表的类型（来自维基百科）</strong>：</p><p>单向链表，双向链表以及循环链表。</p><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p><strong>单向链表的定义：</strong></p><p>单向链表是链表类型中最为简单的一种，每个节点包含两个域，一个数据域(data)，一个指针域(next)。单向链表的next节点指向下一节点，而尾节点的next节点为空。</p><p><strong>单向链表节点的定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504153648.png" alt="20200504153648"></p><p><strong>单链表的模板：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListForward</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode* head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyListForward():head(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获得链表中第index个节点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p)<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果为第index节点值为空值则返回-1；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、在链表头部插一个值为val的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode *p=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        p-&gt;next=head;</span><br><span class="line">        head=p;<span class="comment">//更换头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、在链表尾部添加一个值为val的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode *p=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="comment">//链表为空，直接将新节点作为头节点</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head=p;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *q=head;</span><br><span class="line">        <span class="comment">//遍历直到q的next节点为空</span></span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next)&#123;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、在索引为index的节点之前添加值为val的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="comment">//1、index小于等于0，直接在头部插入节点</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">//若index小于等于0，我们仅需要在头节点前面插入新节点就行了</span></span><br><span class="line">        <span class="comment">//注意这里不能使用指针p，因为p=node时，p所指向的地址发生了变化，head指向的地址没有变化，所以我们这里要使用指针head</span></span><br><span class="line">            node-&gt;next=head;</span><br><span class="line">            head=node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="comment">//在索引为index的节点之前插入新节点，我们需要找到它的前驱节点，然后插入在它的前驱节点后面</span></span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、p为索引节点的前驱节点</span></span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next=p-&gt;next;</span><br><span class="line">            p-&gt;next=node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、删除索引为index的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、index为0，我们直接删除head节点</span></span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>&amp;&amp;head!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *del=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="comment">//删除索引为index的节点，我们需要找到它的前驱节点p，p-&gt;next为需要删除节点</span></span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、index超过链表范围，删除失败</span></span><br><span class="line">        <span class="keyword">if</span>(!p)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//3、index的位置合法，我们找到需要删除的p-&gt;next节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *del=p-&gt;next;</span><br><span class="line">            p-&gt;next=del-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、清空链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ListNode *del=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            del=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyListForward mlf;</span><br><span class="line">    mlf.addAtIndex(<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    mlf.addAtIndex(<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">    mlf.addAtIndex(<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mlf.length();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mlf.<span class="built_in">get</span>(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    mlf.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;mlf.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><strong>双向链表的定义：</strong></p><p>双向链表是一种更为复杂的链表，每个节点包含三个域，一个数据域(data)和两个指针域(prev、next)，其中数据域存放节点的数值，prev指向该节点的前一个节点，next指向该节点的后一个节点。</p><p><strong>双向链表节点的定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next,*prev;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>),prev(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504155110.png" alt="20200504155110"></p><p><strong>双向链表的模板：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *next,*prev;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">nullptr</span>),prev(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//头节点尾节点都为空，表示为空链表</span></span><br><span class="line">    ListNode *head,*tail;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyList():<span class="built_in">size</span>(<span class="number">0</span>),head(<span class="literal">nullptr</span>),tail(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获得索引为index的节点值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;i&lt;index)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p)<span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、在头部插入值为val的新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            node-&gt;next=head;</span><br><span class="line">            head-&gt;prev=node;</span><br><span class="line">            head=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            tail=head;</span><br><span class="line">        &#125;</span><br><span class="line">        ++<span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、在尾部插入值为val的新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            node-&gt;prev=tail;</span><br><span class="line">            tail-&gt;next=node;</span><br><span class="line">            tail=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//尾节点为空，那么头节点也为空，然后首尾节点都为新节点</span></span><br><span class="line">            tail=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">            head=tail;</span><br><span class="line">        &#125;</span><br><span class="line">        ++<span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、在index之前添加值为val的新节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先排除三种特殊情况的index，然后剩下来的index肯定在链表内</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="built_in">size</span>)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;<span class="built_in">size</span>)<span class="keyword">return</span>;</span><br><span class="line">        ListNode *p=<span class="literal">nullptr</span>,*cur=head;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur&amp;&amp;i&lt;index)&#123;</span><br><span class="line">            p=cur;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *node=<span class="keyword">new</span> ListNode(val);</span><br><span class="line">        <span class="comment">//由于前面已经将特殊情况的index排除了，现在的p和cur都有效，都在链表内</span></span><br><span class="line">        p-&gt;next=node;</span><br><span class="line">        node-&gt;prev=p;</span><br><span class="line">        node-&gt;next=cur;</span><br><span class="line">        cur-&gt;prev=node;</span><br><span class="line">        <span class="built_in">size</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、删除索引为index的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//链表为空时，不能删除</span></span><br><span class="line">        <span class="keyword">if</span>(!head)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *del=head;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(head)&#123;<span class="comment">//链表有2个以上节点</span></span><br><span class="line">                head-&gt;prev=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//链表只有一个节点，将尾部制空</span></span><br><span class="line">                tail=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">            <span class="built_in">size</span>--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//index为最后为尾节点，我们需要删除尾节点</span></span><br><span class="line">        <span class="keyword">if</span>(index==<span class="built_in">size</span><span class="number">-1</span>)&#123;</span><br><span class="line">            ListNode *del=tail;</span><br><span class="line">            tail=tail-&gt;prev;</span><br><span class="line">            <span class="comment">//注意这里不用处理tail为空，因为tail为空的话，那么链表只有单个节点</span></span><br><span class="line">            <span class="comment">//然而单个节点只能删除0号节点，只有index为0时才能删除，前面已经处理过了index为0的情况了，所以这里不在处理</span></span><br><span class="line">            <span class="keyword">if</span>(tail)&#123;</span><br><span class="line">                tail-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">            <span class="built_in">size</span>--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        ListNode *p=<span class="literal">nullptr</span>,*cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==index)&#123;</span><br><span class="line">                ListNode *del=cur;</span><br><span class="line">                p-&gt;next=cur-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next)&#123;</span><br><span class="line">                    cur-&gt;next-&gt;prev=p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> del;</span><br><span class="line">                <span class="built_in">size</span>--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=cur;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、获得链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、清空链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">size</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            deleteAtIndex(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyList ml;</span><br><span class="line">    ml.addAtHead(<span class="number">1</span>);</span><br><span class="line">    ml.addAtTail(<span class="number">3</span>);</span><br><span class="line">    ml.addAtHead(<span class="number">4</span>);</span><br><span class="line">    ml.addAtHead(<span class="number">5</span>);</span><br><span class="line">    ml.addAtIndex(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ml.length();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ml.<span class="built_in">get</span>(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ml.deleteAtIndex(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ml.length();++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ml.<span class="built_in">get</span>(i)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ml.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ml.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p><strong>环形链表的定义：</strong></p><p>循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存， 假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。<br><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200504155514.png" alt="20200504155514"></p><h1 id="习题解析"><a href="#习题解析" class="headerlink" title="习题解析"></a>习题解析</h1><h2 id="链表中的双指针技巧"><a href="#链表中的双指针技巧" class="headerlink" title="链表中的双指针技巧"></a>链表中的双指针技巧</h2><p><a href="https://xiaoneng.blog.csdn.net/article/details/97423144" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a>：<strong>快慢指针法</strong>，起始快指针走n步后，若此时快指针已为空，表示我们删除第一个节点，直接返回head-&gt;next即可；否则此时快慢指针一起走，也就是慢指针走size-n步到达倒数第N个节点的前驱节点，快指针会到达链表的尾节点，此时我们删除slow-&gt;next节点即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103322178" target="_blank" rel="noopener">86. 分隔链表</a>：<strong>双指针法</strong>，before_head链表存放比x小的节点，after_head链表存放比x大于或等于的节点，我们分别用before和after来前面两个链表添加节点，用head来遍历原始链表。当原始链表遍历完成时，我们需要将before_head链表连接上after_head链表，即before-&gt;next=after_head-&gt;next;after-&gt;next=nullptr;。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/103648554" target="_blank" rel="noopener">92. 反转链表 II</a>：<strong>双指针法</strong>，指针pre指针指向m的前驱节点，用来将cur的next节点插入到pre后面，指针cur指向位置m起始节点，该节点保持不变，每次需要将cur连接上nxt后边的部分。换句话说，我们要将[m+1,n]的节点每次都要插到位置m之前，这样就完成了反转。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97416410" target="_blank" rel="noopener">141. 环形链表</a>：<strong>快慢指针法</strong>，若存在环最终快慢指针会相遇；若不存在环，那么快指针一定会先走到链表尾部。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97420675" target="_blank" rel="noopener">142. 环形链表 II</a>：<strong>快慢指针法</strong>，首先利用141的代码判断是否存在环，然后相遇之后将fast指针指向头节点，然后fast和slow现在开始每次走一步，相遇点就是环的入口。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103588663" target="_blank" rel="noopener">143. 重排链表</a>：<strong>首尾指针法</strong>，首先将原始链表的每一个节点存放在一个数组中，然后我们取首尾指针向中间遍历，每次循环我们需要将左指针的节点连上右指针的节点，在节点连上之后，我们需要将右指针连上未排序的首节点。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97421357" target="_blank" rel="noopener">160. 相交链表</a>：本题也属于<strong>快慢指针法</strong>，具体思路更抽象的说就是将链表AB分别变成了A-&gt;B和B-&gt;A（这里假设A更短一点），这里我们用ha遍历A-&gt;B，hb遍历B-&gt;A，然后ha指针先走到A-B的B部分，hb指针还在走在B-A的B部分，当hb走到B-A的A部分时，最终二者会相遇，而相遇部分就是公共部分。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103445269" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a>：<strong>快慢指针法</strong>，用两个指针，一块一慢，快的每次走两步，慢的每次走一步，这样当快指针遍历结束时，慢指针指向的也就是链表的中间位置。这时候把中间位置的节点的值作为二叉搜索树根节点的值。因为二叉搜索树对应的就是一个有序数组，根节点对应的元素值为为有序数组最中间的位置。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/100934558" target="_blank" rel="noopener">206. 反转链表</a>：<strong>双指针法</strong>，指针pre用来表示前驱节点，指针cur用来遍历链表，每次循环改变将pre-&gt;cur的方向改变为pre&lt;-cur，直到遍历结束。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/104034708" target="_blank" rel="noopener">234. 回文链表</a>：<strong>快慢指针法</strong>，快指针走两步，慢指针走一步，找到链表的中点。然后，翻转后半部分。最后从前半部分链表和后半部分链表是否相同。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103995590" target="_blank" rel="noopener">876. 链表的中间结点</a>：<strong>快慢指针法</strong>，快指针走两步，慢指针走一步，等快指针走到链表尾节点时，慢指针的位置就是中位数的位置。</p><h2 id="链表排序问题"><a href="#链表排序问题" class="headerlink" title="链表排序问题"></a>链表排序问题</h2><p><a href="https://blog.csdn.net/qq_43152052/article/details/103662802" target="_blank" rel="noopener">147. 对链表进行插入排序</a>：<strong>插入排序</strong>，我们每次用head-&gt;next来进行插入排序，每次插入排序，我们需要从链表的头部开始寻找插入点，所以我们使用一个指针pre来寻找插入点，若pre-&gt;next的节点值大于等于head-&gt;next的节点时，我们的插入位置就是pre-&gt;next，这里处理起来可能麻烦点，大家仔细看代码即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103661851" target="_blank" rel="noopener">148. 排序链表</a>：<strong>归并排序</strong>，先2个2个的 merge，完成一趟后，再 4个4个的 merge，直到结束。</p><h2 id="链表经典题目"><a href="#链表经典题目" class="headerlink" title="链表经典题目"></a>链表经典题目</h2><p><a href="https://blog.csdn.net/qq_43152052/article/details/89285335" target="_blank" rel="noopener">2. 两数相加</a>：<strong>模拟题</strong>，由于链表是逆序存放数字的，所以链表数字从左至右低位对低位，高位对高位，因此我们从左至右遍历两个链表模拟加法运算即可，注意向高位进位。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/97426128" target="_blank" rel="noopener">21. 合并两个有序链表</a>：<strong>模拟题</strong>，每次循环比较l1-&gt;val和l2-&gt;val，若l1-&gt;val<l2->val，则在cur后面添加l1；否则在cur后面添加l2。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103183470" target="_blank" rel="noopener">23. 合并K个排序链表</a>：<strong>方法1：分治法</strong>，将k个链表利用二分分为k个独立子链表，然后两两进行合并，最后形成一个排序链表。<strong>方法2：优雅的暴力法</strong>，利用队列queue来实现两两链表的组合，首先将队列前两个链表合并成一个，然后添加到队列的尾部，直到队列中只有一个链表时，表示k个链表已经合成了。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/100888248" target="_blank" rel="noopener">24. 两两交换链表中的节点</a>：<strong>简单递归</strong>，每次递归交换head与nxt即可，也就是完成了两两交换链表中的节点。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103324877" target="_blank" rel="noopener">25. K 个一组翻转链表</a>：<strong>分治法</strong>，将链表按长度k进行分组，然后每次翻转长度k的链表，注意翻转了长度k的链表后新链表的尾部还要连接未翻转部分。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/89366849" target="_blank" rel="noopener">61. 旋转链表</a>：<strong>模拟题</strong>，先求出链表长度size，若k取余size为空，那么不用旋转了，直接返回head；否则将链表首尾相连形成环形链表，由于k表示尾节点移动k%size位，那么头节点移动size-k%size位。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103544889" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a>：<strong>模拟题</strong>，遍历链表，若head的节点值与head的next节点值不相等，则pre指向head，也就是不重复节点；若相等，我们需要找到重复值子链表的最后一个节点，然后令pre指向head-&gt;next，同时head移动到下一个节点。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103533398" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a>：<strong>模拟题</strong>，直接遍历链表，遇到重复值的节点删除即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/89323912" target="_blank" rel="noopener">138. 复制带随机指针的链表</a>：<strong>模拟题</strong>，分三步，第一步在原链表的每个节点后面拷贝出一个新的节点，第二步拷贝random，第三步断开链表。</p><p><a href="https://xiaoneng.blog.csdn.net/article/details/104033912" target="_blank" rel="noopener">203. 移除链表元素</a>：<strong>模拟题</strong>，直接遍历链表确定是否删除节点即可。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103996408" target="_blank" rel="noopener">445. 两数相加 II</a>：<strong>双栈法</strong>，将两个链表节点值全部压入栈中，然后每次去栈顶元素进行相加，因为这样保证了低位和低位相加，不会出现错位现象。最后直到两个栈为空且进位为0为止，就表示相加完成了。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103995776" target="_blank" rel="noopener">725. 分隔链表</a>：<strong>模拟题</strong>，首先求出链表的长度，然后根据k来求得每段链表的平均长度，顺便求出余数。由于题目要求每部分长度相差不能超过1，而且排在前面的部分长度要大于后面部分的长度，所以我们根据余数的个数，给排在前面的部分长度+1。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/89304371" target="_blank" rel="noopener">430. 扁平化多级双向链表</a>：<strong>模拟题</strong>，迭代法，遍历链表，若发现该链表存在child节点那么就将[child,tail]这段子链表插入到当前节点的后面去，然后继续遍历链表。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103997681" target="_blank" rel="noopener">817. 链表组件</a>：<strong>模拟题</strong>，如果当前的节点在列表G中，并且下一个节点不在列表G中，我们就找到了一个组件的尾节点，将res加1。</p><p><a href="https://blog.csdn.net/qq_43152052/article/details/103997711" target="_blank" rel="noopener">1171. 从链表中删去总和值为零的连续节点</a>：<strong>模拟题</strong>，直接遍历链表进行删除和为0的连续子链表。</p><blockquote><p>文章转载：<a href="https://xiaoneng.blog.csdn.net/article/details/104007259" target="_blank" rel="noopener">algsup</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0503leetcode</title>
      <link href="/2020/05/03/0503leetcode/"/>
      <url>/2020/05/03/0503leetcode/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0502leetcode</title>
      <link href="/2020/05/02/0502leetcode/"/>
      <url>/2020/05/02/0502leetcode/</url>
      
        <content type="html"><![CDATA[<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><center><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502162145.png" alt="20200502162145"></p></center><p><strong>解题思路：</strong></p><center><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502162430.png" alt="20200502162430"></p></center><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">           fast =fast-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">               fast = fast-&gt;next; </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//else break;</span></span><br><span class="line">           slow =slow-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">               <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(fast == head)</span><br><span class="line">                   <span class="keyword">return</span> fast;</span><br><span class="line">                   fast = fast-&gt;next;</span><br><span class="line">                   head = head-&gt;next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h3><center><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502164548.png" alt="20200502164548"></p></center><p><strong>解题思路：</strong></p><ol><li><p>为链表设置虚拟头结点<strong>dummyhead</strong>，链表设置虚拟头结点dummyhead，这样对链表来说，第一个元素就是dummyhead的next所对应的节点元素，而不是dummyhead所对应的节点元素。dummyhead位置所对应的元素是根本不存在的，这只是未来我们编写逻辑方便而出现的一个虚拟头结点。dummyhead就是索引为0的这个位置的元素的前一个节点。当我们有了dummyhead后，为链表添加一个元素，就不需要对头结点进行特殊处理了，只需要找到等待添加位置的前一个位置的节点，<strong>此时对于链表来说，所有位置都有前一个节点。</strong></p></li><li><p>代码主要分为两部分，一部分负责切割链接，另一部分负责将切割下来的链表反转并将链表头指针返回。</p></li><li><p>Tail的使用</p></li></ol><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/20200502171941.png" alt="20200502171941"></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span> || head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* Tail = dummy;<span class="comment">//Tail是当前已经确定的尾部</span></span><br><span class="line">        <span class="comment">//ListNode* Head = head;//还没有确定的首部</span></span><br><span class="line">        ListNode* p=head;<span class="comment">//游标</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((p != <span class="literal">NULL</span>) &amp;&amp; (count &lt; k)) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; k) &#123;<span class="comment">//如果小于k个，则用上一个模块的Tail直接连接首部就可以</span></span><br><span class="line">                Tail-&gt;next = head;</span><br><span class="line">                <span class="keyword">return</span> dummy-&gt;next;<span class="comment">//输出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果不小于k个，</span></span><br><span class="line">                Tail-&gt;next = reversegroup(head, k);<span class="comment">//更新已经确定的尾部</span></span><br><span class="line">                <span class="keyword">while</span> (Tail-&gt;next != <span class="literal">NULL</span>)Tail = Tail-&gt;next;<span class="comment">//更新Tail，把Tail更新到指向为空</span></span><br><span class="line">                head = p;<span class="comment">//更新没有确定的首部</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reversegroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;<span class="comment">//从abcd变成bcda</span></span><br><span class="line">        ListNode* cur;</span><br><span class="line">        ListNode* tail;<span class="comment">//当前已经完成翻转的链表的第一个节点</span></span><br><span class="line">        ListNode* ahead;<span class="comment">//存储旧链表中cur指向的节点</span></span><br><span class="line">        tail = <span class="literal">nullptr</span>;</span><br><span class="line">        cur = <span class="literal">nullptr</span>;</span><br><span class="line">        ahead = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; k) &#123;</span><br><span class="line">            cur = ahead;</span><br><span class="line">            ahead = cur-&gt;next;<span class="comment">//存储旧链表中cur指向的节点</span></span><br><span class="line">            cur-&gt;next = tail;<span class="comment">//指向已经完成翻转的链表的第一个节点</span></span><br><span class="line">            tail = cur;<span class="comment">//更新tail</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        ahead-&gt;next = tail;</span><br><span class="line">        <span class="keyword">return</span> ahead;<span class="comment">//返回小模块的第一个节点，用以作为连接外层循环Tail指向的对象</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/05/01/test/"/>
      <url>/2020/05/01/test/</url>
      
        <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1111111</p><p><img src="https://raw.githubusercontent.com/Wonderperson/picturebed/master/imags_for_study/%E5%88%86%E7%B1%BB-%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B.png" alt="分类-守望先锋"></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/01/hello-world/"/>
      <url>/2020/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
